               INCLUDE HPFIXUPS
               TITLE "LCD"
***************************************************************************************************
***************************************************************************************************
***                                                                                             ***
***            LCD - MODEL 440 LCD DRIVER ROUTINES                                              ***
***                                                                                             ***
***************************************************************************************************
***************************************************************************************************
;
NEG_EXT        EQU     0FFFFFF00H      ;USE IN MOVEQ INSTRUCTIONS WHERE ARG IS
                                       ;80H OR LARGER - HP XASM DOES NOT HANDLE
                                       ;SIGN-EXTEND CORRECTLY.  COSMETIC, KEEPS
                                       ;ACTUAL BYTE VALUE CLEARER.
;
               INCLUDE EQUATES         ;HDW ADDR AND CONSTANT DEFS, ABS_SHORT DIRECTIVE.
;
               .export LCD_FUN_TBL
               .export INIT_LCD
               .export LCDWAIT
               .export WRITE_SCREEN
               .export WRITE_PARAM_VALUE
               .export WRITE_VALUE
               .export WRITE_PARAM_STRING
               .export WRITE_STRING
               .export WRITE_A0_STRING
               .export DISP_SCREEN
               .export DISP_STRING
               .export DISP_BUFFER
               .export DISP_PARAM_FIELD
               .export DISP_FIELD
               .export DISP_HEX
               .export LONG_BIN_TO_BCD
               .export WORD_BIN_TO_BCD
               .export INSERT_DECIMAL_PT
               .export BLANK_ZEROES
               .export WRITE_BCD_DIGITS
               .export SET_SIGN_CHAR
               .export WRITE_SIGN_CHAR
               .export UPDATE_CURSOR
               .export STORE_GRAPHICS
               .export WRITE_HEX_PARAM
               .export WRITE_HEX_VALUE
               .export WRITE_ENCODED_SCREEN
               .export DISP_ENCODED_SCREEN
;
               EXTERNAL  SCREEN_BUFFER
               EXTERNAL  DECIMAL_POINT
               EXTERNAL  PARAM_SIZE
               EXTERNAL  PARAM_BUFFER
               EXTERNAL  SIGN_ENABLE
               EXTERNAL  STRING_AT_MIN
               EXTERNAL  PARAM_LO_LIM
               EXTERNAL  STRING_AT_MAX
               EXTERNAL  PARAM_HI_LIM
               EXTERNAL  DISPLAY_OFFSET
               EXTERNAL  DISPLAY_SCALE
               EXTERNAL  ZERO_BLANKING
               EXTERNAL  DISP_STRNG_PTR
               EXTERNAL  UPDATE_LCD
               EXTERNAL  CURSOR_STAT
               EXTERNAL  BCD_DIGITS
               EXTERNAL  SIGN_CHAR
               EXTERNAL  POSITION_CURS
               EXTERNAL  ROUSING_GUIDO
               EXTERNAL  CUR_FLD_INDEX
               EXTERNAL  TEMP_FLD_INDEX
               SKIP

;
;
; FUNCTION TABLE FOR LCD FUNCTIONS IN THIS MODULE:
; THIS REALLY OUGHTA COME BEFORE ANY OF THE FUNCTIONS IT REFERS TO.
;
LCD_FUN_TBL
               DC.W    INIT_LCD-LCD_FUN_TBL
               DC.W    LCDWAIT-LCD_FUN_TBL
               DC.W    WRITE_SCREEN-LCD_FUN_TBL
               DC.W    WRITE_PARAM_VALUE-LCD_FUN_TBL
               DC.W    WRITE_VALUE-LCD_FUN_TBL
               DC.W    WRITE_PARAM_STRING-LCD_FUN_TBL
               DC.W    WRITE_A0_STRING-LCD_FUN_TBL
               DC.W    WRITE_STRING-LCD_FUN_TBL
               DC.W    DISP_SCREEN-LCD_FUN_TBL
               DC.W    DISP_STRING-LCD_FUN_TBL
               DC.W    DISP_BUFFER-LCD_FUN_TBL
               DC.W    DISP_PARAM_FIELD-LCD_FUN_TBL
               DC.W    DISP_FIELD-LCD_FUN_TBL
               DC.W    DISP_HEX-LCD_FUN_TBL
               DC.W    LONG_BIN_TO_BCD-LCD_FUN_TBL
               DC.W    WORD_BIN_TO_BCD-LCD_FUN_TBL
               DC.W    INSERT_DECIMAL_PT-LCD_FUN_TBL
               DC.W    BLANK_ZEROES-LCD_FUN_TBL
               DC.W    WRITE_BCD_DIGITS-LCD_FUN_TBL
               DC.W    SET_SIGN_CHAR-LCD_FUN_TBL
               DC.W    WRITE_SIGN_CHAR-LCD_FUN_TBL
               DC.W    UPDATE_CURSOR-LCD_FUN_TBL
               DC.W    STORE_GRAPHICS-LCD_FUN_TBL
               DC.W    WRITE_HEX_PARAM-LCD_FUN_TBL
               DC.W    WRITE_HEX_VALUE-LCD_FUN_TBL
               DC.W    WRITE_ENCODED_SCREEN-LCD_FUN_TBL
               DC.W    DISP_ENCODED_SCREEN-LCD_FUN_TBL
;
;
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; INITIALIZE THE LCD -
; USED ONLY AT POWER-UP.  NO INPUTS, NO REGISTERS AFFECTED (AS IF YOU CARED ANYWAY).
;
INIT_LCD
               ABS_LONG
               BSR.S   LCDWAIT
               MOVE.B  #038H,LCD_CONTROL    ;SET 8 BIT/2 LINES/5 X 7 DOTS.
               BSR.S   LCDWAIT
               MOVE.B  #0CH,LCD_CONTROL     ;TURN ON DISPLAY.
               BSR.S   LCDWAIT
               MOVE.B  #006H,LCD_CONTROL    ;CURSOR MODE = INCREMENT.
               RTS
               ABS_SHORT
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;
;
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; WAIT UNTIL LCD IS READY TO ACCEPT NEW DATA OR CONTROL BYTE -
; NO INPUTS, NO REGISTER CLOBBERAGE.
;
LCDWAIT
               ABS_LONG
               BTST.B  #7,LCD_CONTROL       ;TEST BUSY BIT -
               ABS_SHORT
               NOP
               NOP
               BNE     LCDWAIT              ;IF SET, KEEP WAITING.
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;
;
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; TRANSFER FULL SCREEN TEXT TO SCREEN_BUFFER -
; A1 POINTS TO SCREEN TEXT (MUST BE WORD-ALIGNED).
; PRESERVES ALL REGISTERS.
;
WRITE_SCREEN
               MOVEM.L A1-A2/D0,-(A7)
               MOVEQ   #7,D0                ;TRANSFER VIA EIGHT LONG-WORD MOVES.
               MOVE    #SCREEN_BUFFER,A2
WR_SCRN_10
               MOVE.L  (A1)+,(A2)+
               DBRA    D0,WR_SCRN_10
;
               MOVEM.L (A7)+,A1-A2/D0
WR_SCRN_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; WRITE PARAM_BUFFER VALUE DISPLAY INTO ITS SCREEN_BUFFER FIELD -
; A1 POINTS TO FIELD POSITION/LENGTH SPEC (AT BEGINNING OF FIELD BLOCK).
; VALUE IS WRITTEN SUBJECT TO CONTROLS IN EFFECT FOR CURRENT PARAMETER FIELD:
;    *   -   IF STRING_AT_MAX OR STRING_AT_MIN, WRITES STRING INSTEAD OF VALUE AT INDICATED LIMIT.
;    *   -   OFFSET/SCALE PROCESSING IS DONE USING DISPLAY_OFFSET, DISPLAY_SCALE VALUES.
;    *   -   SIGN_ENABLE INVOKES SIGN CHARACTER DISPLAY.
;    *   -   PARAM_SIZE INDICATES SIZE OF VALUE IN PARAM_BUFFER (BYTE/WORD OR LONG).
;    *   -   DECIMAL_POINT > 0 CAUSES DECIMAL POINT TO BE INSERTED AT INDICATED POSITION.
;    *   -   ZERO_BLANKING CAUSES LEADING-ZERO BLANKING IN DISPLAYED VALUE.
; PRESERVES ALL REGISTERS.
;
; SPECIAL CASE:
; IF WE ARE CALLED IN THE MIDDLE OF DECIMAL-KEYPAD INITIATION PROCEDURE,
; THEN WE DON'T DISPLAY ANYTHING IF WE ARE AIMED AT THE CURRENT EDIT
; FIELD - THIS IS MAINLY DONE TO PREVENT MIN/MAX_STRNG DISPLAYS FROM
; CLUTTERING UP THE SCREEN VIA THE EDIT FIELD.
;
WRITE_PARAM_VALUE
               MOVEM.L D0-D2,-(A7)
;
               TST.B   ROUSING_GUIDO        ;ARE WE INITIATING DECIMAL KEYPAD ENTRY IN EDIT FIELD?
               BEQ.S   WR_PVAL_08           ;BRANCH IF NOT, GAW HEAD 'N' DISPLAY.
               MOVE    CUR_FLD_INDEX,D0     ;YES - BUT ARE WE WORKING ON THE EDIT FIELD RIGHT NOW?
               CMP     TEMP_FLD_INDEX,D0
               BEQ     WR_PVAL_B0           ;BRANCH IF YES, SKIP DISPLAY (GUIDO'LL GIT IT).
WR_PVAL_08
               CLR.L   D0                   ;CLEAR OUT PARAMETER VALUE REGISTER.
               MOVE    DECIMAL_POINT,D2     ;SET DECIMAL POINT CONTROL BITS,
               AND     #7,D2                ;DEFAULT ALL OTHER CONTROL BITS TO OFF (STOP-GAP).
               BTST    #1,PARAM_SIZE        ;IS THIS A LONG-WORD PARAMETER?
               BNE.S   WR_PVAL_10           ;BRANCH IF YES,
               MOVE    PARAM_BUFFER,D0      ;ELSE FETCH WORD VALUE FROM BUFFER -
               TST.B   SIGN_ENABLE          ;IS THIS A SIGNED PARAMETER?
               BEQ.S   WR_PVAL_50           ;BRANCH IF NOT,
               BSET    #4,D2                ;ELSE SET SIGNED-PARAMETER CONTROL BIT.
               BRA.S   WR_PVAL_50
WR_PVAL_10
               MOVE.L  PARAM_BUFFER,D0      ;FETCH LONG-WORD VALUE,
               BSET    #3,D2                ;SET LONG-WORD CONTROL BIT - ASSUMED UNSIGNED.
                                            ;STRING-SUBSTITUTE-AT-LIMITS TEST - LONG-WORD VALUE:
               TST.B   STRING_AT_MIN        ;SUBSTITUTE STRING AT MINIMUM PARAMETER VALUE?
               BEQ.S   WR_PVAL_30           ;BRANCH IF NOT,
               CMP.L   PARAM_LO_LIM,D0      ;ELSE SEE IF PARAM IS AT LOWER LIMIT.
               BEQ.S   WR_PVAL_A0           ;BRANCH IF IT IS, WRITE SUBSTITUTE STRING.
WR_PVAL_30
               TST.B   STRING_AT_MAX        ;SUBSTITUTE STRING AT MAXIMUM PARAMETER VALUE?
               BEQ.S   WR_PVAL_40           ;BRANCH IF NOT,
               CMP.L   PARAM_HI_LIM,D0      ;ELSE SEE IF PARAM IS AT UPPER LIMIT.
               BEQ.S   WR_PVAL_A0           ;BRANCH IF IT IS, WRITE SUBSTITUTE STRING.
WR_PVAL_40
               SUB.L   DISPLAY_OFFSET,D0    ;SUBTRACT DISPLAY OFFSET (IF ANY) - NO LONG SCALING.
               BRA.S   WR_PVAL_80           ;HEAD FOR LEADING-ZERO BLANKING CHECK.
WR_PVAL_50
                                            ;STRING-SUBSTITUTE-AT-LIMITS TEST - BYTE/WORD VALUE:
               TST.B   STRING_AT_MIN        ;SUBSTITUTE STRING AT MINIMUM PARAMETER VALUE?
               BEQ.S   WR_PVAL_60           ;BRANCH IF NOT,
               CMP     PARAM_LO_LIM,D0      ;ELSE SEE IF PARAM IS AT LOWER LIMIT.
               BEQ.S   WR_PVAL_A0           ;BRANCH IF IT IS, WRITE SUBSTITUTE STRING.
WR_PVAL_60
               TST.B   STRING_AT_MAX        ;SUBSTITUTE STRING AT MAXIMUM PARAMETER VALUE?
               BEQ.S   WR_PVAL_70           ;BRANCH IF NOT,
               CMP     PARAM_HI_LIM,D0      ;ELSE SEE IF PARAM IS AT UPPER LIMIT.
               BEQ.S   WR_PVAL_A0           ;BRANCH IF IT IS, WRITE SUBSTITUTE STRING.
WR_PVAL_70
                                            ;WORD-VALUE DISPLAY OFFSET/SCALING:
               SUB     DISPLAY_OFFSET,D0    ;SUBTRACT OFFSET (IF ANY) FOR DISPLAY.
               MULU    DISPLAY_SCALE,D0     ;DO SCALING (IF ANY) FOR DISPLAY.
;
WR_PVAL_80
               TST.B   ZERO_BLANKING        ;LEADING-ZERO BLANKING ENABLED?
               BEQ.S   WR_PVAL_90           ;BRANCH IF NOT,
               BSET    #5,D2                ;ELSE SET ZERO-BLANKING CONTROL BIT.
WR_PVAL_90
               MOVE    (A1),D1              ;FETCH FIELD POSITION/LENGTH SPEC.
               BSR.S   WRITE_VALUE          ;SETUP COMPLETE - GO TO IT.
               BRA.S   WR_PVAL_B0
;
WR_PVAL_A0
                                            ;SUBSTITUTE STRING FOR PARAMETER VALUE AT LIMIT:
               MOVE.L  A2,-(A7)
               MOVE.L  DISP_STRNG_PTR,A2    ;FETCH POINTER TO POS/LENGTH/STRING TEXT,
               MOVE    (A2)+,D1             ;COPY POSITION/LENGTH SPEC INTO D1, POINT TO STRING.
               BSR.S   WRITE_STRING         ;WRITE THE STRING PER SPEC.
               ST      UPDATE_LCD           ;BECAUSE STRING MAY EXCEED NORMAL FIELD FOR THIS PARAM,
                                            ;REQUEST UPDATE OF ENTIRE LCD WHEN THIS IS DONE.
               ST      POSITION_CURS        ;AFTER FULL-SCREEN UPDATE, POSITION CURSOR NORMALLY.
               MOVE.L  (A7)+,A2
;
WR_PVAL_B0
               MOVEM.L (A7)+,D0-D2
WR_PVAL_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; WRITE A DECIMAL VALUE INTO A SCREEN_BUFFER FIELD -
; D0 CONTAINS VALUE (WORD OR LONG - LONG VALUES ARE ASSUMED UNSIGNED).
; D1 CONTAINS FIELD POSITION/LENGTH SPEC (IN M.S.BYTE/L.S.BYTE RESPECTIVELY).
; VALUE IS WRITTEN RIGHT-JUSTIFIED INTO FIELD, SUBJECT TO CONTROLS IN D2:
;              BIT 5 -    SET FOR LEADING-ZERO BLANKING.
;              BIT 4 -    SET FOR SIGNED VALUE (OHERWISE ASSUMED UNSIGNED).
;              BIT 3 -    SET FOR LONG-WORD VALUE (OTHERWISE ASSUMED WORD).
;              BIT 2-0 -  DECIMAL-POINT POSITION (0 = NO DECIMAL POINT).
; ALL REGISTERS PRESERVED.
;
WRITE_VALUE
               MOVE.L  D3,-(A7)
               BTST    #4,D2                ;SIGNED PARAMETER?
               BEQ.S   WR_VAL_10            ;BRANCH IF NOT,
               BSR     SET_SIGN_CHAR        ;ELSE SET UP SIGN CHARACTER (AND NEGATE NEGATIVE ARG).
WR_VAL_10
                                            ;CONVERT VALUE TO ASCII BCD STRING IN BCD_DIGITS -
               BTST    #3,D2                ;WORD OR LONG PARAMETER?
               BEQ.S   WR_VAL_20            ;BRANCH IF WORD,
               BSR     LONG_BIN_TO_BCD      ;USE LONG-WORD CONVERSION ONLY WHEN NEEDED.
               BRA.S   WR_VAL_30
WR_VAL_20
               BSR     WORD_BIN_TO_BCD
WR_VAL_30
               MOVE    D2,D3                ;COPY DECIMAL-POINT POSITION SPEC -
               AND     #7,D3
               BEQ.S   WR_VAL_40            ;NO ACTION IF POSITION = 0 -
               BSR     INSERT_DECIMAL_PT    ;ELSE INSERT "." INTO BCD_DIGITS WHERE INDICATED.
WR_VAL_40
               BTST    #5,D2                ;IS LEADING-ZERO BLANKING REQUESTED?
               BEQ.S   WR_VAL_50            ;BRANCH IF NOT,
               BSR     BLANK_ZEROES         ;ELSE BLANK LEADING ZEROES IN BCD_DIGITS STRING.
WR_VAL_50
               BSR     WRITE_BCD_DIGITS     ;COPY PROCESSED BCD STRING INTO SCREEN_BUFFER FIELD.
               BTST    #4,D2                ;SIGNED PARAMETER?
               BEQ.S   WR_VAL_60            ;BRANCH IF NOT,
               BSR     WRITE_SIGN_CHAR      ;ELSE WRITE SIGN CHARACTER INTO SCREEN_BUFFER FIELD.
WR_VAL_60
               MOVE.L  (A7)+,D3
WR_VAL_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; WRITE AN INDEXED CHARACTER STRING TO SCREEN_BUFFER -
; DISP_STRNG_PTR POINTS TO INDEXED STRING BLOCK.
; PARAM_BUFFER CONTAINS INDEX (ASSUMED ZERO-RELATIVE, NON-NEG, WORD).
; A1 POINTS TO FIELD POSITION/LENGTH SPEC (AT TOP OF FIELD BLOCK) -
; STRING LENGTH IS ASSUMED TO BE COMPATIBLE WITH FIELD LENGTH.
; ALL REGISTERS PRESERVED (OF COURSE).
;
WRITE_PARAM_STRING
               MOVEM.L D1/A2,-(A7)
               MOVE.L  DISP_STRNG_PTR,A2    ;FETCH POINTER TO INDEXED STRING BLOCK.
               CLR     D1                   ;FETCH FIELD LENGTH INTO D1.
               MOVE.B  1(A1),D1
               MULU    PARAM_BUFFER,D1      ;MULTIPLY BY INDEX (PARAMETER SETTING).
               ADD     D1,A2                ;BUMP A2 UP TO INDICATED STRING.
WR_PSTG_20
               MOVE    (A1),D1              ;FETCH FIELD POSITION/LENGTH SPEC INTO D1.
               BSR.S   WRITE_STRING         ;PARAMETERS SET - DO THE STRING WRITE.
               MOVEM.L (A7)+,D1/A2
WR_PSTG_EXIT
               RTS
;
;
; WRITE A STRING NON-INDEXED INTO A SCREEN_BUFFER FIELD -
; A0 POINTS DIRECTLY AT THE STRING TO BE WRITTEN.
; OTHERWISE, SAME AS WRITE_PARAM_STRING.
;
WRITE_A0_STRING
               MOVEM.L D1/A2,-(A7)          ;JUST GET THESE ONTO THE STACK FOR BALANCE -
               MOVE.L  A0,A2                ;COPY STRING POINTER INTO THE STANDARD PLACE,
               BRA     WR_PSTG_20           ;PICK UP POSITION/LENGTH FROM FIELD BLOCK VIA A1.
;
;
;
; WRITE A STRING INTO SCREEN_BUFFER -
; A2 POINTS TO STRING, D1 CONTAINS FIELD POSITION/LENGTH SPEC.
; PRESERVES ALL REGISTERS.
;
WRITE_STRING
               MOVEM.L D0-D1/A2-A3,-(A7)
               MOVE    #SCREEN_BUFFER,A3    ;SET A3 AS POINTER TO FIELD IN SCREEN_BUFFER.
               MOVE    D1,D0                ;COPY FIELD POSITION/LENGTH SPEC.
               AND     #0FFH,D0             ;CREATE SEPARATE LENGTH,
               LSR     #8,D1                ;CREATE SEPARATE POSITION.
               ADD     D1,A3                ;POINT A3 AT BEGINNING OF SCREEN_BUFFER FIELD.
               SUBQ    #1,D0                ;DECREMENT LENGTH FOR USE AS TRANSFER LOOP COUNTER.
WR_STG_10
               MOVE.B  (A2)+,(A3)+
               DBRA    D0,WR_STG_10
;
               MOVEM.L (A7)+,D0-D1/A2-A3
WR_STG_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; DISPLAY A NEW SCREEN -
; A1 POINTS TO FULL-SCREEN TEXT (MUST BE WORD-ALIGNED).
; SCREEN TEXT IS COPIED INTO SCREEN_BUFFER FIRST.
; ALL REGISTERS PRESERVED.
;
DISP_SCREEN
               BSR     WRITE_SCREEN         ;TRANSFER TEXT INTO SCREEN_BUFFER,
;
               BRA     DISP_BUFFER          ;TRANSFER SCREEN_BUFFER TO LCD AND RETURN THROUGH.
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;
;
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; DISPLAY A STRING IN LCD -
; A2 POINTS TO STRING, D1 CONTAINS FIELD POSITION/LENGTH SPEC.
; STRING IS COPIED INTO CORRESPONDING SCREEN_BUFFER FIELD FIRST.
; STRING MUST BE CONFINED TO ONE LINE OF LCD.
; PRESERVES ALL REGISTERS.
;
DISP_STRING
               BSR     WRITE_STRING         ;COPY THE STRING INTO A FIELD IN SCREEN_BUFFER.
;
               BRA.S   DISP_FIELD           ;TRANSFER BUFFER FIELD TO LCD, RETURN THROUGH.
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;
;
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; WRITE ENTIRE SCREEN_BUFFER TO LCD -
; NO INPUTS, ALL REGISTERS PRESERVED.
;
DISP_BUFFER
               MOVE.L  D1,-(A7)
               MOVEQ   #16,D1               ;TRANSFER TOP LINE OF BUFFER AS A SINGLE FIELD -
               BSR.S   DISP_FIELD           ;POSITION = 0, LENGTH = 16.
               MOVE    #1010H,D1            ;TRANSFER BOTTOM LINE OF BUFFER AS A SINGLE FIELD -
               BSR.S   DISP_FIELD           ;POSITION = 16, LENGTH = 16.
               MOVE.L  (A7)+,D1
DISP_BUF_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; TRANSFER A PARAMETER FIELD FROM SCREEN_BUFFER TO LCD -
; POSITION CURSOR AT RIGHT END OF FIELD.
; A1 POINTS TO FIELD POSITION/LENGTH SPEC (AT BEGINNING OF FIELD BLOCK) -
; FIELD MUST BE CONFINED TO ONE LINE OF LCD.
; ALL REGISTERS PRESERVED.
;
DISP_PARAM_FIELD
               MOVE    D1,-(A7)
               MOVE    (A1),D1              ;FETCH FIELD POSITION/LENGTH SPEC.
               BSR.S   DISP_FIELD           ;TRANSFER THE FIELD TO LCD.
               AND     #0FFH,D1             ;SET UP TO POSITION CURSOR - THIS BE FIELD LENGTH -
               ADD.B   (A1),D1              ;ADD FIELD POSITION,
               SUBQ    #1,D1                ;BACK UP BY ONE TO HIT RIGHTMOST FIELD POSITION,
               ASL     #8,D1                ;USE FIELD LENGTH OF ZERO FOR CURSOR-POSITIONING ONLY.
               BSR.S   DISP_FIELD
               MOVE    (A7)+,D1
DISP_PFLD_EXIT
               RTS
;
;
;
; DO A ONE-FOR-ONE TRANSFER OF A FIELD FROM SCREEN_BUFFER TO LCD -
; D1 CONTAINS FIELD POSITION/LENGTH (IN M.S.BYTE/L.S.BYTE RESPECTIVELY).
; FIELD MUST BE CONFINED TO ONE LINE OF LCD.
; IF CALLED WITH FIELD LENGTH = 0, EXITS AFTER POSITIONING CURSOR.
; PRESERVES ALL REGISTERS.
;
DISP_FIELD
               MOVEM.L D0-D1/A2,-(A7)
               SF      CURSOR_STAT          ;KILL CURSOR WHILE WRITING TO LCD IN ORDER TO
               BSR     UPDATE_CURSOR        ;PREVENT UNSIGHTLY BLACK SMUDGE IN BLANK AREAS.
               MOVE    #SCREEN_BUFFER,A2    ;SET POINTER TO BEGINING OF FIELD IN SCREEN_BUFFER.
               MOVE    D1,D0                ;COPY FIELD POSITION/LENGTH SPEC.
               AND     #0FFH,D0             ;CREATE SEPARATE LENGTH,
               LSR     #8,D1                ;CREATE SEPARATE POSITION.
               ADD     D1,A2                ;POINT A2 AT BEGINNING OF SCREEN_BUFFER FIELD.
               ADD     #80H,D1              ;SET LCD CURSOR POSITION -
               CMP     #90H,D1              ;FIRST ROW POSITION?
               BLT.S   DISP_FLD_10          ;BRANCH IF YES,
               ADD     #30H,D1              ;ELSE CORRECT CURSOR ADDRESS.
DISP_FLD_10
               ABS_LONG
               BSR     LCDWAIT              ;WAIT FOR LCD NOT BUSY.
               MOVE.B  D1,LCD_CONTROL       ;SET CURSOR POSITION.
;
               SUBQ    #1,D0                ;DECREMENT FIELD LENGTH FOR USE AS TRANSFER COUNTER -
               BMI.S   DISP_FLD_30          ;IF FIELD LENGTH WAS 0, EXIT AFTER POSITIONING CURSOR.
DISP_FLD_20
               BSR     LCDWAIT              ;WAIT FOR LCD NOT BUSY.
               MOVE.B  (A2)+,LCD_DATA       ;TRANSFER A BYTE FROM FIELD TO LCD.
               DBRA    D0,DISP_FLD_20       ;REPEAT UNTIL ENTIRE FIELD TRANSFERRED.
               ABS_SHORT
DISP_FLD_30
               MOVEM.L (A7)+,D0-D1/A2
DISP_FLD_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; WRITE A HEX BYTE VALUE TO TWO-CHARACTER FIELD OF LCD -
; MAINLY FOR TEST CODE USE, UNLESS WE DECIDE TO DISPLAY HEX DATA FOR SOME REASON.
; INPUTS:  D0 CONTAINS HEX VALUE, D1 CONTAINS CURSOR POSITION.
; TRASHES: D0,D1
;
DISP_HEX
               ADD     #80H,D1              ;SET CURSOR POSITION -
               CMP     #90H,D1              ;FIRST ROW POSITION?
               BLT.S   DISP_HEX_08          ;BRANCH IF YES,
               ADD     #30H,D1              ;ELSE CORRECT CURSOR ADDRESS.
DISP_HEX_08
               BSR     LCDWAIT              ;WAIT FOR LCD NOT BUSY.
               ABS_LONG
               MOVE.B  D1,LCD_CONTROL       ;SET CURSOR POSITION.
               ABS_SHORT
;
               AND     #0FFH,D0             ;CLEAR HIGH-ORDER BITS.
               MOVE    D0,D1                ;COPY HEX VALUE.
               AND     #0FH,D0              ;KEEP LOW-ORER DIGIT IN D0,
               LSR     #4,D1                ;HIGH-ORDER DIGIT IN D1.
               ADD     #30H,D1              ;CONVERT AND DISPLAY HIGH-ORDER DIGIT.
               CMP.B   #39H,D1
               BLE.S   DISP_HEX_20          ;BRANCH IF 0-9,
               ADD     #7,D1                ;ELSE BUMP UP TO A-F.
DISP_HEX_20
               BSR     LCDWAIT              ;WAIT FOR LCD NOT BUSY.
               ABS_LONG
               MOVE.B  D1,LCD_DATA          ;DISPLAY HI DIGIT.
               ABS_SHORT
;
               ADD     #30H,D0              ;CONVERT AND DISPLAY LOW-ORDER DIGIT.
               CMP.B   #39H,D0
               BLE.S   DISP_HEX_30          ;BRANCH IF 0-9,
               ADD     #7,D0                ;ELSE BUMP UP TO A-F.
DISP_HEX_30
               BSR     LCDWAIT              ;WAIT FOR LCD NOT BUSY.
               ABS_LONG
               MOVE.B  D0,LCD_DATA          ;DISPLAY LO DIGIT.
               ABS_SHORT
;
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; LONG-WORD BINARY-TO-BCD CONVERSION -
; D0 CONTAINS UNSIGNED LONG ARGUMENT IN THE RANGE 0-99,999,999.
; RETURNS ASCII STRING IN BCD_DIGITS ARRAY.
; ALL REGISTERS PRESERVED.
;
LONG_BIN_TO_BCD
               MOVEM.L A0/D0-D1,-(A7)
               MOVE    #BCD_DIGITS+8,A0     ;POINT PAST BCD_DIGITS ARRAY,
               CLR.L   -(A0)                ;THEN CLEAR ARRAY WHILE MOVING POINTER TO M.S.DIGIT.
               CLR.L   -(A0)
;
               MOVE.L  #10000000,D1         ;GENERATE TEN-MILLIONS DIGIT.
               BSR.S   LBINBCD_20
               MOVE.L  #1000000,D1          ;GENERATE MILLIONS DIGIT.
               BSR.S   LBINBCD_20
               MOVE.L  #100000,D1           ;GENERATE HUNDRED-THOUSANDS DIGIT.
               BSR.S   LBINBCD_20
               MOVE.L  #10000,D1            ;GENERATE TEN-THOUSANDS DIGIT.
               BSR.S   LBINBCD_20
;
               LEA     4(A0),A0             ;POINT PAST LOWEST-ORDER DIGIT -
               BRA.S   WBINBCD_20           ;CONTINUE, USING WORD CONVERSION ROUTINE.
;
;
LBINBCD_20
               CMP.L   D1,D0                ;COMPARE ARGUMENT AGAINST UNIT VALUE IN CURRENT DIGIT.
               BCS.S   LBINBCD_30           ;BRANCH IF LESS, MOVE ON TO NEXT DIGIT.
               SUB.L   D1,D0                ;ELSE SUBTRACT UNIT VALUE FROM ARGUMENT,
               ADDQ.B  #1,(A0)              ;INCREMENT CURRENT BCD_DIGIT VALUE,
               BRA     LBINBCD_20           ;GO BACK AND DO IT AGAIN(?)
LBINBCD_30
               LEA     1(A0),A0             ;SET POINTER TO NEXT LOWER-ORDER BCD_DIGIT.
               RTS
;
;
;
; WORD-LENGTH BINARY-TO-BCD CONVERSION -
; D0 CONTAINS UNSIGNED WORD ARGUMENT IN THE RANGE 0-32,767.
; RETURNS ASCII STRING IN BCD_DIGITS ARRAY.
; LONG-WORD CONVERSION UTILIZES THIS ROUTINE FOR THE UNDER-10,000 REMAINDER.
; ALL REGISTERS PRESERVED.
;
WORD_BIN_TO_BCD
               MOVEM.L A0/D0-D1,-(A7)       ;D1 SAVED FOR COMPATIBILITY WITH LONG_BIN_TO_BCD.
;
               MOVE    #BCD_DIGITS,A0       ;CLEAR ALL DIGITS, POINT PAST LOWEST DIGIT.
               CLR.L   (A0)+
               CLR.L   (A0)+
;
WBINBCD_20
                                            ;WATCH OUT! - LONG-WORD CONVERSION ROUTINE
                                            ;BRANCHES IN AT THIS POINT!
;
               EXT.L   D0                   ;LONG-WORD USED IN DIVIDE.
               DIVU    #10,D0
               SWAP    D0                   ;GET REMAINDER FROM HI-ORDER HALF OF D0 -
               ADD.B   D0,-(A0)             ;ADD INSTEAD OF STORE - MAY BE COMBINING WITH
                                            ;PARTIAL RESULT OF LONG-WORD CONVERSION.
               SWAP    D0                   ;RETRIEVE QUOTIENT -
               TST     D0                   ;IF = 0, WE'RE DONE.
               BNE     WBINBCD_20           ;ELSE KEEP GOING.
;
               MOVE    #BCD_DIGITS,A0       ;NOW CONVERT BCD DIGITS TO ASCII CHARACTERS -
               MOVEQ   #7,D0                ;DO EIGHT DIGITS.
WBINBCD_40
               ADD.B   #'0',(A0)+           ;CONVERT BCD DIGIT TO ASCII.
               DBRA    D0,WBINBCD_40
;
               MOVEM.L (A7)+,A0/D0-D1
WBINBCD_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; INSERT DECIMAL POINT CHARACTER INTO BCD_DIGITS STRING -
; D3 INDICATES NUMBER OF DIGITS TO THE RIGHT OF THE "." (NO "." IF = 0).
; NUMBER OF DECIMAL PLACES IS AUTOMATICALLY LIMITED TO 6 - SO DON'T WORRY.
; M.S.DIGIT IN STRING IS VAPORIZED - HOPEFULLY IT WAS A ZERO ANYWAY.
; ALL REGISTERS PRESERVED.
;
INSERT_DECIMAL_PT
               TST     D3                   ;LOOK FOR 0 (= NO ACTION).
               BEQ.S   INS_DEC_EXIT         ;SKOOT, OFF THE HOOK.
;
               MOVEM.L A0/D3,-(A7)          ;ACTION, SO SAVE REGIFERS.
               EXT.L   D3                   ;EXTEND DEC-PT POSITION TO LONG WORD.
               CMP     #7,D3                ;NO MORE THAN 6 DIGITS ALLOWED RIGHT OF "."
               BCS.S   INS_DEC_10
               MOVEQ   #6,D3
INS_DEC_10
               MOVE    #BCD_DIGITS,A0       ;POINT TO M.S.DIGIT WITH THIS GUY,
               NEG.L   D3                   ;POINT TO DECIMAL POINT POSITION WITH THIS GUY.
               ADD.L   A0,D3
               ADDQ.L  #7,D3
INS_DEC_20
               MOVE.B  1(A0),(A0)+          ;SHIFT HIGHER-ORDER DIGITS TO THE "LEFT",
               CMP.L   A0,D3                ;UNTIL WE GET TO THE DECIMAL POINT POSITION -
               BNE     INS_DEC_20
               MOVE.B  #'.',(A0)            ;THEN, JAM THAT D-P IN.
;
               MOVEM.L (A7)+,A0/D3
INS_DEC_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; BLANK LEADING ZEROES IN BCD_DIGITS STRING -
; WILL LEAVE LEADING ZEROE TO THE IMMEDIATE LEFT OF DECIMAL POINT, IF ANY.
; ALL REGISTERS PRESERVED.
;
BLANK_ZEROES
               MOVEM.L A0/D0,-(A7)
               MOVE    #BCD_DIGITS,A0       ;POINT TO M.S. DIGIT IN BCD_DIGITS STRING.
               MOVEQ   #6,D0                ;DO SEVEN DIGITS MAXIMUM -
                                            ;DON'T COMPLETELY WIPE OUT A ZERO VALUE.
BLNKZER_10
               CMP.B   #'0',(A0)            ;WE GOT A ZEROE HERE?
               BNE.S   BLNKZER_20           ;BRANCH IF NOT, NO MORE LEADING ZEROES.
               CMP.B   #'.',1(A0)           ;YES - BUT IS NEXT CHAR A DECIMAL POINT?
               BEQ.S   BLNKZER_20           ;BRANCH IF YES, WE ARE LIKEWISE FINI.
               MOVE.B  #' ',(A0)+           ;ELSE REPLACE IT WITH A BLANK,
               DBRA    D0,BLNKZER_10        ;REPEAT FOR UP TO SEVEN CHARS.
BLNKZER_20
               MOVEM.L (A7)+,A0/D0
BLNKZER_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; WRITE BCD_DIGITS STRING INTO SCREEN_BUFFER FIELD -
; D1 CONTAINS FIELD POSITION/LENGTH SPEC (IN M.S.BYTE/L.S.BYTE RESPECTIVELY).
; STRING IS RIGHT JUSTIFIED, WRITTEN TO FILL ENTIRE FIELD -
; ANY EXCESS HIGH-ORDER DIGITS ARE RUDELY AMPUTATED.
; ALL REGISTERS PRESERVED.
;
WRITE_BCD_DIGITS
               MOVEM.L A0-A1/D0-D1,-(A7)
               MOVE    D1,D0                ;COPY FIELD POSITION/LENGTH SPEC.
               AND     #0FFH,D0             ;CREATE SEPARATE LENGTH,
               LSR     #8,D1                ;CREATE SEPARATE POSITION -
               ADD     D0,D1                ;ADD LENGTH TO POSITION,
               MOVE    #SCREEN_BUFFER,A0    ;SET A0 TO POINT PAST END OF SCREEN_BUFFER FIELD.
               ADD     D1,A0
               SUBQ    #1,D0                ;DECREMENT FIELD LENGTH FOR USE AS TRANSFER COUNTER.
               MOVE    #BCD_DIGITS+8,A1     ;A1 POINTS PAST LOWEST DIGIT OF BCD_DIGITS STRING.
WR_BCD_10
               MOVE.B  -(A1),-(A0)          ;COPY STRING BACKWARDS INTO FIELD,
               DBRA    D0,WR_BCD_10         ;UNTIL ENTIRE FIELD IS WRITTEN.
;
               MOVEM.L (A7)+,A0-A1/D0-D1
WR_BCD_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; SIGN CHARACTER ROUTINES - CALLED ONLY IF A SIGNED VALUE IS BEING WRITTEN.
; SIGNED VALUE IMPLIES BYTE/WORD VALUE - LONG-WORD PARAMETERS ARE ASSUMED UNSIGNED.
;
; SET UP SIGN CHARACTER - D0 CONTAINS WORD VALUE.
; CALL PRIOR TO CALLING WRITE_VALUE (OR OTHERS OF ITS ILK).
; SETS SIGN_CHAR TO "+", "-" OR " " PER VALUE IN D0.
; D0 VALUE IS NEGATED IF IT IS NEGATIVE - OTHERWISE, PRESERVES ALL REGISTERS..
;
SET_SIGN_CHAR
               TST     D0
               BEQ.S   SET_SGN_10
               BPL.S   SET_SGN_20
               NEG     D0
               MOVE.B  #'-',SIGN_CHAR
               BRA.S   SET_SGN_EXIT
SET_SGN_10
               MOVE.B  #' ',SIGN_CHAR
               BRA.S   SET_SGN_EXIT
SET_SGN_20
               MOVE.B  #'+',SIGN_CHAR
SET_SGN_EXIT
               RTS
;
;
;
; WRITE SIGN CHARACTER INTO SCREEN_BUFFER FIELD -
; D1 CONTAINS FIELD POSITION/LENGTH SPEC (IN M.S.BYTE/L.S.BYTE RESPECTIVELY).
; CALL AFTER BCD'D, DECIMAL-POINTED, ZERO-BLANKED STRING IS ALREADY IN SCREEN_BUFFER -
; I.E., CALL AFTER CALLING WRITE_BCD_DIGITS.
; COPIES SIGN_CHAR INTO RIGHTMOST BLANK DIGIT POSITION (IF ANY) -
; OTHERWISE COPIES IT INTO LEFTMOST DIGIT POSITION, IN WHICH CASE
; M.S.DIGIT IN STRING IS VAPORIZED - HOPEFULLY IT WAS A ZERO ANYWAY.
; PRESERVES ALL REGISTERS.
;
WRITE_SIGN_CHAR
               MOVEM.L D0-D1/A0,-(A7)
               MOVE    D1,D0                ;SEPARATE FIELD LENGTH OUT FOR LIMIT CONDITION.
               AND     #0FH,D0              ;NO FIELD GREATER THAN 15 CHARS, I MUST SAY.
               SUBQ    #1,D0                ;THIS BE THE LIMIT FOR LOOP BELOW.
               MOVE    #SCREEN_BUFFER+1,A0  ;POINT A0 AT LEFTMOST CHARACTER PLUS ONE.
               LSR     #8,D1
               ADD     D1,A0
WR_SGNCHR_10
               CMP.B   #' ',(A0)+           ;IS THERE A BLANK HERE?
               BNE.S   WR_SGNCHR_20         ;BRANCH IF NOT, GO WRITE SIGN CHARACTER.
               DBRA    D0,WR_SGNCHR_10      ;LOOP AGAIN IF WE HAVEN'T GONE OFF RIGHT END OF FIELD.
WR_SGNCHR_20
               MOVE.B  SIGN_CHAR,-2(A0)     ;PUT SIGN CHAR ONE POSITION TO LEFT OF FIRST NON-BLANK,
                                            ;OR AT RIGHT END OF FIELD (WHICHEVER COMES FIRST).
               MOVEM.L (A7)+,D0-D1/A0
WR_SGNCHR_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; UPDATE STATUS OF BLINKING CURSOR -
; FOLLOW VALUE OF CURSOR_STAT (OFF IF = 0, ON IF NOT = 0).
; USES NO REGISTERS.
;
UPDATE_CURSOR
               BSR     LCDWAIT              ;WAIT FOR LCD NOT BUSY.
               TST.B   CURSOR_STAT          ;GOT IT - WHAT'S IT SUPPOSED TO BE NOW?
               BNE.S   UPD_CUR_10           ;BRANCH TO TURN IT ON,
;
               ABS_LONG
               MOVE.B  #0CH,LCD_CONTROL     ;ELSE TURN IT OFF.
               BRA.S   UPD_CUR_EXIT
UPD_CUR_10
               MOVE.B  #0EH,LCD_CONTROL
               ABS_SHORT
;
UPD_CUR_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;
;
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; WRITE BIT PATTERN INTO CHARACTER RAM -
; A1 POINTS TO BIT PATTERN DATA FOR EIGHT GRAPHICS CHARACTER CELLS
; (64 BYTES, BIT PATTERNS ARE ROW PATTERNS IN BITS 4-0).
; PRESERVES ALL REGISTERS.
;
STORE_GRAPHICS
               MOVEM.L A1/D0,-(A7)
               BSR     LCDWAIT              ;WAIT FOR LCD NOT BUSY.
               ABS_LONG
               MOVE.B  #40H,LCD_CONTROL     ;SET CURSOR TO START OF CHARACTER RAM.
               ABS_SHORT
               MOVEQ   #63,D0               ;D7 = # OF BYTES TO WRITE.
STO_GRA_10
               BSR     LCDWAIT              ;WAIT FOR LCD NOT BUSY.
               ABS_LONG
               MOVE.B  (A1)+,LCD_DATA       ;WRITE NEXT BYTE,
               ABS_SHORT
               DBRA    D0,STO_GRA_10        ;LOOP UNTIL DONE.
;
               MOVEM.L (A7)+,A1/D0
STO_GRA_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; WRITE PARAM_BUFFER VALUE DISPLAY INTO ITS SCREEN_BUFFER FIELD -
; USE HEXADECIMAL FORMAT FOR NUMERICAL DISPLAY.
; A1 POINTS TO FIELD POSITION/LENGTH SPEC (AT BEGINNING OF FIELD BLOCK).
; VALUE IS WRITTEN SUBJECT TO CONTROLS IN EFFECT FOR CURRENT PARAMETER FIELD:
;    *   -   OFFSET PROCESSING IS DONE USING DISPLAY_OFFSET VALUE.
;    *   -   PARAM_SIZE INDICATES SIZE OF VALUE IN PARAM_BUFFER (BYTE/WORD OR LONG).
; PRESERVES ALL REGISTERS.
;
WRITE_HEX_PARAM
               MOVEM.L D0-D1,-(A7)
               CLR.L   D0                   ;CLEAR OUT PARAMETER VALUE REGISTER.
               BTST    #1,PARAM_SIZE        ;IS THIS A LONG-WORD PARAMETER?
               BNE.S   WR_HEXPRM_10         ;BRANCH IF YES,
               MOVE    PARAM_BUFFER,D0      ;ELSE FETCH WORD VALUE FROM BUFFER -
               SUB     DISPLAY_OFFSET,D0    ;SUBTRACT OFFSET (IF ANY) FOR DISPLAY.
               BRA.S   WR_HEXPRM_20
WR_HEXPRM_10
               MOVE.L  PARAM_BUFFER,D0      ;FETCH LONG-WORD VALUE.
               SUB.L   DISPLAY_OFFSET,D0    ;SUBTRACT DISPLAY OFFSET (IF ANY).
WR_HEXPRM_20
               MOVE    (A1),D1              ;FETCH FIELD POSITION/LENGTH SPEC.
               BSR.S   WRITE_HEX_VALUE      ;SETUP COMPLETE - GO TO IT.
;
               MOVEM.L (A7)+,D0-D1
WR_HEXPRM_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; WRITE A HEXADECIMAL VALUE INTO A SCREEN_BUFFER FIELD -
; D1 CONTAINS FIELD POSITION/LENGTH SPEC (IN M.S.BYTE/L.S.BYTE RESPECTIVELY).
; D0 CONTAINS VALUE, WHICH IS ASSUMED TO BE VALID UP TO THE NUMBER OF
; DIGITS WHICH WILL ACTUALLY BE DISPLAYED (MAX = EIGHT) AS DETERMINED BY
; FIELD LENGTH IN D1 - IN OTHER WORDS, KEEP YOUR SHIT TOGETHER.
; VALUE IS WRITTEN RIGHT-JUSTIFIED INTO FIELD, AS MUCH AS WILL FIT.
; ALL REGISTERS PRESERVED.
;
WRITE_HEX_VALUE
               MOVEM.L D0-D2/A0,-(A7)
               MOVE.L  #SCREEN_BUFFER,A0    ;SET UP WRITE POINTER.
               MOVE    D1,D2                ;COPY POS/LENGTH SPEC.
               AND     #0FH,D1              ;ISOLATE LENGTH IN D1.
               LSR     #8,D2                ;SHIFT POSITION INTO LOW BYTE,
               AND     #1FH,D2              ;MAKE SURE IT'S WITHIN REASONABLE BOUNDS.
               ADD     D1,A0                ;PUSH WRITE POINTER ONE CHARACTER PAST WRITE FIELD.
               ADD     D2,A0
;
WR_HEXVAL_10
                                            ;LOOP UNTIL WRITE FIELD IS FILLED:
               MOVE    D0,D2                ;COPY CURRENT DATA VALUE,
               LSR.L   #4,D0                ;SHIFT DOWN BY ONE DIGIT FOR NEXT TIME THROUGH.
               AND     #0FH,D2              ;ISOLATE CURRENT DIGIT.
               ADD     #'0',D2              ;CONVERT HEX DIGIT TO ASCII CHAR.
               CMP     #'9',D2
               BLE.S   WR_HEXVAL_20
               ADDQ    #7,D2
WR_HEXVAL_20
               MOVE.B  D2,-(A0)             ;WRITE CONVERTED DIGIT TO CURRENT WRITE POSITION.
               SUBQ    #1,D1                ;DECREMENT DIGITS-TO-WRITE COUNT,
               BNE     WR_HEXVAL_10         ;LOOP IF FIELD NOT YET FILLED.
;
               MOVEM.L (A7)+,D0-D2/A0
WR_HVL_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA


















;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
;
; copy encoded text to SCREEN_BUFFER, then decode it in place.
; text is encoded by exclusive-oring each character with 0a5h,
; decoding is done using the same process again.
; purpose of all of this is to make specific text strings invisible
; to human pokers while in binary format in rom.
;
; calls WRITE_SCREEN to copy text to buffer - a1.l points to text.
; all registers are preserved.
;
; Routine used to decode encoded screens used during power-up procedure.
; Screens are decoded in place after being copied to SCREEN_BUFFER.
; Destroys d0/a1.
;
;
WRITE_ENCODED_SCREEN
;
               movem.l d0/a1,-(a7)
;
               bsr     WRITE_SCREEN         ; copy encoded text to buffer,
               movea.w #SCREEN_BUFFER,a1    ; de-obscure it in place,
               moveq   #15,d0               ; 32 characters worth.
WRENSC_20
               eori.w  #0a5a5h,(a1)+        ; no big deal, really.
               dbra    d0,WRENSC_20
;
               movem.l (a7)+,d0/a1
               rts
;
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA


















;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; display encoded screen indicated by a1.l.
; all registers are preserved.
;
;
DISP_ENCODED_SCREEN
;
       bsr.s   WRITE_ENCODED_SCREEN
       bra     DISP_BUFFER
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

