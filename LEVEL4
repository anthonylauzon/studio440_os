***************************************************************************************************
***************************************************************************************************
***                                                                                             ***
***            UART B TRANSMISSION INT                                                          ***
***                                                                                             ***
***************************************************************************************************
***************************************************************************************************
;
;
               .AWORD
;
;
               INCLUDE EQUATES         ;HDW ADDR AND CONSTANT DEFS, .AWORD DIRECTIVE.
;
;
;
               .EXPORT LEVEL_4_INT
               .EXPORT WAIT_B_LIVE
               .EXPORT LOAD_B_LIVE
               .EXPORT LOAD_B_SEQ
               .EXPORT MIDI_OUT_OVERRUN
;890314               .EXPORT TRIP_B_SEQ_XMIT
;
;
;
                                            ; external ROM.
               .IMPORT  DISP_SCREEN
;
;
;
                                            ; RAM addresses.
               .IMPORT  BLEED_UART_B
               .IMPORT  MB_XMIT_SEQ_GATE
               .IMPORT  MB_XMIT_LIVE_CNT
               .IMPORT  MB_XMIT_LIVE_OUT
               .IMPORT  MB_XMIT_LIVE_BUFF
               .IMPORT  MB_XMIT_SEQ_CNT
               .IMPORT  MB_XMIT_SEQ_OUT
               .IMPORT  MB_XMIT_SEQ_BUFF
               .IMPORT  MB_RUN_STATUS
               .IMPORT  MB_XMIT_LIVE_IN
               .IMPORT  MB_XMIT_SEQ_IN
               .IMPORT  MB_XMIT_SEQ_TIME
               .IMPORT  CUR_SUB_BLOCK
               .IMPORT  SUBFUN_INSTALL


















;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; TRANSMIT MIDI DATA OUT THE 'B' UART.  THERE ARE TWO BUFFERS - 'LIVE'
; EVENTS AND SEQUENCED EVENTS.  GENERALLY, LIVE TAKES PRIORITY OVER SEQUENCED.
; THE PRIORITY SCHEME IS THIS:
;
; 1       COMPLETE ANY MESSAGE STARTED OUT OF THE SEQUENCE BUFFER
;         (CAN'T LET LIVE EVENTS MERGE INTO THE MIDDLE OF A MESSAGE)
; 2       LIVE EVENTS
; 3       SEQUENCE EVENTS
;
; IN MORE DETAIL, IT DOES THIS:
;
;              ALLOWED TO XMIT SEQ EVENTS?
;                  (_SEQ_GATE <> 0)
;                        |
;                       \|/
; XMIT LIVE EVENTS<--NO-***-YES--> WERE WE IN THE MIDDLE OF A MESSAGE?
;                                                    |
;                                                   \|/
;           ARE THERE ANY LIVE EVENTS TO XMIT?<--NO-***-YES-->XMIT NEXT SEQ BYTE
;                            |
;                           \|/
;           XMIT THEM<--YES-***-NO-->XMIT SEQUENCE EVENT
;
;      ADDITIONAL LOGIC INCLUDES RECREATING RUNNING STATUS ON OUTPUT, REDUCING THE
;      _SEQ_GATE COUNT IF AN 'F8' (TIMING BYTE) IS TRANSMITED, AND KILLING OFF
;      THE UART IF BOTH BUFFERS ARE EMPTY (_SEQ_GATE=0='EMPTY').
;
;      ALL REGISTERS PRESERVED.
;
LEVEL_4_INT
               MOVEM.L D0/A0,-(A7)          ;SAVE OFF REGISTERS WE'LL BE USING
;
               TST.B   BLEED_UART_B         ;IF SOMEONE HATH ORDERED TO DUMP SEQUENCE MEMORY
               BNE.S   L_4S_1               ;    THEN DO SO, REGARDLESS OF _GATE STAT.
               TST     MB_XMIT_SEQ_GATE     ;SEE IF SEQ BUFFER DUMP IN PROGRESS
               BNE.S   L_4S_1               ;    IF SO, GO HANDLE THOSE SITUATIONS
;
;
;
; MIDI UART "B" TRANSMIT INTERRUPT SERVICE, "LIVE" EVENTS:
;
L_4L_1
               CLR     MB_XMIT_SEQ_GATE     ;BULLETPROOF - IF ENTERED HERE, SEQ_CNT = 0 : SO SHOULD THIS
               TST     MB_XMIT_LIVE_CNT     ;IS THERE ANYTHING IN THE LIVE BUFFER?
               BEQ     L_4_SHUT_DOWN        ;IF NOT, SHUT DOWN THE UART AND EXIT.
L_4L_2
               MOVE    MB_XMIT_LIVE_OUT,A0 ;     LOAD UP INDEX INTO LIVE XMIT BUFFER
               MOVE.B  MB_XMIT_LIVE_BUFF(A0),D0  ;LOAD UP NEXT BYTE TO XMIT
               BPL.S   L_4L_3              ;IF A DATA BYTE, XMIT UNCONDITIONALLY
               CMP.B   MB_RUN_STATUS,D0    ;EQUAL TO LAST STATUS BYTE?
               BEQ.S   L_4L_4              ;     IF SO, DON'T XMIT-THIS IS HOW WE FORM RUNNING STATUS
               CMP.B   #0EFH,D0            ;ONLY A CHANNEL MESSAGE STATUS BYTE IS VALID
               BHI.S   L_4L_3              ;     RUNNING STATUS - XMIT SYSTEM STUFF UNCONDITIONALLY
               MOVE.B  D0,MB_RUN_STATUS    ;SAVE NEW STATUS BYTE FOR NEXT RUNNING STATUS CHECK
L_4L_3
               MOVE.B  D0,UART_B_DATA      ;XMIT A BYTE
L_4L_4
               ADDQ    #1,MB_XMIT_LIVE_OUT  INCREMENT...
               AND     #3FFH,MB_XMIT_LIVE_OUT    ;   ...AND WRAP INDEX (1K BUFFER)
               SUBQ    #1,MB_XMIT_LIVE_CNT ;DEC BUFFER COUNT (DOUBLES AS ACTIVITY FLAG TO BACKGROUND)
               BRA.S   L_4_EXIT            ;GET OUTA HERE!
;
;
;
; MIDI UART "B" TRANSMIT INTERRUPT SERVICE, SEQUENCER EVENTS:
;
L_4S_1
               TST     MB_XMIT_SEQ_CNT      ;ANYTHING IN THE SEQUENCE BUFFER?
               BEQ     L_4L_1              ;     IF EMPTY, TRY TO XMIT A LIVE BYTE
;
               MOVE    MB_XMIT_SEQ_OUT,A0  ;     LOAD UP INDEX INTO BUFFER
               MOVE.B  MB_XMIT_SEQ_BUFF(A0),D0   ;LOAD UP THE NEXT SEQ BYTE TO XMIT
;
               BPL.S   L_4S_3               ;IF DATA BYTE, MID-MESSAGE - XMIT UNCONDITIONALLY
               TST     MB_XMIT_LIVE_CNT     ;    ELSE - 'TWEN EVENTS.  LIVE MESSAGE WAITING?
               BNE.S   L_4L_2               ;         IF YES, GO TO...
                                            ;              ELSE, RUNNING-STATUS CHECK NEW STATUS BYTE
               CMP.B   MB_RUN_STATUS,D0     ;IF EQUAL TO LAST STATUS BYTE, DO NOT TRANSMIT -
               BEQ.S   L_4S_4              ;     (THIS IS HOW WE REFORM RUNNING STATUS)
               CMP.B   #0EFH,D0            ;IF A 'SYSTEM' STATUS BYTE, DO NOT SAVE AS 'RUNNING STATUS'
               BHI.S   L_4S_2_1
               MOVE.B  D0,MB_RUN_STATUS    ;     ELSE, UPDATE RUNNING STATUS COMPARE BYTE
L_4S_2_1
               CMP.B   #0F8H,D0            ;IS THIS A TIMING BYTE (SIGNALING A 96th NOTE BARRIER)?
               BNE.S   L_4S_3              ;     IF NOT, GO ON OUR MERRY WAY
               SUBQ    #1,MB_XMIT_SEQ_GATE ;          ELSE, ALL THIS GATE PERIOD - DEC COUNT
               BCC.S   L_4S_4
               CLR     MB_XMIT_SEQ_GATE     ;(MAKE SURE NEVER NEGATIVE)
               BRA.S   L_4S_4
L_4S_3
               MOVE.B  D0,UART_B_DATA      ;(THREE YEARS LATER) XMIT A BYTE
L_4S_4
               ADDQ    #1,MB_XMIT_SEQ_OUT  ;INCREMENT...
               AND     #7FFH,MB_XMIT_SEQ_OUT     ;   ...AND WRAP INDEX (1K BUFFER)
               SUBQ    #1,MB_XMIT_SEQ_CNT  ;DEC BUFFER COUNT (ALSO USED AS ACTIVITY FLAG)
               BPL.S   L_4_4_4
               CLR     MB_XMIT_SEQ_CNT
L_4_4_4
               BNE.S   L_4_EXIT
               SF      BLEED_UART_B         ;CANCEL ORDER TO DUMP SEQ MEMORY
L_4_EXIT
               MOVEM.L (A7)+,D0/A0         ;RESTORE REGISTERS
               RTE                          ;GONE!
;
;
;
; UART "B" TRANSMIT BUFFERS EMPTY - KNOCK OFF TRANSMIT INTERRUPT:
;
L_4_SHUT_DOWN
               MOVE.B  #95H,UART_B_CONTROL ;SHUT OFF UART - WE'RE DONE (FOR NOW)
               BRA     L_4_EXIT            ;AND GET US GONE.
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA


















;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; UTILITY TO PUT A MIDI BYTE INTO UART "B" "LIVE EVENT" BUFFER.
; IF THE BUFFER IS FULL (AND WRITING ONE MORE BYTE WOULD OVERFLOW THE
; BUFFER), ENABLE TRANSMISSION VIA UART "B" (TO BE SAFE), AND WAIT HERE
; UNTIL THE LEVEL 4 INTERRUPT CLEARS OUT ENOUGH BUFFER SPACE FOR US.
;
; ENTER WITH DATA BYTE IN D0.
; TRASHES A0.
;
WAIT_B_LIVE
               MOVE.B  #0B5H,UART_B_CONTROL      ;ENABLE UART "B" TRANSMIT INTERRUPT, MAKE SURE
                                                 ;MR. "B" IS ACTUALLY TRYING TO GET US MORE SPACE.
;
LOAD_B_LIVE
               CMP     #3FFH,MB_XMIT_LIVE_CNT    ;ARE WE ABOUT TO WRAP THE OUTPUT BUFFER?
               BCS.S   LOAD_B_LIVE_OK            ;BRANCH IF NOT - GO STUFF HIM BUFFA.
               BSR     MIDI_OUT_OVERRUN          ;ELSE - SEND A WARNING (IF NOT ALREADY SENT),
               BRA     WAIT_B_LIVE               ;THEN GO HAMMER ON UART "B".
;
LOAD_B_LIVE_OK
               MOVE    MB_XMIT_LIVE_IN,A0        ;ROOM AVAILABLE IN BUFFER - FETCH INPUT POINTER,
               MOVE.B  D0,MB_XMIT_LIVE_BUFF(A0)  ;LOAD NEW BYTE INTO BUFFER.
               ADDQ    #1,MB_XMIT_LIVE_IN        ;ADVANCE BUFFER INPUT POINTER,
               AND     #3FFH,MB_XMIT_LIVE_IN     ;WRAPPING IT AROUND IF NECESSARY.
               ADDQ    #1,MB_XMIT_LIVE_CNT       ;INCREMENT COUNT OF BYTES IN BUFFER.
               MOVE.B  #0B5H,UART_B_CONTROL      ;ENABLE UART TRANSMIT INTERRUPT, KICK IT AWAKE.
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA


















;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; UTILITY TO PUT A MIDI BYTE INTO UART "B" SEQUENCER EVENT BUFFER.
; IF THE BUFFER IS FULL (AND WRITING ONE MORE BYTE WOULD OVERFLOW THE
; BUFFER), ENABLE TRANSMISSION VIA UART "B" (TO BE SAFE), AND WAIT HERE
; UNTIL THE LEVEL 4 INTERRUPT CLEARS OUT ENOUGH BUFFER SPACE FOR US -
; EVEN THOUGH THIS IS TIMED INFORMATION, THE ISSUE IS PRETTY MUCH MOOT
; BY THE TIME THE BUFFER IS FULL ....
; NOTE THAT TRANSMISSION-ENABLE IN THIS CASE IS VIA REALTIME INTERRUPT,
; WHICH OBVIOUSLY MUST BE ENABLED IN ORDER FOR THIS TO WORK!
;
; ENTER WITH DATA BYTE IN D0.
; TRASHES A0.
;
LOAD_B_SEQ
               CMP     #7FFH,MB_XMIT_SEQ_CNT     ;ARE WE ABOUT TO WRAP THE OUTPUT BUFFER?
               BCS.S   LOAD_B_SEQ_OK             ;BRANCH IF NOT, GO AHEAD AND STUF-IN-BUF.
;
               BSR.S   MIDI_OUT_OVERRUN     ;ELSE - WARN USER (IF WE HAVEN'T ALREADY),
               MOVE    #1,MB_XMIT_SEQ_TIME  ;FORCE DUMP AS SOON AS LEVEL_3 GETS THERE.
;
LOAD_B_SEQ_WAIT
               CMP     #7FFH,MB_XMIT_SEQ_CNT     ;NOW WE'LL JUST WAIT UNTIL SPACE OPENS UP.
               BEQ     LOAD_B_SEQ_WAIT
;
LOAD_B_SEQ_OK
                                                 ;WE GOT BUFFER SPACE:
               MOVE    MB_XMIT_SEQ_IN,A0         ;FETCH BUFFER INPUT POINTER,
               MOVE.B  D0,MB_XMIT_SEQ_BUFF(A0)   ;LOAD NEW BYTE INTO BUFFER.
               ADDQ    #1,MB_XMIT_SEQ_IN         ;ADVANCE BUFFER INPUT POINTER,
               AND     #7FFH,MB_XMIT_SEQ_IN      ;WRAPPING IT AROUND IF NECESSARY.
               ADDQ    #1,MB_XMIT_SEQ_CNT        ;INCREMENT COUNT OF BYTES IN BUFFER.
               RTS
;
;
;
;890314;
;890314; LITTLE HELPER TO KICK UART "B" SEQ BUFFER TRANSMIT INTO LIFE,
;890314; INDEPENDENT OF (AND WITHOUT CONFUSING) SEQUENCER UART TIMEOUT OR
;890314; SEQ-CLOCK GATEKEEPER COUNT (AS MAINTAINED BY REALTIME INTERRUPT) -
;890314; ALSO AVOIDS SPURIOUS MIDI CLOCK TRANSMISSION:
;890314; (MAKES SENSE TO USE THIS WHEN SOMETHING'S ALREADY IN XMIT BUFFER.)
;890314;
;890314TRIP_B_SEQ_XMIT
;890314               MOVE.B  #0B5H,UART_B_CONTROL ;ENABLE UART TRANSMIT INTERRUPT, KICK IT AWAKE.
;890314               TST     MB_XMIT_SEQ_GATE     ;IS OUR INTERRUPT SERVICE ROUTINE CLEARED FOR WORK?
;890314               BNE.S   TBSX_EXIT            ;BRANCH IF YES, DON'T MESS WITH EXISTING GATE COUNT.
;890314               ADDQ    #1,MB_XMIT_SEQ_GATE  ;ELSE - TELL IT "OK" (NOT TO WORRY, FLAG'LL GET CLEARED
;890314                                            ;AGAIN BY INT SERVICE WHEN IT SEES WE'RE OUTA DATA).
;890314TBSX_EXIT
;890314               RTS
;890314;
;
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA


















;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; MIDI OUTPUT BUFFER OVERRUN HANDLING - SECOND TRY:
; (THIS WAS FORMERLY MIDI_PANIC, IN PRO_CLICK.)
; IT IS RUMORED THAT THE PREVIOUS SYSTEM WAS PRONE TOWARDS DESTRUCTION
; OF THE SEQUENCE WHEN THE OVERRUN CONDITION WAS DETECTED AND HANDLED -
; TO AVOID ANY DOUBT, THIS VERSION SIMPLY PUTS UP A WARNING MESSAGE IN
; THE LCD WHICH WILL REMAIN THERE UNTIL THE USER TAKES SOME ACTION.
; THIS SEEMS REASONABLE BECAUSE:
; 1.  THE BUFFER LOADING ROUTINES WILL DETECT BUFFER-FULL CONDITION AND
;     WILL SIMPLY WAIT UNTIL SPACE IN THE BUFFER BECOMES AVAILABLE -
;     NO DATA IS LOST AND AT WORST, THE SYSTEM WILL SIMPLY DRAG.
; 2.  IF THE SYSTEM STARTS TO DRAG NOTICEABLY, THE USER WILL ALMOST
;     UNDOUBTEDLY LOOK AT THE FRONT PANEL TO SEE WHAT'S GOING ON.
; 3.  THERE MAY ACTUALLY BE SOME LEGITIMATE CASES IN WHICH MIDI BUFFER
;     SATURATION OCCURS - E.G., SYSTEM EXCLUSIVE BULK DUMP PLAYBACK -
;     AND IT'S OKAY (PERHAPS INESCAPABLE, AND MAYBE EVEN EXPECTED) FOR
;     PLAYBACK TIMING TO DRAG TEMPORARILY.
; 4.  IF A LEGITIMATE TEMPORARY TIME DRAG OCCURS OWING TO A SUDDEN LUMP
;     OF PLAYBACK DATA BEING ENCOUNTERED, THE SYSTEM IS DESIGNED TO
;     CATCH ITSELF UP ONCE THINGS QUIET DOWN (PROVIDED THAT THE LEVEL 2
;     INTERRUPT IS NOT DISABLED FOR TOO LONG, ALLOWING MISSED CLOCKS).
;
; INSTEAD OF CHECKING ALL BUFFER COUNTS AFTER WRITING A COMPLETE MIDI
; MESSAGE TO WHO-KNOWS-WHERE, WE ARE CALLED DIRECTLY BY THE BUFFER-LOAD
; ROUTINES, WHICH ALREADY CHECK FOR BUFFER-FULL AS PART OF THEIR NORMAL
; EXECUTION.  THIS WAY WE ARE NOT TRIGGERED FALSELY, NOR CAN WE POSSIBLY
; FAIL TO GET TRIGGERED WHEN WE SHOULD - AND, WE DO NOT INCUR ANY EXTRA
; OVERHEAD DURING PLAYBACK OF MIDI DATA IF NO OVERRUN CONDITION EXISTS.
;
; WE PRESERVE LOS REJISTEROS - ADIOS!
;
;
MIDI_OUT_OVERRUN
               MOVE.L  A1,-(A7)
               MOVE.W  #MIDI_OVRUN_SUB,A1   ;OUR MESSAGE IS A QUASI-SUBFUNCTION, TO ALLOW IT TO
                                            ;TAKE HOLD AND STICK IN LCD.
                                            ;(NOTE - WE EXPECT TO BE IN .AWORD ADDRESS SPACE.)
               CMP.L   CUR_SUB_BLOCK,A1     ;HAVE WE ALREADY DONE THIS LATELY?
               BEQ.S   MIDI_OVR_Z0          ;EXIT IF YES, NO POINT IN WASTING TIME ON IT AGAIN.
                .ALONG
               JSR     DISP_SCREEN          ;ELSE - WRITE TO LCD DIRECTLY, SINCE BACKGROUND MAY
                                            ;NOT GET AROUND TO IT FOR A WHILE (VIA SUBFUN INSTALL).
                .AWORD
               MOVE.L  A1,CUR_SUB_BLOCK     ;MAKE THIS THE NEW SUBFUNCTION, SO THAT ANY PENDING
                                            ;INSTALL REQUESTS WILL REWRITE THE SAME MESSAGE -
                                            ;IT'LL BE AROUND FOR USER TO SEE UNTIL HE/SHE ACTUALLY
                                            ;DOES SOMETHING ABOUT IT ....
               ST      SUBFUN_INSTALL       ;RAISE THIS FLAG TOO, IN CASE ANOTHER SCREEN INSTALL
                                            ;(SUCH AS BAR/BEAT DISPLAY AT BEGINNING OF A BAR)
                                            ;WAS ALREADY IN PROGRESS - IT WOULD NOT SEE THE CHANGED
                                            ;CUR_SUB_BLOCK POINTER AND WOULD WRITE OVER OUR NICE
                                            ;MESSAGE - THIS FLAG GUARANTEES THAT A SCREEN INSTALL
                                            ;WITH OUR NEW POINTER WILL BE THE LAST ONE TO HAPPEN,
                                            ;HOWEVER REDUNDANT IT MAY BE.
MIDI_OVR_Z0
               MOVE.L  (A7)+,A1
MIDI_OVR_EXIT
               RTS
;
;
;
MIDI_OVRUN_SUB
               DC.B    "MIDI-OUT BUFFER "
               DC.B    " WAS SATURATED  "
               DC.W    0                    ;"NO_FIELDS" DECLARATION FOR THE "SUBFUNCTION".
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

