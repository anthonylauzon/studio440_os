               INCLUDE HPFIXUPS
               TITLE "DISKCMD2"
***************************************************************************************************
***************************************************************************************************
***                                                                                             ***
***            DISKCMD2 - DISK TRANSFER FUNCTION MAIN SUBROUTINES                               ***
***                                                                                             ***
***************************************************************************************************
***************************************************************************************************
;
NEG_EXT        EQU     0FFFFFF00H      ;USE IN MOVEQ INSTRUCTIONS WHERE ARG IS
                                       ;80H OR LARGER - HP XASM DOES NOT HANDLE
                                       ;SIGN-EXTEND CORRECTLY.  COSMETIC, KEEPS
                                       ;ACTUAL BYTE VALUE CLEARER.
;
               INCLUDE EQUATES         ;HDW ADDR AND CONSTANT DEFS, ABS_SHORT DIRECTIVE.
;
               INCLUDE S_BLK_EQU       ;SOUND CONTROL BLOCK DEFINITIONS.
;
               INCLUDE DISKDEFS        ;DISK SYSTEM DEFINITIONS, INCLUDING
                                       ;MODEL 2000 SOUND BLOCK DEFINITIONS.
;
               GLB     FORMAT_DISK,NOTNAMED_STRING,INIT_DIR_SCRN
               GLB     CORP_ID_STR,MODEL_ID_STR,CORP_ID_LEN,FULL_ID_LEN
               GLB     TRANSFER,MOVE_SUBFILE,LOAD_ONE_SOUND
               GLB     TRANSFER_2000,SEQUENCES_MOVE
               GLB     SYSTEM_MOVE,CONTROLS_MOVE,KITS_MOVE
               GLB     CUELIST_MOVE,SONGS_MOVE
               GLB     DEL_TARG_SCRN
;
                                            ; external ROM addresses.
;890317               EXTERNAL  CREATE_SAMPLE
               EXTERNAL  INIT_SND_CTL_BLK
               EXTERNAL  SET_ROOT_PITCH
               EXTERNAL  DISP_SCREEN
               EXTERNAL  POSTDEL_SAMSPC
               EXTERNAL  GET_PROP_BLK_PTR
               EXTERNAL  DELETE_SHUFFLE
               EXTERNAL  SEL_SIDE_0
               EXTERNAL  TO_TRK_00
               EXTERNAL  INDICATE
               EXTERNAL  TRACK_WRITE
               EXTERNAL  STEP_INWARD
               EXTERNAL  SEL_SIDE_1
               EXTERNAL  LOOK_FOR_ADDR
               EXTERNAL  TRK_WR_TAG
               EXTERNAL  SECTOR_WRITE
               EXTERNAL  RETRY
               EXTERNAL  DISP_XFR_SCREEN
               EXTERNAL  DISKWARD_HO,QUERY
               EXTERNAL  SOUND_PARAMS_MOVE
               EXTERNAL  MOVE_PAD_PARAMS
               EXTERNAL  MOVE_PADS_ASAP
               EXTERNAL  SET_RAM_INTFC
               EXTERNAL  SAMPLE_MOVE
               EXTERNAL  BLIND_SEEK
               EXTERNAL  DLY_20_MSEC
               EXTERNAL  SECTOR_READ
               EXTERNAL  ADVANCE_REC
               EXTERNAL  LOAD_FILE_SUB
               EXTERNAL  MOVE_SEQ_DATA
               EXTERNAL  SEQ_DATA_RECOVER
               EXTERNAL  WRITE_DESCRIPTOR
               EXTERNAL  MOVE_MIDI_BLOCK
               EXTERNAL  MOVE_SEQ_SYS_BLOCK
               EXTERNAL  MOVE_SMPTE_BLOCK
               EXTERNAL  MOVE_SEQ_DIRECTORY
               EXTERNAL  MOVE_SEQ_BLOCK_LIST
               EXTERNAL  MOVE_SONG_LIST
               EXTERNAL  MOVE_CUE_LIST
               EXTERNAL  RCVR_SEQ_DIRECTORY
               EXTERNAL  RCVR_SEQ_BLOCK_LIST
               EXTERNAL  RCVR_SONG_LIST
               EXTERNAL  RCVR_CUE_LIST
               EXTERNAL  QUIET_RETRY
               EXTERNAL  GET_CUR_SEQ_DIR
               EXTERNAL  UPDATE_SEQ_SIZE
               EXTERNAL  INIT_SCSI_DIR
               EXTERNAL  SCSI_ALL_SND_MOVE
               EXTERNAL  SCSI_ALL_SEQ_MOVE
               EXTERNAL  SCSI_CONFIG_MOVE
               EXTERNAL  SCSI_SND_CTRL_MOVE
               EXTERNAL  SCSI_SEQ_DIR_MOVE
               EXTERNAL  SCSI_KITS_MOVE
               EXTERNAL  SCSI_CUELIST_MOVE
               EXTERNAL  SCSI_SONGLIST_MOVE
               EXTERNAL  SCSI_BLOCKLIST_MOVE
               EXTERNAL  SCSI_SEQ_BLOCK_MOVE
               EXTERNAL  SCSI_SAMPLE_MOVE
;
               EXTERNAL  Q_BLOCK_SIZE       ;SEQUENCE DIRECTORY DEFINITIONS.
               EXTERNAL  Q_STATUS
               EXTERNAL  Q_MEM_USED
               EXTERNAL  Q_START_BLK
;
               EXTERNAL  CURRENT_TRACK      ;RAM, HEY.
               EXTERNAL  CURRENT_SIDE
               EXTERNAL  WASTELAND
               EXTERNAL  WASTELAND_2
               EXTERNAL  RETRIES
               EXTERNAL  DISK_OP_CODE
               EXTERNAL  CUR_XFR_ADDR
               EXTERNAL  CURRENT_SEC
               EXTERNAL  SECTOR_OFFSET
               EXTERNAL  CURRENT_REC
               EXTERNAL  BEGIN_TRUNC
               EXTERNAL  SND_UNIT_SEL
               EXTERNAL  TRUNC_BYTES
               EXTERNAL  BYTE_LENGTH
               EXTERNAL  DSK_FIL_LENGTH
               EXTERNAL  FREE_SAM_RAM
               EXTERNAL  SAMPLE_RAM_END
               EXTERNAL  DSK_FIL_ADDR
               EXTERNAL  BEG_REC_WORDS
               EXTERNAL  BEG_REC_BYTES
               EXTERNAL  FINAL_REC
               EXTERNAL  FIN_REC_WORDS
               EXTERNAL  FIN_REC_BYTES
               EXTERNAL  CURRENT_SOUND
               EXTERNAL  CR_SAM_SIZE
               EXTERNAL  S_BLK_00
;890317               EXTERNAL  CUR_SUB_BLOCK
               EXTERNAL  LFT_HLF_STAT
               EXTERNAL  RGT_HLF_STAT
               EXTERNAL  FMT_CODE
               EXTERNAL  SEQ_UNIT_SEL
               EXTERNAL  SEQ_DIR_99
               EXTERNAL  LAST_FREE_BLK
               EXTERNAL  SEQ_WR_BLK
               EXTERNAL  SEQUENCE_RAM
               EXTERNAL  SEQ1_DRD_BLK
               EXTERNAL  SEQ_BLOCK_LIST
               EXTERNAL  PREV_WR_BLK
               EXTERNAL  CURRENT_SEQUENCE
               EXTERNAL  LAST_SETUP_SEQ
               EXTERNAL  DIRECTORY_BUF
               EXTERNAL  DRIVE_SEL
               EXTERNAL  FD_DESCR_LEN
               EXTERNAL  CUR_FILE_TYPE
               EXTERNAL  CUR_FIRMWR_REV
               EXTERNAL  CUR_QFILE_STAT
               EXTERNAL  BANK_DESCR_BUF
               EXTERNAL  FD_DISK_NAME
               EXTERNAL  CUR_BANK_NAME
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; DISK FORMATTING/DIRECTORY-INIT (FLOPPY AND SCSI BOTH CUM BAI YAH).
; IF HD_UTIL_BIT IN DISK_OP_CODE IS SET,  WE REALLY MEANT SCSI DISK.
;
; DESCRIPTOR CHECKING IS DONE BEFORE WE GET TO THIS POINT -
; DISK SYSTEM WON'T GET HERE UNLESS DISK IS COMPLETELY DEVOID OF FORMAT
; OR "NOT BLANK" WARNING IS OVERRIDEN BY USER.
; RETURNS Z FLAG SET IF ALL OPERATIONS SUCCESSFUL,
; ELSE RETURNS ERROR CODE IN D0 AND Z FLAG CLEAR.
;
; PROCEDURE FOR FLOPPY DISK:
; FORMAT ALL TRACKS OF DISKETTE, ON BOTH SIDES -
; ONCE ALL TRACKS ARE FORMATTED, MINIMAL TEST IS DONE TO VERIFY PRESENCE
; OF VALID FORMAT WITH CORRECT SIDE NUMBERS ON BOTH SIDES OF DISK.
; IF THIS TEST IS PASSED, DESCRIPTOR SECTOR IS INITIALIZED.
; USES/DESTROYS D0-D4, A0-A1.
;
; PROCEDURE FOR SCSI DISK:
; REFER TO SCSI MODULES, SPECIFICALLY INIT_SCSI_DIR.
;
FORMAT_DISK
               MOVE    DISK_OP_CODE,D0      ;SEE WHAT WE'RE SUPPOSED TO BE DOING:
               BTST    #HD_UTIL_BIT,D0      ;ARE WE IN SCSI HARD DISK UTILITY LAND?
               BNE     INIT_SCSI_DIR        ;BRANCH IF YA, DIFFERENT PROCEDURE ALTOGETHER
                                            ;(AHMSAHRI TAHBAHTHYA) -
;
FMT_DSK_20
                                            ;DO THAT FLOPPY THANG:
               BSR     SEL_SIDE_0           ;START WITH SIDE 0.
               MOVE.L  #FMT_SID_0_SCREEN,A1 ;TELL USER WUZ HABNIN'.
                ABS_LONG
               JSR     DISP_SCREEN
                ABS_SHORT
FMT_DSK_30
               CLR     CURRENT_TRACK        ;START WITH TRACK 00 ON EACH SIDE.
               BSR     TO_TRK_00            ;MAKE SURE THAT'S WHERE READ/WRITE HEAD REALLY IS.
               BNE     FMT_DSK_EXIT         ;EXIT IF UNABLE TO REACH TRACK 00 (HARDWARE TROUBLE!).
FMT_DSK_40
               MOVE    CURRENT_TRACK,D0     ;LIGHT A KIT/BANK LED TO INDICATE WHICH TRACK WE'RE ON.
               BSR     INDICATE             ;(LATER, WE'LL WANT TO USE LCD FOR THIS).
               BSR     TRACK_WRITE          ;FORMAT CURRENT TRACK (FORMAT DEFINED IN TRACK_WRITE).
               BNE     FMT_DSK_EXIT         ;IF ANY ERROR OCCURS, HALT FORMATTING OPERATION.
FMT_DSK_50
               CMP     #79,CURRENT_TRACK    ;WHICH TRACK JUST GOT FORMATTED?
               BEQ.S   FMT_DSK_60           ;BRANCH IF ALL TRACKS FORMATTED ON THIS SIDE OF DISK.
               ADDQ    #1,CURRENT_TRACK     ;ELSE, DO THE NEXT.  YUH-YUH-YUH-YUH-
               BSR     STEP_INWARD          ;NOTE: DISK-ROTATION TIME OBVIATES NEED
               BRA     FMT_DSK_40           ;FOR HEAD-SETTLING DELAY HERE.
FMT_DSK_60
               TST     CURRENT_SIDE         ;DID WE JUST FINISH SIDE 1?
               BNE.S   FMT_DSK_70           ;BRANCH IF YES,
               BSR     SEL_SIDE_1           ;ELSE SELECT SIDE 1,
               MOVE.L  #FMT_SID_1_SCREEN,A1 ;TELL USER WUZ HABNIN',
                ABS_LONG
               JSR     DISP_SCREEN
                ABS_SHORT
               BRA     FMT_DSK_30           ;GO BACK AND FORMAT IT.
FMT_DSK_70
               BSR     LOOK_FOR_ADDR        ;BOTH SIDES DONE - VERIFY SIDE 1 FORMAT.
               BNE.S   FMT_DSK_EXIT         ;BRANCH IF ANYTHING IS NOT COOL.
               BSR     SEL_SIDE_0           ;IF SIDE 1 OK, CHECK SIDE 0 FORMAT.
               BSR     LOOK_FOR_ADDR
               BNE.S   FMT_DSK_EXIT         ;BRANCH IF ANYTHING IS NOT COOL.
               MOVE.L  #INIT_DIR_SCRN,A1    ;COOL - ISSUE PROGRESS REPORT,
                ABS_LONG
               JSR     DISP_SCREEN
                ABS_SHORT
               CLR     CURRENT_TRACK        ;HEAD FOR TRACK 00 TO WRITE DESCRIPTOR RECORD.
               BSR     TO_TRK_00
               BNE.S   FMT_DSK_EXIT         ;EXIT IF UNABLE TO RETURN TO TRACK 00.
;
               MOVE    #WASTELAND,A0        ;ASSEMBLE DESCRIPTOR INFO IN WASTELAND.
               MOVE.L  #CORP_ID_STR,A1      ;PUT CORP_ID_STR, MODEL_ID_STR AT START OF DESCRIPTOR.
               MOVEQ   #FULL_ID_LEN,D1
FMT_DSK_80
               MOVE.B  (A1)+,(A0)+
               SUBQ    #1,D1
               BNE     FMT_DSK_80
FMT_DSK_90
                                            ;OTHER DESCRIPTOR PARAMETERS:
               MOVE    #REV_1,(A0)+         ;FIRMWARE_REV: DISK FORMATTED BY REV-1 (DISK) FIRMWARE.
               MOVE    #-1,(A0)+            ;DISK_TYPE: UNCOMMITTED UNTIL FIRST SAVE OPERATION.
               MOVE    #DELETED,D0          ;FILE STATUS FLAGS: INDICATE ALL FILES EMPTY.
               MOVEQ   #15,D1               ;AS OF INITIAL RELEASE, ONLY ONE FLAG DEFINED -BUT TOSS
                                            ;IN A HANDFUL OF EXTRAS, JUST TO MINIMIZE HEADACHES.
FMT_DSK_A0
               MOVE    D0,(A0)+
               DBRA    D1,FMT_DSK_A0
;
                ABS_LONG
               MOVE.L  NOTNAMED_STRING,(A0)+     ;TACK ON DEFAULT FLOPPY DISK NAME.
               MOVE.L  NOTNAMED_STRING+4,(A0)+
                ABS_SHORT
;
               BSR     TRK_WR_TAG           ;REPLICATE EXISTING TRACK TAG, IF ANY.
FMT_DSK_B0
               MOVE    (A1)+,D0
               NOT     D0
               MOVE    D0,(A0)+
               DBRA    D1,FMT_DSK_B0
;
               CLR     RETRIES              ;DESCRIPTOR INFO ASSEMBLED - WRITE IT TO DISK.
FMT_DSK_C0
               MOVEQ   #5,D0                ;THAT'S SECTOR 05 FOR DESCRIPTOR.
               ADD     #FD_DESCR_LEN,D2     ;WRITE THIS # OF BYTES (REMAINDER OF SECTOR GETS 00),
               MOVE    #WASTELAND,A0        ;STARTING AT THIS ADDRESS.
               BSR     SECTOR_WRITE
               BEQ.S   FMT_DSK_EXIT         ;BRANCH IF DESCRIPTOR SECTOR WRITE WAS SUCCESSFUL,
               BSR     RETRY                ;ELSE SET UP FOR RETRY OF DESCRIPTOR SECTOR WRITE -
               BEQ     FMT_DSK_C0           ;BRANCH IF (ANOTHER) RETRY CAN BE DONE,
               MOVEQ   #FORMAT_INCMPLT,D0   ;ELSE RETURN WITH "FORMAT INCOMPLETE" ERROR CODE.
;881025               BRA.S   FMT_DSK_EXIT
               NOP
                                            ;(THIS NOP IS A PLACE HOLDER FOR THE
                                            ;ABOVE BRA.S, WHICH ASSEMBLED AS 'NOP'
                                            ;UNDER HP64000 - STRICTLY FOR INITIAL
                                            ;LINK MAP MATCH-UP, DELETE AFTERWARDS).
;
FMT_DSK_EXIT
               RTS
;
;
CORP_ID_STR    ASC     "(C)SEQUENTIAL-1986"
MODEL_ID_STR   ASC     "0440"
CORP_ID_LEN    EQU     18                   ;NOTE - STRING LENGTH VALUES ENCOMPASS ONLY THE ID,
FULL_ID_LEN    EQU     22                   ;NOT THE WHOLE DESCRIPTOR.
               EVEN
;
;
NOTNAMED_STRING
               ASC     "notnamed"
;
;
FMT_SID_0_SCREEN
               ASC     "   FORMATTING   "
               ASC     "   THIS SIDE    "
FMT_SID_1_SCREEN
               ASC     "   FORMATTING   "
               ASC     " OTHER SIDE NOW "
INIT_DIR_SCRN
               ASC     "  INITIALIZING  "
               ASC     "    DIRECTORY   "
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; PERFORM REQUESTED TRANSFER OF SAMPLE, SEQUENCE, SETUP OR OTHER DATA.
;
; DISK DESCRIPTOR INFO HAS ALREADY BEEN READ INTO APPROPRIATE BUFFERS -
; IF WE BE USING FLOPPY DISK, THEN IT IS CUED UP TO TRACK 00, SIDE 0.
;
; DISK_OP_CODE IS THE MAJOR CONTROLLING PRINCIPLE HERE -
; FULL-DISK SAVE/LOAD/VERIFY (BOTH SOUND AND SEQUENCE DISKS), ONE-SOUND
; LOAD, ONE-SEQUENCE LOAD, SOUND CONTROLS, SYS CONFIG AND EVEN PAD
; ARRAY, CUE LIST AND SONG LIST TRANSFERS ARE ENCOMPASSED BY THIS
; GODLIKE COMMAND WORD.
; ON THE BASIS OF BITS SET IN DISK_OP_CODE, TRANSFER WILL BRANCH TO ONE
; OF SEVERAL SUBROUTINES, EACH OF WHICH RETURNS ON ITS OWN.
;
; NOTE THAT LOADING FROM MODEL 2000 DISKS IS DONE BY A SEPARATE ROUTINE
; CALLED TRANSFER_2000 - THE DISTINCTION IS MADE AT DISKMAIN LEVEL.
;
; LOAD/VERIFY FROM NO-FILE DISKS (DISK_TYPE = 0FFFFH, "UNCOMMITTED")
; ARE BLOCKED AT THE DISKMAIN LEVEL, AS ARE SAVES TO NON-440 DISKS.
;
TRANSFER
               BSR     DISP_XFR_SCREEN      ;DISPLAY TRANSFER SCREEN.
;
               MOVE    DISK_OP_CODE,D0      ;WHAT DO WE DO, THEN.
;
               BTST    #SEQ_BIT,D0          ;SEQUENCES TRANSFER - ONE/ALL/DIRECTORY.
               BNE     SEQUENCES_MOVE       ;POSSIBLY ALSO SONGS, SYSTEM CONFIG.
               BTST    #SAM_BIT,D0          ;SOUNDS TRANSFER - ONE/ALL/DIRECTORY.
               BNE.S   SOUNDS_MOVE          ;POSSIBLY ALSO KITS, SYSTEM CONFIG.
;
               BTST    #SYSTEM_BIT,D0       ;SYSTEM CONFIGURATION FILE ONLY.
               BNE     SYSTEM_MOVE
               BTST    #CONTROL_BIT,D0      ;SOUND CONTROLS ONLY.
               BNE     CONTROLS_MOVE
               BTST    #KIT_BIT,D0          ;PAD KIT/BANK ARRAYS ONLY.
               BNE     KITS_MOVE
               BTST    #CUELIST_BIT,D0      ;SMPTE CUE LIST.
               BNE     CUELIST_MOVE
               BTST    #SONG_BIT,D0         ;SEQUENCER SONG LIST TRANSFER - ONE/ALL/DIRECTORY.
               BNE     SONGS_MOVE
;
               CLR     D0                   ;ONE OF THE ABOVE SHOULD HAVE HIT -
                                            ;DON'T UNDERSTAND - MUST GO.
;
XFR_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; SOUNDS TRANSFER ROUTINE -
; COME HERE FOR ALL-SOUNDS TRANSFER, ONE-SOUND LOAD, SOUND DIRECTORY.
; 440 DISKS ONLY - 2000 DISKS HAVE THEY OWN SCENE, OTHER SIDE O' TOWN.
; ALL-SOUNDS TRANSFER MAY ALSO MOVE KITS OR KITS/SYS-CONFIG AS WELL -
; WHEN SAVING TO DISK, WILL AUTOMATICALLY SAVE ANY OF THE ABOVE WHICH DO
; NOT ALREADY EXIST ON DISK, EVEN IF NOT ALL ARE REQUESTED BY USER, SO
; THAT ANY DISK/BANK WITH TYPE = SOUNDS IS GUARANTEED TO HAVE ALL THREE.
; D0 CONTAINS DISK_OP_CODE UPON ENTRY.
;
SOUNDS_MOVE
               MOVE    CUR_FILE_TYPE,D1     ;FETCH MAIN FILE TYPE CODE, DECIDE HOW TO VIEW IT -
               BTST    #SAVE_BIT,D0         ;ARE WE DOING A SAVE?
               BNE.S   SND_MOV_30           ;BRANCH IF YES, RESPONSES TO STATUS ARE DIFFERENT.
;
;
;
               TST     D1                   ;LOAD OR VERIFY - MUST HAVE A SOUNDS FILE.
               BEQ.S   SND_MOV_80           ;WE GOT IT, MOVE ALONG.
               MOVEQ   #DATA_NOT_PRES,D0    ;FOR ANY OTHER VALUE, SAY THIS -
               BRA     SND_MOV_EXIT         ;AND GO ON VACATION, OR SOME SUCH.
;
SND_MOV_30
                                            ;SAVING TO DISK:
               TST     D1                   ;FILE TYPE = 0 FOR SOUNDS DISK/BANK, ALL SAVES ALLOWED.
               BEQ.S   SND_MOV_50           ;IF THIS WHAT IT IS, POST WARNING OF NON-EMPTY FILE.
               OR      #KIT_MASK,DISK_OP_CODE    ;NON-SOUNDS DISK/BANK BEING CONVERTED TO SOUNDS
                                                 ;TYPE - MUST ALSO HAVE A KITS FILE SAVED.
                                                 ;QUIETLY PATCH DISK_OP_CODE FOR THIS.
               CMP     #1,D1                ;THIS TYPE VALUE SIGNIFIES SEQUENCES DISK/BANK - BRANCH
               BEQ.S   SND_MOV_40           ;IF THIS WHAT WE GOT, SYS CONFIG FILE ALREADY ON DISK.
               OR      #SYSTEM_MASK,DISK_OP_CODE      ;ELSE, ASSUME NO SYS CONFIG FILE ON DISK -
                                                      ;PATCH DISK_OP_CODE SO WE SAVE ONE NOW.
               CMP     #0FFFFH,D1           ;THIS IS MOLTI BONI, MEANS DISK/BANK EMPTY (UNTYPED) -
               BEQ.S   SND_MOV_70           ;AND WE'LL JUST SCURRY ALONG IF WE GOT IT, NO WARNINGS.
               MOVEQ   #OTH_FILE_HERE,D0    ;ELSE WARN DEM ABOT SOME OTHER KINDA FILE ALREADY HERE.
               BRA.S   SND_MOV_60
SND_MOV_40
               MOVEQ   #SEQ_FILE_HERE,D0    ;WARN DEM ABOT DEM SEQUENCE DATTA ON DEM DISK.
               BRA.S   SND_MOV_60
SND_MOV_50
               MOVEQ   #FILE_NOT_EMPTY,D0   ;GIVE HIM ONE CHANCE TO CHANGE HIS MIND ....
SND_MOV_60
               BSR     QUERY                ;SHOULD I STAY OR SHOULD I GO?
               BNE     SND_MOV_EXIT         ;BRANCH IF ERROR (E.G., USER PULLED DISK OUT).
               BCS     SND_MOV_EXIT         ;BRANCH IF USER SAID "QUIT."
               BSR     DISP_XFR_SCREEN      ;REDISPLAY TRANSFER SCREEN AND CONTINUE.
SND_MOV_70
                                            ;NOW, UPDATE STATUS IN MAIN DESCRIPTOR BUFFER:
               CLR     CUR_FILE_TYPE        ;MAKE SURE FILE IS COMMITTED AS SOUNDS FILE.
               MOVE    #REV_1,CUR_FIRMWR_REV     ;ALSO SET IT TO REV-1 - MIGHTA BEEN REV-0 BEFORE,
                                                 ;BUT IT WON'T BE AFTER THIS ....
               BSR     WRITE_DESCRIPTOR     ;TRY, TRY TO PUT IT OUT THERE (NOTE: THIS WILL ALSO PUT
                                            ;RESIDENT SOUND BANK NAME INTO DISK/BANK DESCRIPTOR).
               BNE     SND_MOV_EXIT         ;EXIT IF ERROR (E.G. DISK REMOVED).
               BCS     SND_MOV_EXIT         ;EXIT IF USER SAID "LET'S NOT."
               BRA.S   SND_MOV_A0           ;NO DIRECTORY-SAVE OR ONE-SOUND SAVE, SKIP NEXT BIT.
;
;
;
SND_MOV_80
               MOVE    DISK_OP_CODE,D1      ;SO, WHAT WAS IT WE WERE DOING AGAIN ....
               BTST    #DIR_BIT,D1          ;ARE WE DOING A DIRECTORY READ?
               BEQ.S   SND_MOV_90           ;BRANCH IF NOT - FETCH DISK/BANK NAME, THEN GO ALL-OUT.
               TST     DRIVE_SEL            ;EXTRACTING DIRECTORY - WHAT DRIVE ARE WE ON?
               BPL     SCSI_SND_CTRL_MOVE   ;BRANCH FOR SCSI BANK DIRECTORY EXTRACTION -
               BRA     SOUND_PARAMS_MOVE    ;ELSE, JUST DO THIS AND RETURN THROUGH.
;
SND_MOV_90
               BTST    #MOV_ALL_BIT,D1      ;ARE WE DOING A ONE-SOUND LOAD?
               BEQ     LOAD_ONE_SOUND       ;BRANCH IF YES, SEPARATE PROCEDURE FROM THIS POINT.
                                            ;ELSE - FETCH DISK/BANK NAME, THEN GO ALL-OUT.
               BSR     COPY_BANK_NAME       ;MOVE DISK OR BANK NAME INTO MAIN DESCRIPTOR BUFFER
                                            ;(IF LOADING - FOR VERIFY, NO ACTION).
;
;
;
SND_MOV_A0
                                            ;OKAY, THIS IS IT!
               TST     DRIVE_SEL            ;BUTT WEIGHT AMINIT - WHITHER GOEST US?
               BPL     SCSI_ALL_SND_MOVE    ;BRANCH IF GOING SCSI-LY - SEPRIT PROCEDURE FROM HERE.
;
                                            ;FLOPPY, THEN:
;
               MOVE    DISK_OP_CODE,D1      ;SHOULD WE BE TRANSFERRING SYS CONFIG STUFF?
               BTST    #SYSTEM_BIT,D1
               BEQ.S   SND_MOV_B0           ;BRANCH IF NOT, ELSE ....
;
               BSR     MOVE_MIDI_BLOCK      ;MOVE MIDI SYS CONFIG BLOCK.
               BNE.S   SND_MOV_EXIT         ;BRANCH IF ERROR.
               BCS.S   SND_MOV_EXIT         ;BRANCH IF USER ABORTED AFTER ERROR.
;
               BSR     MOVE_SEQ_SYS_BLOCK   ;MOVE SEQUENCER SYS CONFIG BLOCK.
               BNE.S   SND_MOV_EXIT         ;BRANCH IF ERROR.
               BCS.S   SND_MOV_EXIT         ;BRANCH IF USER ABORTED AFTER ERROR.
;
               BSR     MOVE_SMPTE_BLOCK     ;MOVE SMPTE SYS CONFIG BLOCK.
               BNE.S   SND_MOV_EXIT         ;BRANCH IF ERROR.
               BCS.S   SND_MOV_EXIT         ;BRANCH IF USER ABORTED AFTER ERROR.
;
SND_MOV_B0
               BSR     SOUND_PARAMS_MOVE    ;MOVE SOUND CONTROLS FOR ALL SOUNDS.
               BNE.S   SND_MOV_EXIT         ;BRANCH IF ERROR.
               BCS.S   SND_MOV_EXIT         ;BRANCH IF USER ABORTED AFTER ERROR.
;
               MOVE    DISK_OP_CODE,D1      ;SHOULD WE BE TRANSFERRING PAD KITS/BANKS?
               BTST    #KIT_BIT,D1
               BEQ.S   SND_MOV_C0           ;BRANCH IF NOT, ELSE ....
;
               BSR     MOVE_PADS_ASAP       ;SHOVEL THIS OTHER CRAP OUT TOO, PRONTO.
               BNE.S   SND_MOV_EXIT         ;BRANCH IF ERROR.
               BCS.S   SND_MOV_EXIT         ;BRANCH IF USER ABORTED AFTER ERROR.
;
;
SND_MOV_C0
                                            ;SO MUCH FOR ITTY-BITS -
               CLR.L   CUR_XFR_ADDR         ;FULL SAMPLE-FILE TRANSFERS START AT 0 IN BOTH
                                            ;DISK AND SAMPLE RAM DOMAINS.
SND_MOV_D0
               MOVEQ   #SUBFILE_0_TRK,D0    ;SET INITIAL TRANSFER TRACK FOR FIRST SUBFILE
                                            ;ON CURRENT DISK SIDE.
SND_MOV_E0
               MOVE    D0,CURRENT_TRACK     ;STORE CURRENT SUBFILE STARTING TRACK NUMBER,
               BSR.S   MOVE_SUBFILE         ;TRANSFER ENTIRE SAMPLE SUBFILE.
               BNE.S   SND_MOV_EXIT         ;EXIT IF ERROR.
               BCS.S   SND_MOV_EXIT         ;EXIT IF USER ABORTED AFTER ERROR.
;
               MOVEQ   #SUBFILE_1_TRK,D0    ;FETCH STARTING TRACK FOR SIDE 0 UPPER/INNER SUBFILE -
               TST     CURRENT_SIDE
               BEQ.S   SND_MOV_F0           ;BRANCH IF WE'RE ON SIDE 0, TRACK NUMBER IS OK -
               CMP     #REV_0,CUR_FIRMWR_REV     ;IF SIDE 1, NEED TO LOOK AT DISK REVISION CODE -
               BEQ.S   SND_MOV_F0           ;IF REV-0, SUBFILES ARE ON SAME TRACKS ON BOTH SIDES -
               MOVEQ   #SUBFILE_3_TRK,D0    ;ELSE LOAD CORRESPONDING REV-0 SIDE 1 TRACK NUMBER.
SND_MOV_F0
               CMP     CURRENT_TRACK,D0     ;DID WE JUST DO AN UPPER/INNER SUBFILE TRANSFER?
               BGE     SND_MOV_E0           ;BRANCH IF NOT, GO DO IT (SAME SIDE OF DISK).
               CMP     #1,CURRENT_SIDE      ;YES - WE'RE DONE WITH THIS SIDE, WHICH SIDE IS IT?
               BEQ.S   SND_MOV_EXIT         ;IF SIDE 1, WE'RE DONE - DO NO-ERROR RETURN.
               BSR     SEL_SIDE_1           ;ELSE, SELECT DISK SIDE 1 -
               BSR     LOOK_FOR_ADDR        ;TAKE TIME TO MAKE SURE WE'RE REALLY THERE.
               BNE.S   SND_MOV_EXIT         ;EXIT IF WE CAN'T SEEM TO FIND IT.
               CMP     #REV_0,CUR_FIRMWR_REV     ;ELSE, COOL - SEE IF THIS IS A REV-0 DISK -
               BEQ     SND_MOV_D0           ;BRANCH IF YES, SUBFILES SAME ON BOTH SIDES OF DISK.
               MOVEQ   #SUBFILE_2_TRK,D0    ;FOR REV-1, SIDE 1 SUBFILES ARE ON DIFFERENT TRACKS
               BRA     SND_MOV_E0           ;FROM SIDE 0 SUBFILES.
;
SND_MOV_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; TRANSFER A COMPLETE SAMPLE SUBFILE -
; ASSUMES CURRENT_TRACK IS SET TO SUBFILE STARTING TRACK NUMBER,
; AND DESIRED DISK SIDE HAS BEEN SELECTED AND VERIFIED.
; CALLS SAMPLE_MOVE WITH SETUP NEEDED FOR FULL SUBFILE TRANSFER,
; PASSES SAMPLE_MOVE RETURN CODES BACK UNTOUCHED.
;
MOVE_SUBFILE
               CLR     CURRENT_SEC          ;FULL SUBFILE MOVE STARTS WITH "EVERYTHING" SET TO 0.
               CLR     SECTOR_OFFSET
               CLR     CURRENT_REC
               SF      BEGIN_TRUNC          ;WE DON'T SKIP ANYTHING.
               MOVE    #END_RECORD,FINAL_REC          ;THIS IS HOW WE KNOW WHEN TO QUIT ....
               MOVE    #END_REC_BYTES,FIN_REC_BYTES   ;NUMBER OF BYTES TRANSFERRED FOR FINAL_REC.
               MOVE.L  #END_REC_WORDS,FIN_REC_WORDS   ;LIKEWISE, FOR WORD TRANSFER COUNT.
               BSR     SET_RAM_INTFC        ;SET UP SAMPLE RAM INTERFACE FOR THIS TRANSFER -
                                            ;NOTE - THIS IS DONE FOR EACH SAMPLE SUBFILE MAINLY
                                            ;BECAUSE WE DON'T KNOW IF IT IS THE FIRST SUBFILE BEING
                                            ;TRANSFERRED - INTERFACE MAY NOT BE INITIALIZED YET.
               BRA     SAMPLE_MOVE          ;SO HERE WE GO - RETURN THROUGH.
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;
;
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; COPY DISK OR BANK NAME INTO MAIN DESCRIPTOR BUFFER -
; INVOKED DURING ALL-SOUNDS OR ALL-SEQUENCES LOAD OR VERIFY FROM DISK
; (BUT - OF COURSE - NO ACTION FOR VERIFY OPERATION),
; AFTER ALL VALIDITY AND COMPATIBILITY TESTS HAVE BEEN PASSED.
; IF DRIVE_SEL = -1 (FLOPPY), NAME IS OBTAINED FROM FD_DESCR_BUF -
; FOR SCSI DISK, NAME IS OBTAINED FROM BANK_DESCR_BUF -
; EITHER WAY, THE INFO IS FROM APPLICABLE DISK DESCRIPTOR, HAVING BEEN
; READ AT BEGINNING OF DISK OPERATION BY A CALL TO READ_DESCRIPTOR.
; DEPENDING ON FILE TYPE (SOUNDS OR SEQUENCES), NAME IS PLACED IN
; CUR_BANK_NAME OR CUR_BANK_NAME+8 - TWO NAME SLOTS ARE MAINTAINED.
;
COPY_BANK_NAME
               MOVE    DISK_OP_CODE,D0      ;ARE WE DOING A VERIFY OPERATION?
               BTST    #VERIFY_BIT,D0
               BNE.S   COP_NAM_EXIT         ;EXIT IF YES, DON'T TAMPER WITH RESIDENT BANK NAMES.
               TST     DRIVE_SEL            ;WHICH DRIVE IS DATA COMING IN FROM?
               BMI.S   COP_NAM_20           ;BRANCH IF FLOPPY, GET NAME FROM FD_DESCR_BUF -
               MOVE    #BANK_DESCR_BUF,A0   ;ELSE GET NAME FROM SCSI BANK_DESCR_BUF -
               BRA.S   COP_NAM_60           ;COPY NAME INTO MAIN DESCR BUF (SOUND BANK NAME SLOT).
COP_NAM_20
               MOVE    #FD_DISK_NAME,A0     ;GET NAME FROM FLOPPY DISK DESCRIPTOR BUFFER.
COP_NAM_60
               MOVE    #CUR_BANK_NAME,A1    ;SET POINTER TO BANK NAME SLOTS.
               TST     CUR_FILE_TYPE        ;SOUND FILE?
               BEQ.S   COP_NAM_80           ;BRANCH IF YES, NAME GOES INTO LOWER SLOT.
               ADDQ    #8,A1                ;ELSE, POINT TO SEQUENCE BANK NAME SLOT -
               CMP     #1,CUR_FILE_TYPE     ;IS THIS WHAT WE GOT?
               BNE.S   COP_NAM_EXIT         ;BRANCH IF NOT, DON'T DO ANYTHING (WHAT A WASTE!).
COP_NAM_80
               MOVE.L  (A0)+,(A1)+          ;COPY NAME STRING INTO MAIN DESCRIPTOR BUFFER
               MOVE.L  (A0),(A1)            ;IN APPROPRIATE BANK NAME SLOT.
COP_NAM_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; ONE-SOUND LOAD FROM 440 DISK -
; LOADS SOUND FROM DISK AS INDICATED BY SND_UNIT_SEL.
; IF THIS SOUND IS DELETED ON DISK, NO ACTION OCCURS.
;
; SOUND IS LOADED INTO CURRENT_SOUND SLOT - IF NOT EMPTY, USER IS GIVEN
; A CHANCE TO DECIDE WHETHER TO CONTINUE.  IF USER CHOOSES TO CONTINUE,
; SOUND IS DELETED, AND EXECUTION JUMPS BACK TO BEFORE THE BEGINNING
; (INCLUDING STACK ADJUSTMENTS - CAUTION BE YOU IF PLAYING AROUND HERE).
;
; THE SOURCE SOUND CONTROL BLOCK IS BUFFERED FOR INSPECTION, AND IS NOT
; MOVED INTO THE TARGET CONTROL BLOCK UNTIL SAMPLE DATA TRANSFER IS
; COMPLETE - IF TRANSFER IS TERMINATED AT ANY TIME BEFORE THIS POINT,
; THE LOADED SOUND WILL THEREFORE NOT APPEAR IN ANY FORM TO THE USER.
;
; FOR FLOPPY LOAD - WE ASSUME US TO BE ON DISK SIDE 0 WHEN WE GET HERE.
;
; ONE-SOUND SAVE/VERIFY ARE OF COURSE NOT IMPLEMENTED, NOR IS ONE-SOUND
; LOAD FROM A 2000 DISK - MAYBE SOMEDAY (MAYBE SUNDAY?).  ATTEMPTED
; ONE-SOUND LOAD FROM A 2000 DISK IS TRAPPED AT THE DISKMAIN LEVEL,
; WE DON'T CHECK FOR IT HERE - OTHER DISK_TYPE CHECKING IS DONE IN
; SOUNDS_MOVE BEFORE WE GET HERE - SO, BASICALLY, WE'RE COOL.
;
;
LOAD_ONE_SOUND
                                            ;FIRST THING IS TO SEE WHETHER SOURCE SOUND EXISTS, AND
                                            ;IF SO, FETCH ITS SOUND CONTROL BLOCK INTO WASTELAND:
;
               TST     DRIVE_SEL            ;ARE WE DEALING WITH FLOPPY OR SCSI?
               BMI.S   LD_1_FLOPPY_SOUND    ;BRANCH FOR FLOPPY -
               BSR     SCSI_SND_CTRL_MOVE   ;ELSE TRY TO READ SCSI SOUND CTRL BLOCK INTO WASTELAND,
               BRA     HOW_DID_IT_GO        ;BRANCH AHEAD TO TEST TRANSFER RETURN CODES AND GO ON.
;
;
;
LD_1_FLOPPY_SOUND
                                            ;BUFFER SOURCE SOUND CONTROL BLOCK FROM FLOPPY DISK:
;
               MOVE    #S_BLOCK_SIZE,BYTE_LENGTH      ;# OF BYTES TO READ FROM CTRL BLK RECORD.
               MOVE    SND_UNIT_SEL,D0      ;COMPUTE TRACK/SECTOR/SKIP COUNT FOR SOURCE CTRL BLOCK.
               EXT.L   D0
               DIVU    #5,D0                ;CONTROL BLOCKS ARE SAVED 5 PER SECTOR (EXCEPT 30-31).
               MOVE    D0,D1                ;COPY QUOTIENT - INDICATES SECTOR WE WANT.
               MOVE.B  LD_1_TRK_TBL(PC,D1),CURRENT_TRACK+1 ;FETCH TRACK NUMBER,
               MOVE.B  LD_1_SEC_TBL(PC,D1),CURRENT_SEC+1   ;FETCH SECTOR NUMBER.
               SWAP    D0                   ;REMAINDER INDICATES LOCATION OF BLOCK WITHIN SECTOR -
               TST     D0                   ;IF REMAINDER = 0, FIRST IN SECTOR - NO SKIP.
               BEQ.S   NO_CTRL_BLK_SKIP
               MULU    #S_BLOCK_SIZE,D0     ;ELSE, COMPUTE BYTE SKIP COUNT -
               MOVE    D0,TRUNC_BYTES       ;SAVE IT HERE IN CASE OF RETRY.
               ST      BEGIN_TRUNC          ;YES, WE GONNA SKIP-UM BYTES.
               BRA.S   ON_THE_WAY_IN
;
                                            ;WHERE TO FIND SOUND CONTROL BLOCKS:
LD_1_TRK_TBL
               DC.B    00H                  ;TRACK 00, SEC 3 FOR SOUNDS 0-4.
               DC.B    00H                  ;TRACK 00, SEC 4 FOR SOUNDS 5-9.
               DC.B    00H                  ;TRACK 00, SEC 0 FOR SOUNDS 10-14.
               DC.B    00H                  ;TRACK 00, SEC 1 FOR SOUNDS 15-19.
               DC.B    00H                  ;TRACK 00, SEC 2 FOR SOUNDS 20-24.
               DC.B    01H                  ;TRACK 01, SEC 4 FOR SOUNDS 25-29.
               DC.B    01H                  ;TRACK 01, SEC 0 FOR SOUNDS 30-31.
               EVEN                         ;NOTE - ASSEMBLER CAN'T SEEM TO GROK label(PC,Dx)
                                            ;WHERE label IS NOT ON A WORD BOUNDARY !?!?
LD_1_SEC_TBL
               DC.B    03H                  ;TRACK 00, SEC 3 FOR SOUNDS 0-4.
               DC.B    04H                  ;TRACK 00, SEC 4 FOR SOUNDS 5-9.
               DC.B    00H                  ;TRACK 00, SEC 0 FOR SOUNDS 10-14.
               DC.B    01H                  ;TRACK 00, SEC 1 FOR SOUNDS 15-19.
               DC.B    02H                  ;TRACK 00, SEC 2 FOR SOUNDS 20-24.
               DC.B    04H                  ;TRACK 01, SEC 4 FOR SOUNDS 25-29.
               DC.B    00H                  ;TRACK 01, SEC 0 FOR SOUNDS 30-31.
               EVEN
;
NO_CTRL_BLK_SKIP
               SF      BEGIN_TRUNC          ;NO, WE NO SKIP-UM NUTTIN.
ON_THE_WAY_IN
               MOVE    CURRENT_TRACK,D0     ;SO - WANNA GO TO THE TRACK.
               BSR     BLIND_SEEK           ;SEEK BLINDLY WITH THINE HEAD ....
               BSR     DLY_20_MSEC          ;ALLOW TIME FOR HEAD TO SETTLE ON TRACK.
               CLR     RETRIES              ;WE SHALL PASS THIS WAY BUT WUNTZ.
CLEAR_FOR_TAKEOFF
               MOVE    #WASTELAND,A0        ;BUFFER DEM CONTROL BLOCK HERE.
               TST.B   BEGIN_TRUNC          ;WE SKIPPIN?
               BNE.S   WAY_DOWN_FUNWAY      ;YAH -
               MOVE    BYTE_LENGTH,D2       ;NAH - D2 GETS TRANSFER COUNT.
               BRA.S   UP_IN_DE_AIYRE
WAY_DOWN_FUNWAY
               MOVE    TRUNC_BYTES,D2       ;SKIPPIN' - D2 = SKIP COUNT, BYTE_LENGTH = XFR COUNT.
UP_IN_DE_AIYRE
               MOVE    CURRENT_SEC,D0       ;UMM YEAH - NEED THIS TOO.
               BSR     SECTOR_READ          ;GOTTA READ SOUND CONTROL BLOCK NOW.
               BEQ.S   DOES_IT_EXIST        ;IF READ OK, GO CHECK STATUS OF SOUND.
               BSR     RETRY                ;IF ERROR, SEE ABOUT ANOTHER SHOT AT IT -
               BEQ     CLEAR_FOR_TAKEOFF    ;LOOP BACK IF WE GOT CLEERENTS,
               MOVEQ   #GENERIC_ERROR,D0    ;ELSE GIVE MR. USER A MEMO -
               BSR     QUERY
HOW_DID_IT_GO
               BNE     LD_1_SND_EXIT        ;EXIT IF ERROR (E.G. MR. USER RIPPED OUT DA DISK).
               BCS     LD_1_SND_EXIT        ;EXIT IF USER SAID "BYE."
               BSR     DISP_XFR_SCREEN      ;CONTINUING, SO RESTORE TRANSFER SCREEN.
;
;
;
DOES_IT_EXIST
                                            ;SOURCE SOUND CONTROL HAS BEEN BUFFERED INTO WASTELAND,
                                            ;LET'S SEE IF SOURCE SOUND EVEN EXISTS:
;
               MOVE    #WASTELAND,A0        ;POINT AT BUFFERED SOUND CONTROL BLOCK -
               BTST    #NOT_DEL_BIT,S_STATUS(A0) ;IS SOURCE SOUND DELETED ON DISK?
               BNE.S   SOURCE_EXISTS        ;BRANCH IF NOT, CONTINUE.
               MOVEQ   #SOURCE_DELETED,D0   ;ELSE, NOTIFY MONSIEUR USERE THAT HIS SOUND IS, GONE.
               BRA     LD_1_SND_EXIT
;
;
;
SOURCE_EXISTS
                                            ;SOURCE SOUND EXISTS - DETERMINE WHETHER WE CAN FIT IT
                                            ;INTO AVAILABLE SAMPLE MEMORY SPACE (INCLUDING SPACE
                                            ;TAKEN UP BY TARGET SAMPLE IF IT EXISTS):
;
;890314               MOVE    FREE_SAM_RAM,D1      ;COMPUTE EXISTING FREE RAM SPACE (WORDS).
;890314               MULU    #1024,D1
;890314                ABS_LONG
;890314               JSR     GET_PROP_BLK_PTR     ;SET A0 AS POINTER TO CURRENT_SOUND CONTROL BLOCK -
;890314                ABS_SHORT
;890314               BTST    #NOT_DEL_BIT,S_STATUS(A0) ;IS IT DELETED?
;890314               BEQ.S   KNOW_AVAILABLE_SPACE      ;BRANCH IF YES, CONTINUE -
;890314               ADD.L   S_FINISH(A0),D1           ;ELSE, ADD IN SPACE USED BY TARGET SAMPLE.
;890314               SUB.L   S_BEGIN(A0),D1
;890314               ADDQ.L  #1,D1
;890314;
;890314KNOW_AVAILABLE_SPACE
;
               JSR     POSTDEL_SAMSPC       ; total space after delete in D1.L.
;
                                            ;D1 NOW CONTAINS TOTAL AVAILABLE SPACE IN WORDS -
               MOVE    #WASTELAND,A0        ;POINTER TO BUFFERED SOURCE SOUND CONTROL BLOCK.
               MOVE.L  S_FINISH(A0),D0      ;COMPUTE SOURCE SOUND SIZE.
               SUB.L   S_BEGIN(A0),D0
               ADDQ.L  #1,D0
               MOVE.L  D0,DSK_FIL_LENGTH    ;NUMBER OF SAMPLE WORDS TO LOAD - IF WE GO FOR IT.
               CMP.L   D0,D1                ;WILL SOURCE SOUND FIT INTO AVAILABLE RAM?
               BCC.S   ENOUGH_SPACE         ;BRANCH IF YES,
               MOVEQ   #NO_ROOM,D0          ;ELSE WE MUST CEASE AND DE-CYST.
               BRA     LD_1_SND_EXIT
;
;
;
;
ENOUGH_SPACE
                                            ;WE HAVE ENOUGH SPACE TO FIT SOURCE SAMPLE INTO RAM -
                                            ;DO WE NEED TO GET RID OF TARGET SOUND FIRST?
                ABS_LONG
               JSR     GET_PROP_BLK_PTR     ;SET A0 AS POINTER TO CURRENT_SOUND CONTROL BLOCK -
                ABS_SHORT
               BTST    #NOT_DEL_BIT,S_STATUS(A0) ;IS IT DELETED?
               BEQ.S   TARGET_IS_EMPTY           ;BRANCH IF YES, CONTINUE.
               MOVEQ   #TARGET_EXISTS,D0         ;IF NOT, WE GO NO FURTHER WITHOUT USER'S OK -
               BSR     QUERY
               BNE     LD_1_SND_EXIT        ;BAIL OUT IF DRIVE STATUS ERROR (E.G. DISK REMOVED).
               BCS     LD_1_SND_EXIT        ;TAKE A HIKE IF USER SAID "TAKE A HIKE."
;
               LEA     DEL_TARG_SCRN(PC),A1 ;USER SAID OK, SO ACKNOWLEDGE THE GO-AHEAD.
               .ALONG
               JSR     DISP_SCREEN
               .AWORD
               JSR     GET_PROP_BLK_PTR     ;RE-FETCH SOUND CONTROL BLOCK POINTER,
               .ALONG
               JSR     DELETE_SHUFFLE       ;REMOVE TARGET SOUND FROM THE PICTURE.
               .AWORD
;
;890315               MOVE    #2700H,SR            ;PUT INTERRUPTS BACK THE WAY THEY WERE - ALL BLOCKED.
;                                           .... don't need this anymore ....
;
               LEA     8(A7),A7             ;NOW FOR THE DARING PART - TOSS RETURN ADDRESSES,
               BRA     DISKWARD_HO          ;RE-ENTER FROM THE TOP - ACTUALLY THIS IS INSURANCE
                                            ;AGAINST SINISTER DISK-SWAPPERS AND THE LIKE ....
                                            ;ALL WE REALLY ACCOMPLISHED WAS TARGET SOUND DELETION,
                                            ;WHICH WE WON'T NEED TO DO NEXT TIME WE COME THROUGH.
;
;
;
TARGET_IS_EMPTY
                                            ;NO SOUND CURRENTLY EXISTS IN OUR TARGET SOUND SLOT -
                                            ;IT'S TIME TO STOP WAFFLING AND START LOADING!
;
               MOVE    SAMPLE_RAM_END,D1    ;NEW SOUND WILL LOAD AT START OF FREE RAM AREA -
               SUB     FREE_SAM_RAM,D1      ;COMPUTE THIS ADDRESS.
               MULU    #1024,D1
               MOVE.L  D1,CUR_XFR_ADDR      ;SET INITIAL SAMPLE DATA TRANSFER ADDRESS.
               MOVE    #WASTELAND,A0        ;SET POINTER TO BUFFERED SOURCE SOUND CONTROL BLOCK -
               MOVE.L  S_BEGIN(A0),D0       ;THIS IS WHERE SOURCE SOUND STARTS IN THE DISK FILE.
               MOVE.L  D0,DSK_FIL_ADDR      ;LET'S MAKE A NOTE OF THAT, SHALL WE?
;
               SUB.L   D0,D1                ;COMPUTE DISK-TO-RAM TRANSFER OFFSET,
               ADD.L   D1,S_BEGIN(A0)       ;ADJUST ALL POINTERS IN BUFFERED SOUND CONTROL BLOCK
               ADD.L   D1,S_FINISH(A0)      ;TO BE CORRECT FOR WHERE THE SAMPLE WILL ACTUALLY LOAD.
               ADD     #S_SUB_0,A0
               ADD.L   D1,S_START(A0)       ;SUB-BLOCK 0 POINTERS.
               ADD.L   D1,S_LOOP_START(A0)
               ADD.L   D1,S_LOOP_END(A0)
               ADD.L   D1,S_END(A0)
               ADD     #S_SUB_SIZE,A0       ;SUB_BLOCK 1 POINTERS.
               ADD.L   D1,S_START(A0)
               ADD.L   D1,S_LOOP_START(A0)
               ADD.L   D1,S_LOOP_END(A0)
               ADD.L   D1,S_END(A0)
;
               TST     DRIVE_SEL            ;AND AGAIN - WHICH DRIVE WAS THAT?
               BMI.S   SUBFILE_LOOP         ;BRANCH IF IT WAS LE FLOPPE -
               BSR     SCSI_SAMPLE_MOVE     ;ELSE DO SCSI SAMPLE DATA TRANSFER.
               BEQ     COPY_CTRL_BLK        ;TAKE THIS BRANCH IF IT WENT OKAY,
               BRA     LD_1_SND_EXIT        ;TAKE THIS ONE IF IT DIDN'T.
;
;
;
SUBFILE_LOOP
                                            ;PASS THROUGH HERE 1-4 TIMES, DEPENDING UPON THE
                                            ;NUMBER OF SUBFILES SPANNED BY THE SAMPLE BEING LOADED.
;
               TST.L   DSK_FIL_LENGTH       ;GOES TO ZERO WHEN WE'RE DONE - ARE WE DONE?
               BEQ     COPY_CTRL_BLK        ;BRANCH IF YES - PLUG BUFFERED CONTROL BLOCK IN, EXIT.
;
               MOVE.L  DSK_FIL_ADDR,D0      ;NOT DONE - FETCH CURRENT DISK FILE TRANSFER ADDRESS.
               CMP.L   #40000H,D0           ;WHICH SIDE OF DISK IS IT ON?
               BLT.S   SIDE_U_WANT          ;BRANCH IF SIDE 0 - WE SHOULD STILL BE ON SIDE 0 THEN.
               SUB.L   #40000H,D0           ;MAKE DISK FILE POINTER SIDE-RELATIVE.
               TST     CURRENT_SIDE         ;ARE WE ALREADY ON SIDE 1 (FROM PREVIOUS SUBFILE)?
               BNE.S   SIDE_U_WANT          ;BRANCH IF YES, SKIP THIS CRAP.
               MOVE.L  D0,-(A7)             ;NO - SAVE RELATIVE FILE PTR, GET THEE TO SIDE 1.
               BSR     SEL_SIDE_1
               BSR     LOOK_FOR_ADDR        ;MAKE SURE IT LOOKS LIKE SIDE 1.
               BEQ.S   GOT_SIDE_1_NOW       ;SURE IT DOES.
               LEA     4(A7),A7             ;NO IT DON'T - DUMP FILE PTR, EXIT W/ ERR CODE IN D0.
               BRA     LD_1_SND_EXIT
GOT_SIDE_1_NOW
               MOVE.L  (A7)+,D0             ;RETRIEVE SIDE-RELATIVE FILE POINTER, CONTINUE.
;
SIDE_U_WANT
               CMP.L   #20000H,D0           ;WHICH SUBFILE ON CURRENT SIDE OF DISK?
               BGE.S   INNER_SUBFILE        ;THE UPPER/HIGHER/LATER/INNER ONE, HOW SHALL I SAY?
               MOVE    #SUBFILE_0_TRK,CURRENT_TRACK   ;ELSE SET TRACK NUMBER FOR LOWER/OUTER ONE -
               TST     CURRENT_SIDE         ;FINE, AS LONG AS WE'RE ON SIDE 0 -
               BEQ.S   SUBFILE_U_WANT       ;BRANCH IF WE ARE.
               CMP     #REV_0,CUR_FIRMWR_REV     ;IF SIDE 1, STILL FINE IF DISK IS REV-0 -
               BEQ.S   SUBFILE_U_WANT            ;BRANCH IF THAT BE THE CASE,
               MOVE    #SUBFILE_2_TRK,CURRENT_TRACK   ;ELSE SET TRACK NUMBER FOR REV-1 DISK.
               BRA.S   SUBFILE_U_WANT
INNER_SUBFILE
               SUB.L   #20000H,D0           ;MAKE DISK FILE POINTER SUBFILE-RELATIVE.
               MOVE    #SUBFILE_1_TRK,CURRENT_TRACK   ;SET INNER SUBFILE STARTING TRACK NUMBER.
               TST     CURRENT_SIDE         ;FINE, AS LONG AS WE'RE ON SIDE 0 -
               BEQ.S   SUBFILE_U_WANT       ;BRANCH IF WE ARE.
               CMP     #REV_0,CUR_FIRMWR_REV     ;IF SIDE 1, STILL FINE IF DISK IS REV-0 -
               BEQ.S   SUBFILE_U_WANT            ;BRANCH IF THAT BE THE CASE,
               MOVE    #SUBFILE_3_TRK,CURRENT_TRACK   ;ELSE SET TRACK NUMBER FOR REV-1 DISK.
;
SUBFILE_U_WANT
               MOVE.L  D0,D1                ;COPY DISK FILE POINTER FOR START-RECORD COMPUTATIONS.
               DIVU    #SAM_REC_WORDS,D1    ;DIVIDE BY # OF WORDS IN NOMINAL SAMPLE DATA RECORD.
               MOVE    D1,CURRENT_REC       ;QUOTIENT = # OF RECORD THAT FILE PTR IS POINTING INTO.
               SWAP    D1                   ;REMAINDER = WORD OFFSET OF FILE PTR INTO THIS RECORD.
               TST     D1                   ;WAS THERE A REMAINDER?
               BNE.S   SKIP_SOME_WORDS      ;BRANCH IF YES, SORT IT OUT.
               SF      BEGIN_TRUNC          ;NO - TURN OFF SKIP FLAG,
               MOVE.L  #SAM_REC_WORDS,BEG_REC_WORDS   ;SET WORD TRANSFER COUNT FOR FIRST RECORD
                                                      ;TO FULL-RECORD LENGTH
                                                      ;(FOR CORRECT END-RECORD ACCOUNTING).
               BRA.S   OTHER_END_NOW        ;GO DO THE END-RECORD ACCOUNTING.
SKIP_SOME_WORDS
               ST      BEGIN_TRUNC          ;WE GONNA SKIP SOME.
               MOVE.L  #SAM_REC_WORDS,D2    ;NOMINAL WORDS-PER-RECORD -
               EXT.L   D1                   ;WATCH FOR TRASH IN WORD SKIP COUNT ....
               SUB.L   D1,D2                ;NUMBER OF WORDS WE'LL READ FROM FISRT RECORD.
               MOVE.L  D2,BEG_REC_WORDS
               MULU    #3,D2                ;MULTIPLY BY 1.5 FOR BYTE TRANSFER COUNT, FIRST RECORD.
               LSR     #1,D2
               MOVE    D2,BEG_REC_BYTES     ;STORE FIRST RECORD BYTE TRANSFER COUNT.
               MULU    #3,D1                ;MULTIPLY WORD SKIP COUNT BY 1.5 FOR BYTE SKIP COUNT.
               LSR     #1,D1
               MOVE    D1,TRUNC_BYTES       ;STORE FIRST RECORD BYTE SKIP COUNT.
;
OTHER_END_NOW
               MOVE.L  #20000H,D1           ;FULL SUBFILE WORD COUNT -
               SUB.L   D0,D1                ;WORD COUNT FROM FILE POINTER THRU SUBFILE END -
               CMP.L   DSK_FIL_LENGTH,D1    ;DOES OUR SOUND END IN THIS SUBFILE?
               BLT.S   NOT_LAST_SUBFILE     ;BRANCH IF NOT - SET UP TO TRANSFER THRU SUBFILE END.
               MOVE.L  DSK_FIL_LENGTH,D1    ;YES - THIS IS TRANSFER LENGTH WE WNAT TO WORK WITH.
               CLR.L   DSK_FIL_LENGTH       ;THIS GETS US OUT OF SUBFILE_LOOP NEXT TIME THRU.
               SUB.L   BEG_REC_WORDS,D1     ;SHAVE OFF FIRST RECORD WORD TRANSFER COUNT.
               DIVU    #SAM_REC_WORDS,D1    ;QUOTIENT = # OF FULL RECORDS FROM SECOND THRU LAST -
               MOVE    CURRENT_REC,FINAL_REC     ;USE IT TO SET (PRELIMINARY) FINAL RECORD NUMBER -
               ADD     D1,FINAL_REC         ;OFFSET IT FROM BEGINNING RECORD NUMBER.
               SWAP    D1                   ;REMAINDER = WORD XFR COUNT FROM PARTIAL LAST RECORD -
               TST     D1                   ;IS THERE ANY?
               BNE.S   GOT_LEFTOVERS        ;BRANCH IF YES, GO SET FINAL RECORD TRANSFER LENGTH.
               MOVE.L  #SAM_REC_WORDS,FIN_REC_WORDS   ;IF NO, TRANSFER FULL RECORD LENGTH FROM IT.
               MOVE    #SAM_REC_BYTES,FIN_REC_BYTES   ;AND, LEAVE FINAL_REC WHERE IT IS -
               BRA.S   SET_PHYSICAL_PTRS              ;NO PARTIAL FINAL RECORD TO BUMP IT UP FOR.
GOT_LEFTOVERS
               EXT.L   D1                   ;WORD COUNT FROM FINAL (PARTIALLY-READ) RECORD -
               MOVE.L  D1,FIN_REC_WORDS
               MULU    #3,D1                ;COMPUTE AND STORE BYTE TRANSFER COUNT FOR SAME.
               LSR     #1,D1
               MOVE    D1,FIN_REC_BYTES
               ADDQ    #1,FINAL_REC         ;FINAL RECORD IS ONE HIGHER THAN WE SET EARLIER.
               BRA.S   SET_PHYSICAL_PTRS    ;GO INITIALIZE PHYSICAL RECORD POINTERS AND LOADITUP.
;
NOT_LAST_SUBFILE
               MOVE    #END_RECORD,FINAL_REC     ;SET UP TO READ THROUGH END OF THIS SUBFILE -
               MOVE.L  #END_REC_WORDS,FIN_REC_WORDS   ;SUBFILE END RECORD IS SMALLER THAN OTHERS,
               MOVE    #END_REC_BYTES,FIN_REC_BYTES   ;HENCE HAS ITS OWN SPECIAL TRANSFER LENGTHS.
               SUB.L   D1,DSK_FIL_LENGTH    ;ADJUST FILE POINTER AND (REMAINING) FILE TRANSFER
               ADD.L   D1,DSK_FIL_ADDR      ;FOR SITUATION WHICH WILL OBTAIN AFTER THIS SUBFILE
                                            ;HAS BEEN TRANSFERRED.
;
SET_PHYSICAL_PTRS
               MOVE    CURRENT_REC,D1       ;COPY BEGIN RECORD LOGICAL RECORD NUMBER.
               CLR     CURRENT_REC          ;ZERO ALL RECORD POINTERS,
               CLR     CURRENT_SEC          ;THEN WALK THRU ADVANCE_REC (D1) TIMES -
               CLR     SECTOR_OFFSET        ;THIS WILL RESTORE CURRENT_REC TO WHERE IT WAS,
                                            ;WHILE SETTING OTHER PHYSICAL POINTERS (INCLUDING
                                            ;CURRENT_TRACK) TO THE VALUES WHICH CORRESPOND.
               BRA.S   SET_PHYS_ELOPE       ;IF CURRENT_REC = 0, THEN EVERYTHING'S ALREADY SET -
                                            ;SO, JUMP IN AT BOTTOM OF LOOP.
SET_PHYS_LOOP
               BSR     ADVANCE_REC
SET_PHYS_ELOPE
               DBRA    D1,SET_PHYS_LOOP
;
TELL_THE_CHIP
               BSR     SET_RAM_INTFC        ;TELL SAMPLE RAM INTERFACE WHERE TO GO.
               BSR     SAMPLE_MOVE          ;GOOD LUCK!
               BNE.S   LD_1_SND_EXIT        ;EXIT IF FATAL ERROR OCCURRED.
               BCS.S   LD_1_SND_EXIT        ;EXIT IF USER ABORTED TRANSFER AFTER ERROR.
               BRA     SUBFILE_LOOP         ;SO FAH SO GOOT - CONTINUE WITH NEXT SUBFILE IF ANY.
;
;
;
COPY_CTRL_BLK
                                            ;ALL SAMPLE DATA HAS BEEN LOADED - TIME TO INSTALL THE
                                            ;BUFFERED SOUND CONTROL BLOCK IN ITS RIGHTFUL HOME:
                ABS_LONG
               JSR     GET_PROP_BLK_PTR     ;SET POINTER TO TARGET SOUND CONTROL BLOCK AREA.
                ABS_SHORT
               MOVE    #WASTELAND,A1        ;SET POINTER TO BUFFERED SOURCE SOUND CONTROL BLOCK.
               MOVE    #S_BLOCK_SIZE-1,D0   ;SET BYTE TRANSFER COUNT.
COPY_CTRL_LOOP
               MOVE.B  (A1)+,(A0)+
               DBRA    D0,COPY_CTRL_LOOP
               CLR     D0                   ;WHEN DONE, RETURN WITH NO-ERROR STATUS.
;
;
;
LD_1_SND_EXIT
               RTS
;
;
;
DEL_TARG_SCRN
               ASC     "Target sound is "
               ASC     "being deleted..."
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; TRANSFER SYSTEM CONFIGURATION BLOCKS -
; BY NOW, WE'VE ALREADY PASSED DISK REVISION-LEVEL TEST, IF ANY.
;
SYSTEM_MOVE
               MOVE    CUR_FILE_TYPE,D1     ;IS THERE A SOUNDS FILE HERE?
               BEQ.S   SYS_MOV_10           ;BRANCH IF YES, THIS IS OKAY.
               CMP     #1,D1                ;NO?  WELL, HOW ABOUT A SEQUENCES FILE?
               BEQ.S   SYS_MOV_10           ;THERE IS?  GREAT, GREAT.
               MOVEQ   #NOT_ALLOWED,D0      ;IF NEITHER, NO CAN DO - 'BYE.
               BRA.S   SYS_MOV_EXIT
SYS_MOV_10
               TST     DRIVE_SEL            ;ARE WE OPERATING ON FLOPPY OR SCSI DISK?
               BPL     SCSI_CONFIG_MOVE     ;BRANCH FOR SCSI - SEPARATE PROCEDURE FROM THIS POINT.
;
                                            ;FLOPPY, THEN:
               BSR     MOVE_MIDI_BLOCK      ;TRANSFER MIDI SYS CONFIG BLOCK.
               BNE.S   SYS_MOV_EXIT         ;EXIT IF FATAL ERROR.
               BCS.S   SYS_MOV_EXIT         ;EXIT IF USER ABORT ON ERROR.
;
               BSR     MOVE_SEQ_SYS_BLOCK   ;TRANSFER SEQUENCER SYS CONFIG BLOCK.
               BNE.S   SYS_MOV_EXIT         ;EXIT IF FATAL ERROR.
               BCS.S   SYS_MOV_EXIT         ;EXIT IF USER ABORT ON ERROR.
;
               BSR     MOVE_SMPTE_BLOCK     ;TRANSFER SMPTE SYS CONFIG BLOCK.
                                            ;PASS RETURN STATUS THROUGH.
;
SYS_MOV_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; TRANSFER SOUND CONTROLS ONLY -
;
CONTROLS_MOVE
               MOVE    CUR_FILE_TYPE,D1     ;MAKE SURE WE GOT A SOUNDS FILE HERE -
               BEQ.S   CTL_MOV_20           ;BRANCH IF WE DO, GO 'HAID.
               CMP     #0FFFFH,D1           ;IS IT ANY KIND OF FILE YET?
               BNE.S   CTL_MOV_10           ;BRANCH IF YES - IT'S JUST NOT THE KIND WE WANT.
               MOVEQ   #NOT_ALLOWED,D0      ;ELSE, SAY IT STRAIGHT - NO MAIN FILE HERE, CAN'T.
               BRA.S   CTL_MOV_EXIT
CTL_MOV_10
               MOVEQ   #DATA_NOT_PRES,D0    ;NOT OUR KIND OF FILE.
               BRA.S   CTL_MOV_EXIT
CTL_MOV_20
               TST     DRIVE_SEL            ;ARE WE OPERATING ON FLOPPY OR SCSI DISK?
               BPL     SCSI_SND_CTRL_MOVE   ;BRANCH FOR SCSI - SEPARATE PROCEDURE FROM THIS POINT.
;
                                            ;FLOPPY, THEN:
               BSR     SOUND_PARAMS_MOVE    ;DO IT, PASS RETURN STATUS THROUGH.
;
CTL_MOV_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; TRANSFER PAD KIT/BANK ARRAYS ONLY -
;
KITS_MOVE
               MOVE    CUR_FILE_TYPE,D1     ;MAKE SURE WE GOT A SOUNDS FILE HERE -
               BEQ.S   KIT_MOV_20           ;BRANCH IF WE DO, GO 'HAID.
               CMP     #0FFFFH,D1           ;IS IT ANY KIND OF FILE YET?
               BNE.S   KIT_MOV_10           ;BRANCH IF YES - IT'S JUST NOT THE KIND WE WANT.
               MOVEQ   #NOT_ALLOWED,D0      ;ELSE, SAY IT STRAIGHT - NO MAIN FILE HERE, CAN'T.
               BRA.S   KIT_MOV_EXIT
KIT_MOV_10
               MOVEQ   #DATA_NOT_PRES,D0    ;NOT OUR KIND OF FILE.
               BRA.S   KIT_MOV_EXIT
KIT_MOV_20
               TST     DRIVE_SEL            ;ARE WE OPERATING ON FLOPPY OR SCSI DISK?
               BPL     SCSI_KITS_MOVE       ;BRANCH FOR SCSI - SEPARATE PROCEDURE FROM THIS POINT.
;
                                            ;FLOPPY, THEN:
               BSR     MOVE_PAD_PARAMS      ;DO IT, PASS RETURN STATUS THROUGH.
;
KIT_MOV_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; TRANSFER SMPTE CUE LIST FILE ONLY -
;
CUELIST_MOVE
               MOVE    CUR_FILE_TYPE,D1     ;IS THERE A SOUNDS FILE HERE?
               BEQ.S   CUE_MOV_10           ;BRANCH IF YES, THIS IS OKAY.
               CMP     #1,D1                ;NO?  WELL, HOW ABOUT A SEQUENCES FILE?
               BEQ.S   CUE_MOV_10           ;THERE IS?  GREAT, GREAT.
               MOVEQ   #NOT_ALLOWED,D0      ;IF NEITHER, NO CAN DO - 'BYE.
               BRA.S   CUE_MOV_EXIT
;
CUE_MOV_10
               MOVE    DISK_OP_CODE,D1      ;ARE WE SAVING?
               BTST    #SAVE_BIT,D1
               BEQ.S   CUE_MOV_40           ;BRANCH IF NOT, PROCEED APACE.
               CMP     #NON_DELETED,CUR_QFILE_STAT    ;SAVING - OVERWRITING AN EXISTING CUE FILE?
               BNE.S   CUE_MOV_20                     ;BRANCH IF NOT, JUST DO IT.
               MOVEQ   #FILE_NOT_EMPTY,D0   ;ELSE, GIVE HIM ONE CHANCE TO CHANGE HIS MIND ....
               BSR     QUERY                ;SHOULD I STAY OR SHOULD I GO?
               BNE.S   CUE_MOV_EXIT         ;BRANCH IF ERROR (E.G., USER PULLED DISK OUT).
               BCS.S   CUE_MOV_EXIT         ;BRANCH IF USER SAID "QUIT."
               BSR     DISP_XFR_SCREEN      ;REDISPLAY TRANSFER SCREEN AND CONTINUE.
               BRA.S   CUE_MOV_50
CUE_MOV_20
               MOVE    #NON_DELETED,CUR_QFILE_STAT    ;WRITING INTO EMPTY FILE, UPDATE STATUS FLAG.
               BSR     WRITE_DESCRIPTOR               ;PUT IT ONTO DISK (NOTE: WON'T CHANGE DISK OR
                                                      ;BANK NAME).
               BNE.S   CUE_MOV_EXIT                   ;EXIT IF DRIVE STATUS ERROR.
               BCS.S   CUE_MOV_EXIT                   ;EXIT IF USER ABORT.
               BRA.S   CUE_MOV_50
;
CUE_MOV_40
               CMP     #NON_DELETED,CUR_QFILE_STAT    ;LOAD/VERIFY - HAS CUE FILE BEEN SAVED TO?
               BEQ.S   CUE_MOV_50                     ;BRANCH IF YES,
               MOVEQ   #DATA_NOT_PRES,D0              ;ELSE EXIT WITH "FILE EMPTY" ERROR MESSAGE.
               BRA.S   CUE_MOV_EXIT
;
CUE_MOV_50
               TST     DRIVE_SEL            ;ARE WE OPERATING ON FLOPPY OR SCSI DISK?
               BPL     SCSI_CUELIST_MOVE    ;BRANCH FOR SCSI - SEPARATE PROCEDURE FROM THIS POINT.
;
                                            ;FLOPPY, THEN:
               BSR     SEL_SIDE_0           ;DO SIDE 0 FIRST,
               BSR     MOVE_CUE_LIST        ;TRANSFER FILE.
               BNE     SYS_MOV_EXIT         ;EXIT IF FATAL ERROR.
               BCS     SYS_MOV_EXIT         ;EXIT IF USER ABORT ON ERROR.
               MOVE    DISK_OP_CODE,D1      ;ARE WE DOING A LOAD?
               BTST    #LOAD_BIT,D1
               BEQ.S   CUE_MOV_60           ;BRANCH IF NOT, DO SIDE 1 REDUNDANT SAVE OR VERIFY.
               TST     (A6)                 ;LOADING - WERE ANY SIDE 0 RECORDS UNLOADABLE?
               BEQ.S   CUE_MOV_EXIT         ;BRANCH IF NONE UNLOADABLE, EXIT WITH NO-ERROR STATUS.
               BSR     RCVR_CUE_LIST        ;ELSE ATTEMPT TO LOAD THESE RECORDS FROM SIDE 1 FILE,
               BRA.S   CUE_MOV_EXIT         ;PASS RETURN STATUS THROUGH.
CUE_MOV_60
               BSR     SEL_SIDE_1           ;SAVE OR VERIFY - SELECT SIDE 1,
               BSR     MOVE_CUE_LIST        ;REPLICATE THE TRANSFER, PASS RETURN STATUS THROUGH.
;
CUE_MOV_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; TRANSFER SEQUENCER SONG LIST ONLY -
;
SONGS_MOVE
               MOVE    CUR_FILE_TYPE,D1     ;MAKE SURE WE GOT A SEQUENCES FILE HERE -
               CMP     #1,D1                ;THIS IS _TYPE VALUE FOR SEQUENCES FILE.
               BEQ.S   SONGMOV_20           ;BRANCH IF WE DO, GO 'HAID.
               CMP     #0FFFFH,D1           ;IS IT ANY KIND OF FILE YET?
               BNE.S   SONGMOV_10           ;BRANCH IF YES - IT'S JUST NOT THE KIND WE WANT.
               MOVEQ   #NOT_ALLOWED,D0      ;ELSE, SAY IT STRAIGHT - NO MAIN FILE HERE, CAN'T.
               BRA.S   SONGMOV_EXIT
SONGMOV_10
               MOVEQ   #DATA_NOT_PRES,D0    ;NOT OUR KIND OF FILE.
               BRA.S   SONGMOV_EXIT
;
SONGMOV_20
               MOVE    DISK_OP_CODE,D1      ;ARE WE SAVING?
               BTST    #SAVE_BIT,D1
               BEQ.S   SONGMOV_40           ;BRANCH IF NOT, PROCEED APACE.
               MOVEQ   #FILE_NOT_EMPTY,D0   ;ELSE, GIVE HIM ONE CHANCE TO CHANGE HIS MIND ....
               BSR     QUERY                ;SHOULD I STAY OR SHOULD I GO?
               BNE.S   SONGMOV_EXIT         ;BRANCH IF ERROR (E.G., USER PULLED DISK OUT).
               BCS.S   SONGMOV_EXIT         ;BRANCH IF USER SAID "QUIT."
               BSR     DISP_XFR_SCREEN      ;REDISPLAY TRANSFER SCREEN AND CONTINUE.
;
SONGMOV_40
               TST     DRIVE_SEL            ;ARE WE OPERATING ON FLOPPY OR SCSI DISK?
               BPL     SCSI_SONGLIST_MOVE   ;BRANCH FOR SCSI - SEPARATE PROCEDURE FROM THIS POINT.
;
                                            ;FLOPPY, THEN:
               BSR     SEL_SIDE_0           ;DO SIDE 0 FIRST,
               BSR     MOVE_SONG_LIST       ;TRANSFER FILE.
               BNE.S   SONGMOV_EXIT         ;EXIT IF FATAL ERROR.
               BCS.S   SONGMOV_EXIT         ;EXIT IF USER ABORT ON ERROR.
               MOVE    DISK_OP_CODE,D1      ;ARE WE DOING A READ?
               BTST    #LOAD_BIT,D1
               BNE.S   SONGMOV_50           ;BRANCH IF LOADING.
               BTST    #DIR_BIT,D1          ;NOT LOADING - HOWABOUT DIRECTORY EXTRACTION?
               BEQ.S   SONGMOV_60           ;BRANCH IF NOT, DO SIDE 1 REDUNDANT SAVE OR VERIFY.
SONGMOV_50
               TST     (A6)                 ;READING - WERE ANY SIDE 0 RECORDS UNLOADABLE?
               BEQ.S   SONGMOV_EXIT         ;BRANCH IF NONE UNLOADABLE, EXIT WITH NO-ERROR STATUS.
               BSR     RCVR_SONG_LIST       ;ELSE ATTEMPT TO LOAD THESE RECORDS FROM SIDE 1 FILE,
               BRA.S   SONGMOV_EXIT         ;PASS RETURN STATUS THROUGH.
SONGMOV_60
               BSR     SEL_SIDE_1           ;SELECT SIDE 1,
               BSR     MOVE_SONG_LIST       ;REPLICATE THE SAVE, PASS RETURN STATUS THROUGH.
;
SONGMOV_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; SEQUENCES TRANSFER ROUTINE -
; COME HERE FOR ALL-SEQS TRANSFER, ONE-SEQUENCE LOAD, SEQ DIRECTORY.
; ALL-SEQS TRANSFER MAY ALSO MOVE SONGS OR SONGS/SYS-CONFIG AS WELL -
; WHEN SAVING TO DISK, WILL AUTOMATICALLY SAVE ANY OF THE ABOVE WHICH DO
; NOT ALREADY EXIST ON DISK, EVEN IF NOT ALL ARE REQUESTED BY USER, SO
; THAT ANY DISK/BANK WITH TYPE = SEQS IS GUARANTEED TO HAVE ALL THREE.
; NOTE:  ALL-SEQUENCES TRANSFER MOVES SEQ DIRECTORY AND BLOCK LIST AS
; WELL AS THE ACTUAL SEQUENCE DATA (REGARDLESS OF SONGS/SYS-CONFIG).
; D0 CONTAINS DISK_OP_CODE UPON ENTRY.
;
SEQUENCES_MOVE
               MOVE    CUR_FILE_TYPE,D1     ;HAVE A LOOK AT MAIN FILE TYPE -
               BTST    #SAVE_BIT,D0         ;IF SAVING, WE WANT SEQ FILE OR UNCOMMITTED FILE -
               BNE.S   SEQ_MOV_10           ;BRANCH IF SAVING.
;
               CMP     #1,D1                ;LOAD/VERIFY REQUIRE SEQUENCES FILE.
               BEQ.S   SEQ_MOV_40           ;BRANCH IF THIS WE HAVE GOT,
               MOVEQ   #DATA_NOT_PRES,D0    ;ELSE RETURN ERROR CODE.
               BRA     SEQ_MOV_EXIT
;
SEQ_MOV_10
                                            ;SAVING TO DISK:
               CMP     #1,D1                ;TYPE = 1 FOR SEQUENCES DISK/BANK - ALL SAVES ALLOWED.
               BEQ.S   SEQ_MOV_20           ;BRANCH IF WE GOT ONE, WE GONNA DO IT - WARN THE USER.
               OR      #SONG_MASK,DISK_OP_CODE   ;ELSE, MUST SAVE A SONG FILE WHEN WE CONVERT THIS
                                                 ;DISK TO A SEQUENCES DISK.
               TST     D1                   ;TYPE = 0 FOR SOUNDS DISK/BANK - IT ALREADY HAS SYSTEM
               BEQ.S   SEQ_MOV_12           ;CONFIG FILE.  BRANCH IF WE GOT ONE, WARN USER.
               OR      #SYSTEM_MASK,DISK_OP_CODE ;ELSE, MUST SAVE A SYS CONFIG FILE ALSO, IN ORDER
                                                 ;TO CONFORM TO CONVENTIONS FOR SEQS DISK/BANK.
               CMP     #0FFFFH,D1           ;IF = 0FFFFH, EMPTY (NO TYPE) - SAVE WITHOUT WARNINGS.
               BEQ.S   SEQ_MOV_30           ;BRANCH IF UNCOMMITTED DISK - UPDATE DESCRIPTOR.
               MOVEQ   #OTH_FILE_HERE,D0    ;WARN USER ABOUT EXISTENCE OF SOME OTHER TYPE OF FILE.
               BRA.S   SEQ_MOV_24
SEQ_MOV_12
               MOVEQ   #SND_FILE_HERE,D0    ;ELSE, WARN USER ABOUT SOUND FILE.
               BRA.S   SEQ_MOV_24
SEQ_MOV_20
               MOVEQ   #FILE_NOT_EMPTY,D0   ;GIVE HIM A CHANCE TO RECONSIDER ....
SEQ_MOV_24
               BSR     QUERY
               BNE     SEQ_MOV_EXIT         ;EXIT IF DRIVE STATUS ERROR.
               BCS     SEQ_MOV_EXIT         ;EXIT IF HE HAD SECOND THOUGHTS, DOUBTS, UNCERTAINTIES.
               BSR     DISP_XFR_SCREEN
SEQ_MOV_30
                                            ;UPDATE DESCRIPTOR RECORD -  IF FILE TYPE WAS
               MOVE    #1,CUR_FILE_TYPE     ;UNCOMMITTED BEFORE, BY GUM IT'S COMMITTED NOW.
               MOVE    #REV_1,CUR_FIRMWR_REV    ;UP-REV REV-0 FILES TO REV 1 - ANYTHING OTHER THAN
                                                ;REV-0 AND REV-1 SHOULDA BEEN TRAPPED BY DISKMAIN.
               BSR     WRITE_DESCRIPTOR     ;TRY, TRY TO PUT IT OUT THERE (NOTE: THIS WILL ALSO PUT
                                            ;RESIDENT SEQ BANK NAME INTO DISK/BANK DESCRIPTOR).
               BNE     SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS     SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
               BRA.S   SEQ_MOV_4F           ;CAN'T SAVE DIRECTORY OR SINGLE SEQ, SKIP TO FULL MOVE.
;
SEQ_MOV_40
               BTST    #DIR_BIT,D0          ;ARE WE DOING A DIRECTORY READ?
               BEQ.S   SEQ_MOV_44           ;BRANCH IF NOT - COPY DISK/BANK NAME, THEN GO ALL-OUT.
;
               TST     DRIVE_SEL            ;READING SEQUENCES DIRECTORY - FROM WHICH DRIVE?
               BPL     SCSI_SEQ_DIR_MOVE    ;BRANCH FOR SCSI BANK DIRECTORY EXTRACT, RETURN THRU.
;
               BSR     MOVE_SEQ_DIRECTORY   ;FLOPPY - COMPILE DIR FROM SIDE 0 FILE IN WASTELAND.
               TST     (A6)                 ;ANY UNREADABLE RECORDS IN SIDE 0 SEQ DIRECTORY FILE?
               BEQ     SEQ_MOV_EXIT         ;BRANCH IF NOT, EXIT WITH NO-ERROR STATUS.
               BRA     RCVR_SEQ_DIRECTORY   ;ELSE TRY TO RECOVER DATA FROM SIDE 1 REDUNDANT FILE,
                                            ;PASS RETURN STATUS THROUGH.
;
SEQ_MOV_44
               BTST    #MOV_ALL_BIT,D0      ;ARE WE DOING ONE-SEQUENCE LOAD?
               BEQ     LOAD_ONE_SEQUENCE    ;BRANCH IF YES - SEPARATE PROCEDURE FROM THIS POINT.
                                            ;ELSE - COPY DISK/BANK NAME, THEN GO ALL-OUT.
;
SEQ_MOV_4F
                                            ;ALL-SEQUENCES TRANSFER:
;
               BSR     COPY_BANK_NAME       ;MOVE DISK OR BANK NAME INTO MAIN DESCRIPTOR BUFFER
                                            ;(IF LOADING - FOR VERIFY, NO ACTION).
;
               TST     DRIVE_SEL            ;NOW WEIGHT AMINIT - WHITHER GOEST US?
               BPL     SCSI_ALL_SEQ_MOVE    ;BRANCH IF GOING SCSI-LY - SEPRIT PROCEDURE FROM HERE.
;
                                            ;FLOPPY, THEN:
;
               BSR     SEL_SIDE_0           ;WE MUST BEYOND ANY DOUBT BE LOOKING AT SIDE 0.
;
               MOVE    DISK_OP_CODE,D1      ;SHOULD WE BE TRANSFERRING SYS CONFIG STUFF?
               BTST    #SYSTEM_BIT,D1
               BEQ.S   SEQ_MOV_50           ;BRANCH IF NOT, ELSE ....
;
               BSR     MOVE_MIDI_BLOCK      ;TRANSFER MIDI SYSTEM CONFIG BLOCK.
               BNE     SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS     SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
;
               BSR     MOVE_SEQ_SYS_BLOCK   ;TRANSFER SEQUENCER SYSTEM CONFIG BLOCK.
               BNE     SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS     SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
;
               BSR     MOVE_SMPTE_BLOCK     ;TRANSFER SMPTE SYSTEM CONFIG BLOCK.
               BNE     SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS     SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
;
SEQ_MOV_50
               BSR     MOVE_SEQ_DIRECTORY   ;TRANSFER SEQUENCE DIRECTORY.
               BNE     SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS     SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
;
               BSR     MOVE_SEQ_BLOCK_LIST  ;TRANSFER SEQUENCE RAM BLOCK LIST.
               BNE     SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS     SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
;
               MOVE    DISK_OP_CODE,D1      ;SHOULD WE BE TRANSFERRING SONGS?
               BTST    #SONG_BIT,D1
               BEQ.S   SEQ_MOV_60           ;BRANCH IF NOT, ELSE ....
;
               BSR     MOVE_SONG_LIST       ;TRANSFER SONG LIST.
               BNE     SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS     SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
;
SEQ_MOV_60
               MOVE    DISK_OP_CODE,D1      ;ARE WE LOADING?
               BTST    #LOAD_BIT,D1
               BEQ.S   SEQ_MOV_A0           ;BRANCH IF NOT, DO SIDE 1 REDUNDANT SAVE OR VERIFY
                                            ;OF SEQUENCE DIRECTORY, BLOCK LIST, SONG LIST FILES.
;
                                            ;LOADING:
               MOVE    DISK_OP_CODE,D1      ;ARE WE SUPPOSED TO BE TRANSFERRING SONGS?
               BTST    #SONG_BIT,D1
               BEQ.S   SEQ_MOV_70           ;BRANCH IF NOT, ELSE ....
;
               TST     (A6)                 ;ANY UNREADABLE RECORDS IN SIDE 0 SONG LIST FILE?
               BEQ.S   SEQ_MOV_70           ;BRANCH IF NOT, GO CHECK UP ON BLOCK LIST TRANSFER.
               BSR     RCVR_SONG_LIST       ;ELSE ATTEMPT TO LOAD BAD RECORDS FROM SIDE 1 FILE.
               BNE     SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS     SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
;
SEQ_MOV_70
               MOVE    #WASTELAND_2+220H,A6 ;CHECK RESULTS LOGGED FOR BLOCK LIST TRANSFER -
               TST     (A6)                 ;ANY UNREADABLE RECORDS IN SIDE 0 BLOCK LIST FILE?
               BEQ.S   SEQ_MOV_80           ;BRANCH IF NOT, GO CHECK UP ON DIRECTORY TRANSFER.
               BSR     RCVR_SEQ_BLOCK_LIST  ;ELSE ATTEMPT TO LOAD BAD RECORDS FROM SIDE 1 FILE.
               BNE     SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS     SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
;
SEQ_MOV_80
               MOVE    #WASTELAND_2+200H,A6 ;CHECK RESULTS LOGGED FOR DIRECTORY TRANSFER -
               TST     (A6)                 ;ANY UNREADABLE RECORDS IN SIDE 0 SONG LIST FILE?
               BEQ.S   SEQ_MOV_B0           ;BRANCH IF NOT - ONWARD TO SEQUENCE DATA TRANSFER.
               BSR     RCVR_SEQ_DIRECTORY   ;ELSE ATTEMPT TO LOAD BAD RECORDS FROM SIDE 1 FILE.
               BNE.S   SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS.S   SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
               BRA.S   SEQ_MOV_B0           ;SUCCESSFUL - GO DO SEQUENCE DATA (ITSELF) TRANSFER.
;
SEQ_MOV_A0
               BSR     SEL_SIDE_1           ;REDUNDANT SAVE: SEQ DIRECTORY, BLOCK LIST, SONG LIST.
;
               BSR     MOVE_SEQ_DIRECTORY   ;WRITE SEQUENCE DIRECTORY.
               BNE.S   SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS.S   SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
;
               BSR     MOVE_SEQ_BLOCK_LIST  ;WRITE SEQUENCE RAM BLOCK LIST.
               BNE.S   SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS.S   SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
;
               MOVE    DISK_OP_CODE,D1      ;ARE WE SUPPOSED TO BE TRANSFERRING SONGS?
               BTST    #SONG_BIT,D1
               BEQ.S   SEQ_MOV_B0           ;BRANCH IF NOT, ELSE ....
;
               BSR     MOVE_SONG_LIST       ;WRITE SONG LIST.
               BNE.S   SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS.S   SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
;
;
SEQ_MOV_B0
                                            ;NOW THAT DISK AND RAM DIRECTORIES ARE EQUIVALENT,
                                            ;COMPILE A LIST OF USED SQUENCE DATA RECORDS -
                                            ;WE TRANSFER ONLY THE ONES ACTUALLY USED, SAVES US
                                            ;BUON MOLTO EL TIEMPO, IF YOU FOLLOW MY MEANING ....
               MOVEQ   #-1,D0               ;FIRST, SET 400 BYTES IN DIRECTORY_BUF -
               MOVEQ   #99,D1               ;AS THOUGH ALL 400 RECORDS CONTAIN VALID DATA.
               MOVE.L  #DIRECTORY_BUF,A0    ;SET POINTER TO THIS BUF,
               MOVE.L  A0,A1                ;SET DUPLICATE POINTER FOR LATER.
SEQ_MOV_C0
               MOVE.L  D0,(A1)+
               DBRA    D1,SEQ_MOV_C0
;
               MOVE.L  #SEQ_DIR_99,A1       ;NOW, FETCH START BLOCK INDEX FOR FREE MEMORY STRING -
               MOVE    Q_START_BLK(A1),D1   ;OF COURSE, THIS BLOCK IS UNUSED .... RIGHT?
SEQ_MOV_D0
               SF      0(A0,D1)             ;CLEAR DIRECTORY_BUF FLAG FOR UNUSED SEQ DATA RECORD.
               ADD     D1,D1                     ;A1 BECOMES WORD OFFSET PER BLOCK INDEX,
               MOVE    D1,A1
               MOVE    SEQ_BLOCK_LIST(A1),D1     ;FETCH INDEX OF NEXT BLOCK IN FREE MEMORY STRING -
               BPL.S   SEQ_MOV_D0                ;LOOP IF NOT NEG - WE HAVEN'T HIT END OF STRING.
;
               BSR     SEL_SIDE_0           ;NOW, GO FOR THE BIG RAW MOUNDS OF DATA.
               BSR     MOVE_SEQ_DATA        ;TRANSFER SEQUENCE DATA ON SIDE 0 FIRST.
               BNE.S   SEQ_MOV_EXIT         ;BRANCH IF ERROR ABORT.
               BCS.S   SEQ_MOV_EXIT         ;BRANCH IF USER ABORT.
               MOVE    DISK_OP_CODE,D1      ;ARE WE LOADING?
               BTST    #LOAD_BIT,D1
               BEQ.S   SEQ_MOV_E0           ;BRANCH IF NOT, DO SIDE 1 REDUNDANT SAVE OR VERIFY.
               CMP     #WASTELAND_2,A6      ;LOADING - WERE ANY SIDE 0 RECORDS UNREADABLE?
               BEQ.S   SEQ_MOV_EXIT         ;BRANCH IF NOT (LIST POINTER HASN'T BEEN ADVANCED) -
                                            ;EXIT WITH NO-ERROR STATUS.
               BSR     SEQ_DATA_RECOVER     ;ELSE, ATTEMPT TO LOAD THESE RECORDS FROM SIDE 1 FILE.
               BRA.S   SEQ_MOV_EXIT         ;PASS RETURN STATUS THROUGH AS COMPLETION STATUS.
SEQ_MOV_E0
               BSR     SEL_SIDE_1           ;DO DUPLICATE (REVERSED) SAVE/COMPARE TO SIDE 1.
               BSR     MOVE_SEQ_DATA
                                            ;PASS RETURN STATUS THROUGH AS COMPLETION STATUS.
;
SEQ_MOV_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; ONE-SEQUENCE LOAD -
; BY THE TIME WE GET HERE, WE'VE PASSED THE IMPORTANT TESTS -
; DISK TYPE, FILE STATUS, WHAT-HAVE-YOU ....
; IF LOADING FROM FLOPPY, WE SHOULD BE ON DISK SIDE 0.  OFF WE GO!
;
LOAD_ONE_SEQUENCE
                                            ;FIRST THING IS TO READ SOURCE SEQUENCE DIRECTORY BLOCK
                                            ;INTO WASTELAND_2, TO SEE IF IT EXISTS AND SUCH:
;
               TST     DRIVE_SEL            ;LOADING FROM FLOPPY?
               BMI.S   LD_1_SEQ_06          ;BRANCH IF YES -
               BSR     SCSI_SEQ_DIR_MOVE    ;ELSE GO FOR THE SCSI STUFF.
               BEQ.S   LD_1_SEQ_30          ;IF SCSI DATA COMES IN OK, GO LOOK AT IT -
               BRA     LD_1_SEQ_EXIT        ;ELSE, WE OUTA HERE.
;
LD_1_SEQ_06
                                            ;LOADING FROM FLOPPY:
               SF      BEGIN_TRUNC          ;NO BYTE SKIP TO READ DIRECTORY ENTRY FROM DISK.
               MOVE    SEQ_UNIT_SEL,D0      ;FETCH NUMBER OF SEQUENCE TO LOAD FROM DISK.
               LSR     #3,D0                ;AT EIGHT ENTRIES PER, HERE IS DIRECTORY FILE RECORD -
               MOVE    D0,CURRENT_REC
               ADDQ    #4,D0                ;ON SIDE 0, DIRECTORY STARTS ON TRACK 04.
LD_1_SEQ_08
               MOVE    D0,CURRENT_TRACK     ;SAVE IT IN CASE WE MUST RETRY.
               BSR     BLIND_SEEK           ;HEAD FOR THIS TRACK,
               BSR     DLY_20_MSEC          ;GET SETTLED THERE.
               CLR     RETRIES              ;CLEAR THE RECORD.
LD_1_SEQ_10
               MOVEQ   #5,D0                ;SECTOR 5, TO BE SURE.
               MOVE    #256,D2              ;READ THE WHOLE RECORD.
               MOVE    #WASTELAND_2,A0      ;STASH IT HERE FOR DISSECTION.
               BSR     SECTOR_READ
               BEQ.S   LD_1_SEQ_20          ;BRANCH IF RECORD SUCCESFULLY READ.
               BSR     QUIET_RETRY          ;ELSE SEE IF (ANOTHER) RETRY IS POSSIBLE.
               BEQ     LD_1_SEQ_10          ;BRANCH IF YES, GO TO IT.
               TST     CURRENT_SIDE         ;MULTIPLE RETRIES FAILED - ARE WE ON SIDE 1?
               BEQ.S   LD_1_SEQ_12          ;BRANCH IF NOT, GIVE SIDE 1 A TRY.
               MOVEQ   #UNRECOVERABLE,D0    ;ELSE ABANDON ALL HOPE -
               BRA     LD_1_SEQ_EXIT        ;EXIT WITH THIS GLOOMY MESSAGE.
LD_1_SEQ_12
               BSR     SEL_SIDE_1           ;TRY TO GET DATA FROM REDUNDANT SIDE 1 FILE.
               MOVEQ   #75,D0               ;SIDE 1 FILE STARTS ON TRACK 75 AND WORKS OUTWARD -
               SUB     CURRENT_REC,D0
               BRA     LD_1_SEQ_08          ;LOOP BACK TO SET NEW TRACK NUMBER AND TRY SIDE 1 FILE.
;
LD_1_SEQ_20
               MOVE    #WASTELAND_2,A1      ;THIS IS WHERE WE WANT SOURCE SEQUENCE DIRECTORY ENTRY.
               MOVE    SEQ_UNIT_SEL,D0      ;FETCH SOURCE SEQUENCE NUMBER AGAIN, SEE WHERE IT IS.
               AND     #7,D0
               BEQ.S   LD_1_SEQ_30          ;BRANCH IF ENTRY WAS AT START OF RECORD,
               MOVE    #Q_BLOCK_SIZE,D1     ;ELSE MOVE IT TO APPEAR AS THOUGH IT WAS -
               MULU    D1,D0                ;COMPUTE BYTE OFFSET INTO BUFFERED RECORD,
               MOVE    A1,A0                ;SET POINTER TO DIRECTORY ENTRY,
               ADD     D0,A0
               SUBQ    #1,D1                ;SET UP MOVE-LOOP COUNT.
LD_1_SEQ_24
               MOVE.B  0(A0,D1),0(A1,D1)
               DBRA    D1,LD_1_SEQ_24
;
;
;
LD_1_SEQ_30
                                            ;SOURCE SEQ DIR BLOCK IS NOW AT WASTELAND_2:
;
               MOVE    #WASTELAND_2,A1      ;SET POINTER TO BUFFERED SOURCE SEQUENCE DIR BLOCK -
               TST     Q_STATUS(A1)         ;IS DISK SOURCE SEQUENCE EMPTY, DELETED, ETC?
               BNE.S   LD_1_SEQ_40          ;BRANCH IF NOT, CONTINUE -
               MOVEQ   #SOURCE_SEQ_DEL,D0   ;ELSE HALT AND EXIT WITH THIS MESSAGE.
               BRA     LD_1_SEQ_EXIT
;
;
;
LD_1_SEQ_40
               MOVE.L  #SEQ_DIR_99,A2       ;SOURCE SEQ EXISTS - HOW MUCH LOADING SPACE DO WE HAVE?
               MOVE    Q_MEM_USED(A2),D0    ;THIS IS THE AMOUNT OF FREE SEQUENCE MEMORY.
                ABS_LONG
               JSR     GET_CUR_SEQ_DIR      ;SET A0 AS POINTER TO TARGET SEQUENCE DIRECTORY ENTRY.
                ABS_SHORT
               TST     Q_STATUS(A0)         ;IS TARGET SEQUENCE EMPTY?
               BEQ.S   LD_1_SEQ_44          ;BRANCH IF YES, IT HAS NO SPACE TO CONTRIBUTE.
               ADD     Q_MEM_USED(A0),D0    ;ELSE, WE'LL USE THAT SPACE, SO ADD IT ON -
LD_1_SEQ_44
               CMP     Q_MEM_USED(A1),D0    ;IS TOTAL AVAILABLE SPACE LARGER THAN SOURCE SEQUENCE?
               BGT.S   LD_1_SEQ_50          ;BRANCH IF YES (NEED AT LEAST ONE EXTRA BLOCK, YES?) -
               MOVEQ   #NO_ROOM,D0          ;ELSE HALT WITH THIS MESSAGE.
               BRA     LD_1_SEQ_EXIT
;
;
;
LD_1_SEQ_50
               TST     Q_STATUS(A0)         ;WE GOT THE SPACE WE NEED - IS TARGET SEQUENCE EMPTY?
               BEQ.S   LD_1_SEQ_60          ;BRANCH IF YES, EES NO PRO'LEM -
               MOVEQ   #TARGET_SEQ_EST,D0   ;ELSE, GIVE THE USER A CHANCE TO AVOID REGRETZ.
               BSR     QUERY
               BNE     LD_1_SEQ_EXIT        ;BRANCH IF RETURN WITH DRIVE STATUS ERROR.
               BCS     LD_1_SEQ_EXIT        ;BRANCH IF USER SAID "....nah."
               BSR     DISP_XFR_SCREEN      ;ELSE PUT UP DISPLAY SCREEN,
                ABS_LONG
               JSR     GET_CUR_SEQ_DIR      ;REFRESH OUR POINTER TO TARGET SEQUENCE DIRECTORY SLOT,
                ABS_SHORT
               CLR     Q_STATUS(A0)         ;PLOW TARGET SEQUENCE BACK INTO THE EARTH.
               CLR     Q_MEM_USED(A0)
               MOVE    Q_START_BLK(A0),D0   ;SAVE START BLOCK INDEX -
               MOVE    #-1,Q_START_BLK(A0)  ;START BLOCK IS NOW A NON-BLOCK, a.k.a. MEM STRING END.
               MOVE    LAST_FREE_BLK,A0     ;LINK END OF NULL SEQUENCE TO TARGET SEQUENCE'S MEMORY,
               ADD     A0,A0                ;RETURN THAT MEMORY TO FREE-MEM POOL.
               MOVE    D0,SEQ_BLOCK_LIST(A0)
               MOVE    CURRENT_SEQUENCE,LAST_SETUP_SEQ     ;AHH - MAKE SURE WE UPDATE THE RIGHT SEQ.
                ABS_LONG
               JSR     UPDATE_SEQ_SIZE      ;SETTLE ACCOUNTS NOW, IN CASE WE ABORT ON DISK ERROR.
                ABS_SHORT
;
;
;
LD_1_SEQ_60
                                            ;TARGET SEQUENCE IS WIPED - NOW PUSH RESIDENT SEQUENCE
                                            ;MEMORY BLOCK LIST ASIDE SO WE CAN LOAD ONE FROM DISK:
;
               MOVE    #199,D0              ;STASH LOCAL BLOCK LIST IN WASTELAND WHILE WE
               SUB.L   A0,A0                ;LOAD BLOCK LIST IN FROM DISK.
LD_1_SEQ_62
               MOVE.L  SEQ_BLOCK_LIST(A0),WASTELAND(A0)
               ADDQ    #4,A0
               DBRA    D0,LD_1_SEQ_62
;
               TST     DRIVE_SEL            ;ARE WE LOADING FROM FLOPPY DISK?
               BMI.S   LD_1_SEQ_63          ;BRANCH IF YES -
               BSR     SCSI_BLOCKLIST_MOVE  ;ELSE GO FOR THE SCSI STUFF.
               BRA.S   LD_1_SEQ_64          ;FORGE AHEAD, TRANSFER RESULTS CHECKED BELOW.
;
LD_1_SEQ_63
                                            ;LOADING FROM FLOPPY:
               BSR     SEL_SIDE_0           ;MAKE SURE WE'RE LOOKING AT DISK SIDE 0.
               BSR     MOVE_SEQ_BLOCK_LIST  ;WELL, TRY TO DRAG IT IN (TO SEQ_BLOCK_LIST AREA).
               TST     (A6)                 ;DID WE HIT ANY UNREADABLE RECORDS?
               BEQ.S   LD_1_SEQ_64          ;BRANCH IF NOT,
               BSR     RCVR_SEQ_BLOCK_LIST  ;ELSE TRY TO RECOVER DATA FROM SIDE 1 REDUNDANT FILE.
LD_1_SEQ_64
;
;880709               MOVE    CCR,-(A7)            ;SAVE RETURN CODES, WE MUST RESTORE LOCAL BLOCK LIST
;880709;       NOTE:  MOVE FROM CCR DOES NOT EXIST ON 68000,
;880709;       HP64000 ASSEMBLER (QUIETLY) USED THE FOLLOWING IN ITS PLACE:
;
               MOVE    SR,-(A7)             ;SAVE RETURN CODES, WE MUST RESTORE LOCAL BLOCK LIST
               MOVE    D0,-(A7)             ;NO MATTER WHAT HAPPENED!
               MOVE    #199,D0              ;AT SAME TIME, DISK BLOCK LIST IS MOVED INTO WASTELAND.
               SUB.L   A0,A0
LD_1_SEQ_66
               MOVE.L  SEQ_BLOCK_LIST(A0),D1     ;FETCH TWO WORDS FROM BUFFERED DISK BLOCK LIST,
               MOVE.L  WASTELAND(A0),D2          ;LIKEWISE FOR STASHED LOCAL BLOCK LIST.
               MOVE.L  D1,WASTELAND(A0)          ;SWAP-STORE THEM.
               MOVE.L  D2,SEQ_BLOCK_LIST(A0)
               ADDQ    #4,A0
               DBRA    D0,LD_1_SEQ_66            ;LOOP UNTIL BLOCK LISTS COMPLETELY SWAPPED.
;
               MOVE    (A7)+,D0             ;RETRIEVE BLOCK LIST LOAD RETURN CODES -
               MOVE    (A7)+,CCR
               BNE     LD_1_SEQ_EXIT        ;EXIT IF DRIVE STATUS ERROR.
               BCS     LD_1_SEQ_EXIT        ;EXIT IF USER ABORT UPON ERROR.
;
;
;
                                            ;SEQUENCE MEMORY BLOCK LIST FROM SOURCE SEQUENCE DISK
                                            ;FILE IS NOW IN WASTELAND - USE IT TO LOAD SEQ DATA:
;
               MOVE    #WASTELAND_2,A0      ;FETCH DISK/SOURCE SEQUENCE START BLOCK INDEX
               MOVE    Q_START_BLK(A0),SEQ1_DRD_BLK   ;(GUIDES US INTO RECORDS-TO-READ SEQUENCE),
               BPL.S   LD_1_SEQ_68          ;MAKE SURE IT'S NOT NEGATIVE, WHICH WOULD BE DISASTER -
               MOVEQ   #BAD_SEQ_DIR,D0      ;IF IT IS, SOMEONE GOOFED UP THE FILE SAVED TO DISK -
               BRA     LD_1_SEQ_EXIT        ;QUIT WHILE AHEAD, WITH ERROR MESSAGE.
LD_1_SEQ_68
               MOVE.L  #SEQ_DIR_99,A0       ;LIKEWISE FOR FREE MEMORY STRING - WE'LL WRITE INTO IT.
               MOVE    Q_START_BLK(A0),SEQ_WR_BLK
;
;
                                            ;MAIN DATA-TRANSFER LOOP:
LD_1_SEQ_70
               MOVE    SEQ_WR_BLK,D0        ;SET RAM LOAD ADDRESS FOR RECORD ABOUT TO BE READ.
               MULU    #1024,D0             ;NUMBER OF BYTES PER,
               ADD.L   #SEQUENCE_RAM,D0     ;AND IT ALL BEGINS HERE -
               MOVE.L  D0,CUR_XFR_ADDR      ;STORE FOR FUTURE (RETRY) REFERENCE.
;
               TST     DRIVE_SEL            ;ARE WE LOADING FROM FLOPPY DISK?
               BMI.S   LD_1_SEQ_78          ;BRANCH IF YES -
               MOVE    SEQ1_DRD_BLK,D0      ;ELSE FETCH SEQ DATA BLOCK RECORD NUMBER,
               MOVE    D0,CURRENT_REC
               BSR     INDICATE             ;TWINKLE THE LEDs, MUCH TO USER'S AMAZEMENT,
               BSR     SCSI_SEQ_BLOCK_MOVE  ;GO FOR THE SCSI STUFF.
               BEQ.S   LD_1_SEQ_A8          ;FORGE AHEAD IF TRANSFER WAS SUCCESSFUL,
               BRA     LD_1_SEQ_EXIT        ;ELSE WAVE WISTE-FULLE GOODE-BYE.
;
LD_1_SEQ_78
               BSR     SEL_SIDE_0           ;FLOPPY LOAD - NORMALLY, WE READ FROM SIDE 0 FILE.
;
LD_1_SEQ_80
               CLR.L   D0                   ;NOW COMPUTE TRACK AND SECTOR FOR RECORD TO BE READ:
               MOVE    SEQ1_DRD_BLK,D0      ;FETCH RECORD NUMBER,
               MOVE.L  D0,D1                ;COPY IT AND COMPUTE RECORD PHYSICAL ADDRESS.
               DIVU    #5,D0                ;FIVE RECORDS PER TRACK -
               EXT.L   D0                   ;THIS IS IT IF WE'RE ON SIDE 0 -
               MOVE.L  D0,D2                ;OFF REMAINDER, SAVE FOR SECTOR COMPUTATION.
               TST     CURRENT_SIDE         ;ARE WE ON SIDE 0?
               BEQ.S   LD_1_SEQ_82          ;BRANCH IF YES,
               NEG     D0                   ;ELSE ADJUST TRACK NUMBER FOR SIDE 1 REVERSAL.
               ADD     #79,D0
LD_1_SEQ_82
               ADD     D1,D2                ;RECORD SEQUENCE ROTATES BY ONE PER TRACK,
               DIVU    #5,D2                ;DIVIDE BY 5,
               SWAP    D2                   ;TAKE REMAINDER -
               MOVE    D2,CURRENT_SEC       ;SO THIS IS THE SECTOR WE WANT.
               CMP     CURRENT_TRACK,D0     ;ARE WE ALREADY ON DESIRED TRACK?
               BEQ.S   LD_1_SEQ_84          ;BRANCH IF YES, DON'T WASTE TIME ON TRACK SEEK.
               MOVE    D0,CURRENT_TRACK     ;ELSE SET NEW TRACK NUMBER,
               BSR     BLIND_SEEK           ;"HEAD" FOR THIS TRACK,
               BSR     DLY_20_MSEC          ;SETTLE YE BUTT UPON IT.
LD_1_SEQ_84
               CLR     RETRIES              ;CLEAR RETRY COUNT FOR THIS RECORD.
;
LD_1_SEQ_90
               MOVE.L  CUR_XFR_ADDR,A0      ;FETCH CURRENT RECORD LOAD ADDRESS.
               MOVE    CURRENT_SEC,D0       ;FETCH SECTOR NUMBER,
               BSR     INDICATE             ;PUT IT UP IN LIGHTS.
               MOVE    #1024,D2             ;ALWAYS READ ENTIRE SECTOR, JA?
               BSR     SECTOR_READ          ;RID DEM SIKTAH.
               BEQ.S   LD_1_SEQ_A0          ;IF SUCCESSFULLY READ, MOVE ON TO NEXT RECORD.
               TST     CURRENT_SIDE         ;IF ERROR, ACTION DEPENDS ON WHICH SIDE WE'RE ON -
               BNE.S   LD_1_SEQ_98          ;BRANCH IF ON SIDE 1.
               BSR     QUIET_RETRY          ;USE LOW-KEY RETRY ON SIDE 0.
               BEQ     LD_1_SEQ_90          ;IF OK TO TRY AGAIN, DO SO WITH SAME TRANSFER PARAMS -
               BSR     SEL_SIDE_1           ;IF MULTIPLE RETRIES ON SIDE 0 FAILED, GO TO SIDE 1 AND
               BRA     LD_1_SEQ_80          ;TRY WITH PARAMS SET FOR SAME RECORD IN SIDE 1 FILE.
LD_1_SEQ_98
               BSR     RETRY                ;ALREADY TRYING TO READ FROM REDUNDANT SIDE 1 FILE -
               BEQ     LD_1_SEQ_90          ;IF ANOTHER RETRY OK, RE-USE EXISTING TRANSFER PARAMS.
               MOVEQ   #UNRECOVERABLE,D0    ;IF MULTIPLE RETRIES FAILED IN REDUNDANT FILE ALSO,
               BRA.S   LD_1_SEQ_EXIT        ;WE'RE FUCKED, BASICALLY.
;
;
;
LD_1_SEQ_A0
               BSR     SEL_SIDE_0                ;FLOPPY MAY HAVE GONE TO SIDE 1 - JAM TO SIDE 0.
;
LD_1_SEQ_A8
               MOVE    SEQ_WR_BLK,PREV_WR_BLK    ;RECORD READ OK, SAVE INDEX OF BLOCK WRITTEN INTO.
               MOVE    SEQ1_DRD_BLK,A0           ;ACCESS DISK BLOCK LIST FOR NEXT RECORD TO READ.
               ADD     A0,A0
               MOVE    WASTELAND(A0),SEQ1_DRD_BLK
               BMI.S   LD_1_SEQ_B0               ;IF NEGATIVE, WE DONE READ 'EM ALL.
               MOVE    SEQ_WR_BLK,A0             ;ELSE FIND NEXT WRITE BLOCK, LOOP BACK TO FILL UP.
               ADD     A0,A0
               MOVE    SEQ_BLOCK_LIST(A0),SEQ_WR_BLK
               BPL     LD_1_SEQ_70               ;WE OUGHT NEVER TO HIT THE END OF FREE MEM STRING,
               MOVE    CUR_XFR_ADDR,A0           ;BUT JUST IN CASE WE DO ....
               ADD     #1016,A0
               MOVEQ   #0FH,D0                   ;AMPUTATE SEQUENCE AT THE END OF LAST_READ BLOCK,
               MOVE    D0,(A0)+
               MOVE    D0,(A0)+
               MOVE    D0,(A0)+
               MOVE    D0,(A0)+
               MOVEQ   #MEM_ALLOC_ERR,D0         ;THEN POST THIS BAD NEWS AND ....
               BRA.S   LD_1_SEQ_EXIT             ;STOP!!!
;
LD_1_SEQ_B0
                ABS_LONG
               JSR     GET_CUR_SEQ_DIR      ;CLEAN-UP TIME: A0 POINTS TO TARGET SEQ DIR BLOCK -
                ABS_SHORT
               MOVE    #WASTELAND_2,A1      ;COPY THE BUFFERED SOURCE SEQ DIR BLOCK INTO IT.
               MOVE    #Q_BLOCK_SIZE-1,D0
LD_1_SEQ_B4
               MOVE.B  0(A1,D0),0(A0,D0)
               DBRA    D0,LD_1_SEQ_B4
;
               MOVE.L  #SEQ_DIR_99,A1       ;NOW MAKE THE PERTINENT ADJUSTMENTS:
               MOVE    Q_START_BLK(A1),Q_START_BLK(A0)     ;SET NEW TARGET SEQ START BLOCK INDEX.
               MOVE    PREV_WR_BLK,A2       ;THE LAST BLOCK WRITTEN INTO LINKS TO WHAT IS NOW THE
               ADD     A2,A2                ;FIRST BLOCK IN THE FREE-MEMORY STRING -
               MOVE    SEQ_BLOCK_LIST(A2),Q_START_BLK(A1)
               MOVE    #-1,SEQ_BLOCK_LIST(A2)    ;AND, LAST WRITE BLOCK IS LAST BLOCK OF NEW SEQ.
                ABS_LONG
               JSR     UPDATE_SEQ_SIZE      ;UPDATE Q_MEM_USED FOR TARGET AND FREE-MEM SEQUENCES,
                                            ;ALSO VALUES FOR LAST_FREE_BLK AND NEXT2LAST_FREE.
                ABS_SHORT
               CLR     D0                   ;EXIT WITH NO-ERROR STATUS.
;
LD_1_SEQ_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; TRANSFER SOUNDS FROM A MODEL 2000/2002 DISK -
; THEORETICALLY AT LEAST, HANDLES REV 2.1 DISKS AND REV 3.0 DISKS
; (BOTH 1-SIDED AND 2-SIDED), INCLUDING DISKS ONLY HALF-SAVED.
;
; SOUNDS 1-16 (SUCH AS EXIST ON THE DISK) ARE LOADED INTO THE 440
; IN THE CORRESPONDING SOUND SLOTS - TRANSFER ABORTS WITHOUT EFFECT IF
; NEITHER FILE STATUS CHARACTER ON DISK MATCHES NON-DELETED STATUS.
;
; APPROPRIATES BEGIN, FINISH, START AND END ADDRESSES INTO BOTH
; VARIATIONS OF EACH 440 TARGET SOUND -
; RELEASE LOOP IS USED AS LOOP FOR THE NON-A VARIATION,
; SINCE MOST 2000 DISKS USE RELEASE LOOP ONLY.
; SUSTAIN LOOP IS USED AS LOOP FOR THE A VARIATION.
; LOOP ENABLE AND MODE, SAMPLE RATE, DIRECTION AND - WHAT THE HELL -
; START-POINT VELOCITY MOD ARE ADAPTED FROM DISK AS WELL.
; ALL OTHER SOUND PARAMETERS ARE DEFAULTED, INCLUDING SOUND NAME.
;
; PRESET, MAP AND GLOBAL INFO IS ALL BLITHELY IGNORED - NO SURPRISE.
;
; SAVE, VERIFY, AND ONE-SOUND LOAD REMAIN UNIMPLEMENTED FOR NOW.
; SORRY.   WELL, NOT REALLY.
;
TRANSFER_2000
               BSR     DISP_XFR_SCREEN      ;SHOW THEM HOW SMART WE ARE.
               MOVE    #WASTELAND,A0        ;CLEAR IT OUT - SAMPLE CONTROL BLOCKS BUFFERED HERE,
               MOVE    #1FFH,D0             ;THIS DEFAULTS UN-LOADED BLOCKS TO DELETED STATUS.
               CLR.L   D1
XFR_2K_10
               MOVE.L  D1,(A0)+
               DBRA    D0,XFR_2K_10
;
               CMP.B   #NON_DELETED,LFT_HLF_STAT      ;ARE BOTH FILE STATUS CHARS RECOGNIZABLE?
               BEQ.S   XFR_2K_20
               CMP.B   #DELETED,LFT_HLF_STAT
               BNE.S   XFR_2K_30                      ;THIS ONE'S NOT -
XFR_2K_20
               CMP.B   #NON_DELETED,RGT_HLF_STAT      ;LEFT ONE'S OK, HOW ABOUT RIGHT?
               BEQ.S   XFR_2K_40
               CMP.B   #DELETED,RGT_HLF_STAT
               BEQ.S   XFR_2K_40                      ;LOOKIN' WAY GOOD.
XFR_2K_30
               MOVEQ   #INVAL_FORMAT,D0     ;SEND A MESSAGE ABOUT THAT BOGUS FILE STATUS CHARACTER.
               BSR     QUERY                ;WHAT DOES MR. USER THINK ABOUT THIS?
               BNE     XFR_2K_EXIT          ;EXIT IF DRIVE STATUS ERROR (E.G. REMOVED DISK).
               BCS     XFR_2K_EXIT          ;EXIT IF MR. USER SAY ONCLE.
               BSR     DISP_XFR_SCREEN      ;CONTINUING, SO RESTORE TRANSFER SCREEN.
XFR_2K_40
               CMP.B   #NON_DELETED,LFT_HLF_STAT      ;AT LEAST ONE FILE BEEN SAVED TO?
               BEQ.S   XFR_2K_50
               CMP.B   #NON_DELETED,RGT_HLF_STAT      ;LEFT ONE'S EMPTY, HOW ABOUT RIGHT?
               BEQ.S   XFR_2K_50
               MOVEQ   #DATA_NOT_PRES,D0              ;NYTHAH - SO WE BE GONE NOW.
               BRA     XFR_2K_EXIT
XFR_2K_50
               CMP.B   #NON_DELETED,LFT_HLF_STAT      ;ARE WE TO LOAD THE LEFT FILE?
               BNE.S   XFR_2K_70                      ;WULL, GESS NOTT.
               CLR     RETRIES                        ;WALL, OK - START MIT DER KLEENEN SLATTEN.
               CLR     CURRENT_SEC                    ;WEBEGINWIT SECTOR 0, THEN.
XFR_2K_60
               MOVE    CURRENT_SEC,D0
               MOVE    #WASTELAND,A0        ;THIS WHERE LEFT FILE CONTROL BLOCKS GO.
               MOVE    #SRLEN*8,D2          ;THIS HOW BIG EIGHT OF 'EM BE.
               SF      BEGIN_TRUNC          ;DON'T SKIP NOTHIN.
               BSR     SECTOR_READ
               BEQ.S   XFR_2K_70            ;WE COOL - LOOK AT MR. RIGHT (FILE).
               BSR     RETRY                ;NOT COOL - TRYA GAIN?
               BEQ     XFR_2K_60            ;YAO KAY.
               BSR     QUERY                ;NO - WHAT DOES MR. USER THINK ABOUT THIS?
               BNE     XFR_2K_EXIT          ;EXIT IF DRIVE STATUS ERROR (E.G. REMOVED DISK).
               BCS     XFR_2K_EXIT          ;EXIT IF MR. USER SAY ONCLE.
               BSR     DISP_XFR_SCREEN      ;CONTINUING, SO RESTORE TRANSFER SCREEN.
XFR_2K_70
               CMP.B   #NON_DELETED,RGT_HLF_STAT      ;ARE WE TO LOAD THE RIGHT FILE?
               BNE.S   XFR_2K_90                      ;WULL, GESS NOTT.
               CLR     RETRIES                        ;WALL, OK - START MIT DER KLEENEN SLATTEN.
               MOVE    #1,CURRENT_SEC                 ;WEGOWANWIT SECTOR 1, THEN.
XFR_2K_80
               MOVE    CURRENT_SEC,D0
               MOVE    #WASTELAND+SRLEN*8,A0     ;THIS WHERE RIGHT FILE CONTROL BLOCKS GO.
               MOVE    #SRLEN*8,D2          ;THIS HOW BIG EIGHT OF 'EM BE.
               SF      BEGIN_TRUNC          ;DON'T SKIP NOTHIN.
               BSR     SECTOR_READ
               BEQ.S   XFR_2K_90            ;WE COOL - MIGHT BE TIME TO LOAD SAMPLE DATA.
               BSR     RETRY                ;NOT COOL - TRYA GAIN?
               BEQ     XFR_2K_80            ;YAO KAY.
               BSR     QUERY                ;NO - WHAT DOES MR. USER THINK ABOUT THIS?
               BNE     XFR_2K_EXIT          ;EXIT IF DRIVE STATUS ERROR (E.G. REMOVED DISK).
               BCS     XFR_2K_EXIT          ;EXIT IF MR. USER SAY ONCLE.
               BSR     DISP_XFR_SCREEN      ;CONTINUING, SO RESTORE TRANSFER SCREEN.
;
XFR_2K_90
               CLR.L   CUR_XFR_ADDR         ;WE'LL LOAD SAMPLES INTO THE BOTTOM OF SOUND RAM.
               CMP.B   #NON_DELETED,LFT_HLF_STAT      ;ARE WE TO LOAD THE LEFT SAMPLE FILE?
               BNE.S   XFR_2K_B0                      ;WULL, GESS NOTT.
;
               MOVE    #LFT_FIL_TRK,CURRENT_TRACK     ;YAH - THIS WHAT TRACK IT START ON.
               BSR     MOVE_SUBFILE                   ;SO GO GIT IT.
               BNE     XFR_2K_EXIT          ;EXIT IF ERROR,
               BCS     XFR_2K_EXIT          ;OR IF ABORT BY USER.
               TST.B   FMT_CODE             ;WE GOT A 2-SIDED DISKY HERE?
               BEQ.S   XFR_2K_B0            ;NO - IT'S RIGHT FILE TIME.
               BSR     SEL_SIDE_1           ;YES - SO GO OVER TO THE OTHER SIDE,
               BSR     LOOK_FOR_ADDR        ;SEE IF IT LOOKS LIKE THE OTHER SIDE -
               BEQ.S   XFR_2K_A0            ;IT'S JUST WHAT WE EXPECTED, ALRITE.
               BSR     QUERY                ;IT'S NO GOOD - WHAT DOES MR. USER THINK ABOUT THIS?
               BNE     XFR_2K_EXIT          ;EXIT IF DRIVE STATUS ERROR (E.G. REMOVED DISK).
               BCS     XFR_2K_EXIT          ;EXIT IF MR. USER SAY ONCLE.
               BSR     DISP_XFR_SCREEN      ;CONTINUING, SO RESTORE TRANSFER SCREEN.
XFR_2K_A0
               MOVE    #LFT_FIL_TRK,CURRENT_TRACK     ;SIDE 1 SUBFILE MIRRORS SIDE 0 SUBFILE.
               BSR     MOVE_SUBFILE                   ;SO GO GIT IT.
               BNE     XFR_2K_EXIT          ;EXIT IF ERROR,
               BCS     XFR_2K_EXIT          ;OR IF ABORT BY USER.
;
               BSR     SEL_SIDE_0           ;MOVING RIGHT ALONG - BACK TO SIDE 0.
               BSR     LOOK_FOR_ADDR        ;SEE IF IT LOOKS LIKE THE OTHER SIDE -
               BEQ.S   XFR_2K_B0            ;IT'S JUST WHAT WE EXPECTED, ALRITE.
               BSR     QUERY                ;IT'S NO GOOD - WHAT DOES MR. USER THINK ABOUT THIS?
               BNE     XFR_2K_EXIT          ;EXIT IF DRIVE STATUS ERROR (E.G. REMOVED DISK).
               BCS     XFR_2K_EXIT          ;EXIT IF MR. USER SAY ONCLE.
               BSR     DISP_XFR_SCREEN      ;CONTINUING, SO RESTORE TRANSFER SCREEN.
XFR_2K_B0
               CMP.B   #NON_DELETED,RGT_HLF_STAT      ;ARE WE TO LOAD THE RIGHT SAMPLE FILE?
               BNE.S   XFR_2K_D0                      ;WULL, GESS NOTT.
;
               MOVE    #RGT_FIL_TRK,CURRENT_TRACK     ;YAH - THIS WHAT TRACK IT START ON.
               BSR     MOVE_SUBFILE                   ;SO GO GIT IT.
               BNE     XFR_2K_EXIT          ;EXIT IF ERROR,
               BCS     XFR_2K_EXIT          ;OR IF ABORT BY USER.
               TST.B   FMT_CODE             ;WE GOT A 2-SIDED DISKY HERE?
               BEQ.S   XFR_2K_D0            ;NO - IT'S TIME FOR OUR JUGGLING ACT (SOUND CONTROLS).
               BSR     SEL_SIDE_1           ;YES - SO GO OVER TO THE OTHER SIDE,
               BSR     LOOK_FOR_ADDR        ;SEE IF IT LOOKS LIKE THE OTHER SIDE -
               BEQ.S   XFR_2K_C0            ;IT'S JUST WHAT WE EXPECTED, ALRITE.
               BSR     QUERY                ;IT'S NO GOOD - WHAT DOES MR. USER THINK ABOUT THIS?
               BNE     XFR_2K_EXIT          ;EXIT IF DRIVE STATUS ERROR (E.G. REMOVED DISK).
               BCS     XFR_2K_EXIT          ;EXIT IF MR. USER SAY ONCLE.
               BSR     DISP_XFR_SCREEN      ;CONTINUING, SO RESTORE TRANSFER SCREEN.
XFR_2K_C0
               MOVE    #RGT_FIL_TRK,CURRENT_TRACK     ;SIDE 1 SUBFILE MIRRORS SIDE 0 SUBFILE.
               BSR     MOVE_SUBFILE                   ;SO GO GIT IT.
               BNE     XFR_2K_EXIT          ;EXIT IF ERROR,
               BCS     XFR_2K_EXIT          ;OR IF ABORT BY USER.
;
XFR_2K_D0
               CLR     CURRENT_SOUND        ;GOT TO GO THROUGH ALL OF 'EM.
               MOVE    SAMPLE_RAM_END,FREE_SAM_RAM    ;OPEN UP FREE RAM, WE'LL "CREATE" 16 SOUNDS.
               MOVE    #1,CR_SAM_SIZE                 ;JUST TO BE SAVE, "CREATE" 'EM SMALL.
               MOVE    #S_BLK_00,A0         ;440 SOUND BLOCK POINTER.
               MOVE    #S_SUB_0,D0          ;440 SOUND SUB-BLOCK POINTERS.
               MOVE    #S_SUB_1,D1
               MOVE    #WASTELAND,A2        ;BUFFERED 2000 SOUND BLOCK POINTER.
;
XFR_2K_E0
               BTST    #5,SAMSTAT(A2)       ;IS CURRENT 2000 SOUND SAVED ON DISK IN SAMPLED STATUS?
               BNE.S   XFR_2K_F0            ;BRANCH IF YES - WE'LL DO IT UP.
;890317                ABS_LONG
;890317               MOVE.L  DELETED_STRING,S_NAME(A0)      ;ELSE - ERASE HIS PHONY NAME,
;890317               MOVE.L  DELETED_STRING+4,S_NAME+4(A0)
;890317                ABS_SHORT
               MOVE.L  DLTD_STRNG(PC),S_NAME(A0) ; ELSE - ERASE HIS PHONY NAME,
               MOVE.L  DLTD_STRNG+4(PC),S_NAME+4(A0)
               SF      S_STATUS(A0)              ; DELETE 440 SOUND AND MOVE ON.
               BRA     XFR_2K_J0
;
XFR_2K_F0
;
;890317               MOVEM.L D0-D1/A0-A3,-(A7)    ;SAVE ALL OF OUR POINTERS FROM THIS NEXT ONE, EH?
;890317                ABS_LONG
;890317               JSR     CREATE_SAMPLE        ;MAINLY, SET DEFAULT SOUND CONTROLS FOR THIS SOUND.
;890317                ABS_SHORT
;890317               MOVEM.L (A7)+,D0-D1/A0-A3    ;OK, BRING 'EM ON BACK NOW.
;
               JSR     INIT_SND_CTL_BLK     ; set default params in control blk.
;
;890317                ABS_LONG
;890317               MOVE.L  FROM_2000_STRING,S_NAME(A0)    ;GIVE SAMPLE A BIRTH CERTIFICATE.
;890317               MOVE.L  FROM_2000_STRING+4,S_NAME+4(A0)
;890317                ABS_SHORT
;
               MOVE.L  FROM2K_STRNG(PC),S_NAME(A0)    ;GIVE SAMPLE A BIRTH CERTIFICATE.
               MOVE.L  FROM2K_STRNG+4(PC),S_NAME+4(A0)
;
               BSET    #SAMPLED_BIT,S_STATUS(A0) ;SET SAMPLED STATUS FOR THIS SOUND
                                                 ;(INIT_SND_CTL_BLK MADE IT "UNSAMPLED").
;
               LEA     SBEGHI(A2),A3        ;COPY BEGIN ADDRESS.
               LEA     S_BEGIN+1(A0),A1
               MOVE.B  (A3)+,(A1)+
               MOVE.B  (A3)+,(A1)+
               MOVE.B  (A3),(A1)
;
               LEA     SFINHI(A2),A3        ;COPY FINISH ADDRESS.
               LEA     S_FINISH+1(A0),A1
               MOVE.B  (A3)+,(A1)+
               MOVE.B  (A3)+,(A1)+
               MOVE.B  (A3),(A1)
;
               LEA     STARTHI(A2),A3       ;COPY START ADDRESS TO BOTH VARIATIONS.
               LEA     S_START+1(A0),A1
               MOVE.B  (A3),0(A1,D0)
               MOVE.B  1(A3),1(A1,D0)
               MOVE.B  2(A3),2(A1,D0)
               MOVE.B  (A3),0(A1,D1)
               MOVE.B  1(A3),1(A1,D1)
               MOVE.B  2(A3),2(A1,D1)
;
               LEA     SENDHI(A2),A3        ;COPY END ADDRESS TO BOTH VARIATIONS.
               LEA     S_END+1(A0),A1
               MOVE.B  (A3),0(A1,D0)
               MOVE.B  1(A3),1(A1,D0)
               MOVE.B  2(A3),2(A1,D0)
               MOVE.B  (A3),0(A1,D1)
               MOVE.B  1(A3),1(A1,D1)
               MOVE.B  2(A3),2(A1,D1)
;
               LEA     SUSTHI(A2),A3        ;COPY SUSTAIN LOOP ADDRESSES TO A VARIATION.
               LEA     S_LOOP_START+1(A0,D1),A1
               MOVE.B  (A3)+,(A1)+
               MOVE.B  (A3)+,(A1)+
               MOVE.B  (A3),(A1)
               LEA     SUSENDHI(A2),A3
               LEA     S_LOOP_END+1(A0,D1),A1
               MOVE.B  (A3)+,(A1)+
               MOVE.B  (A3)+,(A1)+
               MOVE.B  (A3),(A1)
;
               LEA     SRELSTHI(A2),A3      ;COPY RELEASE LOOP ADDRESSES TO NON-A VARIATION.
               LEA     S_LOOP_START+1(A0,D0),A1
               MOVE.B  (A3)+,(A1)+
               MOVE.B  (A3)+,(A1)+
               MOVE.B  (A3),(A1)
               LEA     SRENDHI(A2),A3
               LEA     S_LOOP_END+1(A0,D0),A1
               MOVE.B  (A3)+,(A1)+
               MOVE.B  (A3)+,(A1)+
               MOVE.B  (A3),(A1)
;
               BTST    #0,SAMSTAT(A2)       ;SUSTAIN LOOP ENABLED IN SOURCE SOUND?
               BEQ.S   XFR_2K_G0            ;IF NO, LEAVE IT OFF IN TARGET (A VARIATION).
               BSET    #7,S_LOOP_TYPE(A0,D1)     ;ELSE TORYNE IT AWN, MARKED AS SUSTAIN LOOP.
XFR_2K_G0
               BTST    #1,SAMSTAT(A2)       ;HOW ABOUT RELEASE LOOP?
               BEQ.S   XFR_2K_G8            ;NO - LEAVE IT.
               BSET    #7,S_LOOP_TYPE(A0,D0)     ;YAH - TURN IT ON IN NON-A VARIATION,
               BSET    #4,S_LOOP_TYPE(A0,D0)     ;MARK IT AS RELEASE LOOP.
XFR_2K_G8
               BTST    #2,SAMSTAT(A2)       ;AND, UH - WHAT BE LOOP MODE, THEN.
               BEQ.S   XFR_2K_H0            ;IF UNIDIRECTIONAL, TARGET IS CORRECTLY SET.
               BSET    #6,S_LOOP_TYPE(A0,D0)     ;FOR BIDIRECTIONAL - SET BIT IN BOTH VARIATIONS.
               BSET    #6,S_LOOP_TYPE(A0,D1)
XFR_2K_H0
               BTST    #3,SAMSTAT(A2)       ;WHAT'S PLAYBACK DIRECTION?
               BEQ.S   XFR_2K_I0            ;BRANCH IF FORWARD,
               BSET    #5,S_LOOP_TYPE(A0,D0)     ;ELSE SET REVERSE BIT IN BOTH VARIATIONS.
               BSET    #5,S_LOOP_TYPE(A0,D1)
XFR_2K_I0
               MOVE.B  SVELMOD(A2),D2       ;CONVERT START-POINT VELOCITY-MOD SETTING.
               EXT.W   D2
               MULS    #99,D2
               ASR     #7,D2
               MOVE.B  D2,S_VEL_START(A0,D0)     ;COPY IT TO BOTH VARIATIONS.
               MOVE.B  D2,S_VEL_START(A0,D1)
               MOVE.B  SRATE(A2),D2         ;ADAPT SAMPLE RATE SETTING.
               EXT.W   D2
               ADDQ    #1,D2
               MOVE.B  D2,S_RATE(A0)
               MOVE    CURRENT_SOUND,-(A7)
               JSR     SET_ROOT_PITCH       ;SET UP ROOT PITCH DEPENDING ON SAMPLE RATE
               MOVE    (A7)+,CURRENT_SOUND
;
XFR_2K_J0
               LEA     S_BLOCK_SIZE(A0),A0  ;STEP UP TO NEXT SOUND, IF ANY -
               LEA     SRLEN(A2),A2
               ADDQ    #1,CURRENT_SOUND
               CMP     #16,CURRENT_SOUND    ;STILL WORKING ON SOUNDS (POSSIBLY) FROM 2000 DISK?
               BLT     XFR_2K_E0            ;YES - BRANCH BACK FOR FULL TREE'MENT.
               CMP     #32,CURRENT_SOUND    ;NO - BUT SOUNDS 16-32 NEED DELETE TREE'MENT.
               BGE.S   XFR_2K_J8
;890317                ABS_LONG
;890317               MOVE.L  DLTD_STRING,S_NAME(A0)      ;ERASE HIS PHONY NAME.
;890317               MOVE.L  DLTD_STRING+4,S_NAME+4(A0)
;890317                ABS_SHORT
               MOVE.L  DLTD_STRNG(PC),S_NAME(A0)      ; ERASE HIS PHONY NAME,
               MOVE.L  DLTD_STRNG+4(PC),S_NAME+4(A0)
               SF      S_STATUS(A0)
               BRA     XFR_2K_J0
XFR_2K_J8
;
;890317;
;890317               MOVE.L  #LOAD_FILE_SUB,CUR_SUB_BLOCK   ;CREATE_SAMPLE TRIED TO JUMP - TIE IT DOWN.
;890317;
               MOVE    #S_BLK_00+08*0C0H,A0 ;POINTER CORRECTION FOR SOUNDS 9-16:
               MOVE    #8,CURRENT_SOUND     ;D0-D1 SHOULD STILL = #S_SUB_0, #S_SUB_1.
               TST.B   FMT_CODE             ;IS BE A WHAT KINDA DISK?
               BNE.S   XFR_2K_K0            ;BRANCH IF 2-SIDED DISK.
               CMP.B   #NON_DELETED,LFT_HLF_STAT ;1-SIDED - DID WE LOAD LEFT HALF OF DISK?
               BEQ.S   XFR_2K_EXIT               ;BRANCH IF YES - ALL ADDRESSES ALREADY CORRECT.
               MOVE.L  #-20000H,D2               ;ELSE, RIGHT HALF ADDRESSES ARE 20000H TOO HIGH.
               BRA.S   XFR_2K_M0
XFR_2K_K0
               CMP.B   #NON_DELETED,LFT_HLF_STAT ;2-SIDED - DID WE LOAD LEFT HALF OF DISK?
               BEQ.S   XFR_2K_L0                 ;BRANCH IF YES - GOTTA FIXEMUP RIGHT HALF.
               CLR     D0                        ;ELSE, RIGHT HALF ADDRESSES ARE CORRECT -
               BRA.S   XFR_2K_EXIT               ;SO WE GO.
XFR_2K_L0
               MOVE.L  #40000H,D2           ;OFFSET FOR 2-SIDED DISK RIGHT-HALF POINTERS.
XFR_2K_M0
               ADD.L   D2,S_BEGIN(A0)       ;OFFSET EVERY GOT-DAM POINTER THE SAME!
               ADD.L   D2,S_FINISH(A0)
               ADD.L   D2,S_START(A0,D0)
               ADD.L   D2,S_LOOP_START(A0,D0)
               ADD.L   D2,S_LOOP_END(A0,D0)
               ADD.L   D2,S_END(A0,D0)
               ADD.L   D2,S_START(A0,D1)
               ADD.L   D2,S_LOOP_START(A0,D1)
               ADD.L   D2,S_LOOP_END(A0,D1)
               ADD.L   D2,S_END(A0,D1)
;
               LEA     S_BLOCK_SIZE(A0),A0  ;ONWARD TO NEXT SOUND, IF IT BE ONE.
               ADDQ    #1,CURRENT_SOUND
               CMP     #16,CURRENT_SOUND
               BLT     XFR_2K_M0
               CLR     D0                   ;NO MORE?  OK, SO GET OUTA HERE.
;
XFR_2K_EXIT
               RTS
;
;
FROM2K_STRNG
               ASC     "2000DATA"
;
DLTD_STRNG
               ASC     "deleted "
;
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

