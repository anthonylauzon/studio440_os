               INCLUDE HPFIXUPS
               TITLE "DISKMAIN"
***************************************************************************************************
***************************************************************************************************
***                                                                                             ***
***            DISKMAIN - MODEL 440 DISK SYSTEM MAIN PROGRAM AND USER INTERFACE ROUTINES        ***
***                                                                                             ***
***************************************************************************************************
***************************************************************************************************
;
NEG_EXT        EQU     0FFFFFF00H      ;USE IN MOVEQ INSTRUCTIONS WHERE ARG IS
                                       ;80H OR LARGER - HP XASM DOES NOT HANDLE
                                       ;SIGN-EXTEND CORRECTLY.  COSMETIC, KEEPS
                                       ;ACTUAL BYTE VALUE CLEARER.
;
               INCLUDE EQUATES         ;HARDWARE ADDRESSES AND DEFINITIONS.
;
               ABS_SHORT
;
               INCLUDE DISKDEFS        ;DISK SYSTEM DEFINITIONS.
;
               GLB     DISKWARD_HO
               GLB     QUERY,ALT_QUERY
               GLB     WAIT_A_SECOND,WAIT_TWO_SECS
;
                                            ;EXTERNAL ROM.
               EXTERNAL  CHECK_DRIVE,START_FLOPPY,CHECK_SPEED
               EXTERNAL  INDEX_SYNC
               EXTERNAL  READ_DESCRIPTOR,FORMAT_DISK
               EXTERNAL  TRANSFER,TRANSFER_2000
               EXTERNAL  DISP_SCREEN,DISP_BUFFER
;890313               EXTERNAL  GLANCE_AT_SWITCHES
               EXTERNAL  SCAN_SWITCHES
               EXTERNAL  SCSI_MULTIPLE_CONF,PARK_THE_HEADS
               EXTERNAL  SCSI_ALL_BANKS_DIR,SCSI_WRITE_PROTECT
               EXTERNAL  SET_NEW_SCSI_ID
               EXTERNAL  BANK_SEL_TEST
               EXTERNAL  WRITE_SCREEN
               EXTERNAL  WRITE_HEX_VALUE
               EXTERNAL  FINISH_SCSI_SEQ
               EXTERNAL  REQUEST_SENSE
               EXTERNAL  WRITE_STRING
;
                                            ;RAM, SON.
               EXTERNAL  LED_OUT_STAT
               EXTERNAL  SWITCH_BLOCK
               EXTERNAL  REAL_TIME
               EXTERNAL  FLASH_TIME
               EXTERNAL  DISK_MSG_PTR
               EXTERNAL  DISK_MSG_STAT
               EXTERNAL  DISK_OP_CODE
               EXTERNAL  ABORT_FLAG
               EXTERNAL  SWITCH_HIT
               EXTERNAL  DRIVE_SEL
               EXTERNAL  CUR_MODEL_ID
               EXTERNAL  CUR_FIRMWR_REV
               EXTERNAL  CUR_FILE_TYPE
               EXTERNAL  CUR_WRT_PROT
               EXTERNAL  CUR_SCSI_PHS
               EXTERNAL  LAST_SCSI_PHS
               EXTERNAL  TARG_STATUS
               EXTERNAL  TARG_SENSE_KEY
               EXTERNAL  HD_CAPACITY
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; DISK SYSTEM HIGH-LEVEL ENTRY POINT -
; DISK_OP_CODE CONTAINS OPCODE (BIT-MAP) FOR DESIRED OPERATION.
; DRIVE_SEL = -1 FOR FLOPPY DISK, OR = 0-6 FOR A SCSI HARD DISK.
; IF USING SCSI DISK, BANK_SEL INDICATES WHICH BANK TO ACCESS.
;
; IF ACCESSING ALTERNATE FUNCTIONS LIST, D1 CONTAINS ALTERNATE FUNCTION
; CODE - RETURN CONVENTION IS THEN DEFINED PER EACH ALTERNATE FUNCTION.
;
; ALL INTERRUPTS ARE ASSUMED TO BE DISABLED UPON ENTRY,
; AND REMAIN SO THROUGH RETURN.
;
; NORMAL HIGH-LEVEL PATH FOR EXIT FROM DISK SYSTEM - EXIT VIA:
;  -  DISK_HO_ERROR TO DISPLAY ERROR MESSAGE AND PROMPTS PER CODE IN D0.
;  -  DISK_HO_ABORT TO SLIP AWAY QUIETLY, WITH ABORT SWITCH-HIT VALUE
;     STORED IN SWITCH_HIT AND Z FLAG FALSE.
;  -  DISK_HO_EXIT TO DISPLAY OPERATION-COMPLETE MESSAGE AND RETURN
;     WITH Z FLAG TRUE.
; ALSO NOTE THAT ALL EXIT PATHS ATTEMPT TO EXECUTE HEAD-PARKING ROUTINE
; IF OPERATING ON A SCSI DRIVE.
;
DISKWARD_HO
               MOVE.W  #0,VOLUME_OUT        ; while here - let there be silence.
;
               MOVE    DISK_OP_CODE,D0      ;WHAT ZUPP.
               BTST    #ALT_BIT,D0          ;ACCESSING ALTERNATE FUNCTION LIST?
               BNE     DO_ALT_FUN           ;BRANCH IF YES - D1 CONTAINS ALTERNATE FUNCTION CODE.
;
                                            ;PROCEEDING ON NORMAL HIGH-LEVEL ENTRY PATH - SO FAR -
               MOVE.L  #COURTESY_SCREEN,A1  ;JUST FOR APPEARANCE'S SAKE, DO SOMETHING.
                ABS_LONG
               JSR     DISP_SCREEN
                ABS_SHORT
;
WORLD_O_DISKS
               BSR     DISK_DEPPIDY         ;OK, THEN.  NORMAL! THEN.  DELEGATE ALL DETAILZ.
;
DISK_HO_RETURN
               BNE.S   DISK_HO_ERROR        ;ABORT IF RETURN WITH ERROR STATUS, DISPLAY MESSAGE.
               BCS.S   DISK_HO_ABORT        ;EXIT AND RESTORE SUBFUNCTION SCREEN IF USER SAID QUIT.
                                            ;ELSE - DON'T GO AWAY MAD, JUST GO AWAY.
;
;
DISK_HO_EXIT
               TST     DRIVE_SEL            ;WAS THIS A SCSI THING WE DID?
               BMI.S   DISK_HO_EX_10        ;BRANCH IF NOT, WE GONE DAD.
               BSR     PARK_THE_HEADS       ;ELSE, WE GONE ONCE WE PARK THE DRIVE HEADS.
               BNE.S   DISK_HO_ERROR        ;SKOOT OVER IF WE HAD A PROBLEM PARKING, ELSE ....
DISK_HO_EX_10
               CLR     D0                   ;ALL-CLEAR UPON EXIT.
               RTS
;
;
;
DISK_HO_ERROR
               CMP.B   #SCSICODEOFFS,D0     ;ERROR - DO WE HAVE A SPECIAL SCSI ERROR CODE HERE?
               BCS.S   DISK_HO_ER_10        ;BRANCH IF NOT, DO GENERIC HANDLING (MESSAGE, EXIT).
               BSR     SCSI_ERROR           ;ELSE, DO WHAT WE MUST FOR THIS ERROR CODE.
               BSR     PARK_THE_HEADS       ;AND HAVING DONE SO, PARK THE HEADS BEFORE LEAVING.
               BRA.S   DISK_HO_ER_Z0        ;AND, EXIT WITH Z FLAG FALSE DESPITE PARKING SUCCESS.
DISK_HO_ER_10
               ST      ABORT_FLAG           ;WE GAVE UP (DON'T KEEP FLOPPY DRIVE SPINNING).
               BSR     GET_RESPONSE         ;DISPLAY A MESSAGE PER ERROR CODE IN D0.
               TST     DRIVE_SEL            ;WAS THIS A SCSI THING WE DID?
               BMI.S   DISK_HO_ER_Z0        ;BRANCH IF NOT, WE GONE DAD.
               BSR     PARK_THE_HEADS       ;ELSE, WE GONE ONCE WE PARK THE DRIVE HEADS.
DISK_HO_ER_Z0
               MOVEQ   #GENERIC_ERROR,D0    ;RETURN INTO 440 MAIN SYSTEM OR WHATEVER WITH
               RTS                          ;Z FLAG FALSE (KEEPS ERROR MESSAGE IN LCD).
;
;
;
DISK_HO_ABORT
               MOVE    D0,SWITCH_HIT        ;SET UP SWITCH_HIT VALUE FOR MAIN SYSTEM HANDLING.
               TST     DRIVE_SEL            ;WAS THIS A SCSI THING WE DID?
               BMI.S   DISK_HO_AB_10        ;BRANCH IF NOT, WE GONE DAD.
               BSR     PARK_THE_HEADS       ;ELSE, WE GONE ONCE WE PARK THE DRIVE HEADS.
DISK_HO_AB_10
               MOVEQ   #GENERIC_ERROR,D0    ;RETURN INTO 440 MAIN SYSTEM OR WHATEVER WITH
               RTS                          ;Z FLAG FALSE.
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; THE "DIRTY WORK"-ER CALLED UPON FROM ABOVE TO PERFORM ....
; IT'S DEPPIDY DISK !!!!!   AAIIIGHHHHHH !!!!!
;
DISK_DEPPIDY
               TST     DRIVE_SEL            ;DOES DRIVE_SEL SAY WE ARE TO OPERATE ON FLOPPY DRIVE?
               BPL.S   DISK_DP_20           ;BRANCH IF NOT - SCSI FOR SURE, NO STARTUP PROCEDURE.
               MOVE    DISK_OP_CODE,D1      ;BUT - ACTUALLY TRYING TO RUN SCSI SPECIAL UTILITY?
               BTST    #HD_UTIL_BIT,D1      ;(UTILITY SELECTED INDEPENDENT OF DRIVE_SEL VALUE ....)
               BEQ.S   DISK_DP_10           ;NO - DRIVE_SEL SETTING IS COO, GO FOR FLOPPY DRIVE.
               MOVEQ   #MUST_SEL_SCSI,D0    ;ELSE, TELL USER TO SELECT A SCSI DRIVE FIRST.
               BRA     DISK_DP_EXIT
;
DISK_DP_10
               BSR     START_FLOPPY         ;FLOPPY SYS FUNS START WITH DRIVE STATUS CHECK, RECAL.
               BNE     DISK_DP_EXIT         ;HALT IF FLOPPY DRIVE NOT READY (NO DISK OR WHATEVER).
;
DISK_DP_20
               BSR     READ_DESCRIPTOR      ;LOOK FOR VALID SEQUENTIAL FORMAT ON DISK -
                                            ;RETURNS WITH D0 CLEAR IF IT IS FOUND ....
;
                                            ;DID DESCRIPTOR CHECK, BUT HAVEN'T CHECKED RESULTS -
               MOVE    DISK_OP_CODE,D1      ;RESPONSE DEPENDS ON WHAT WE ARE TRYING TO DO:
               BTST    #HD_UTIL_BIT,D1      ;RUNNING SPECIAL SCSI HARD DISK UTILITY?
               BEQ.S   DISK_DP_30           ;BRANCH IF NOT, GO CHECK OTHER POSSIBILITIES.
;
                                            ;SCSI UTILITIES - GENERALLY NON-FILE-ORIENTED STUFF:
               BTST    #FORMAT_BIT,D1       ;CREATE EMPTY DIRECTORY ON DISK?
               BNE     DISK_DP_D0           ;BRANCH IF YES - SAME TESTS AS FOR FLOPPY FORMATTING.
;
               TST     D0                   ;FOR OTHER SCSI UTILS, EXIT IF DESCRIPTOR NOT VALID.
               BNE     DISK_DP_EXIT
               BTST    #DIR_BIT,D1          ;DESCRIPTOR OK - DOING ALL-BANKS DIRECTORY EXTRACTION?
               BNE     SCSI_ALL_BANKS_DIR   ;BRANCH IF YES, WE GOT NO PROBLEM WITH THAT.
               BTST    #CONTROL_BIT,D1      ;OR, ARE WE TRYING TO SET A NEW DEVICE ID FOR A DRIVE?
               BNE     SET_NEW_SCSI_ID      ;BRANCH IF YAR, AGAIN NOT CARE MUCH ABOUT BANK NUMBER.
               BSR     BANK_SEL_TEST        ;ELSE, CHECK VALIDITY OF SELECTED BANK NUMBER -
               BEQ     SCSI_WRITE_PROTECT   ;IF OKAY, GO FOR ONLY REMAINING UTILITY -
               BRA     DISK_DP_EXIT         ;ELSE - RETURN BANK-NUMBER ERROR CODE IN D0.
;
DISK_DP_30
               BTST    #FORMAT_BIT,D1       ;FORMATTING FLOPPY DISK?
               BNE     DISK_DP_D0           ;BRANCH IF YES.
               TST     D0                   ;OTHERWISE - WAS VALID SEQUENTIAL DESCRIPTOR FOUND?
               BNE     DISK_DP_EXIT         ;BRANCH IF NOT - NO DATA TRANSFERS ALLOWED, PERIOD.
               BSR     BANK_SEL_TEST        ;DESCRIPTOR OK - TEST BANK_SEL AGAINST DRIVE DIR INFO,
               BNE     DISK_DP_EXIT         ;EXIT IF TOO HIGH (NOTE: ERROR ONLY WITH SCSI DRIVE).
               BTST    #LOAD_BIT,D1         ;DOING SOME SORTA LOAD FROM SOME KINDA DISK?
               BNE.S   DISK_DP_70           ;BRANCH IF YES.
               BTST    #DIR_BIT,D1          ;NOT LOADING - WOTABOUT DIRECTORY EXTRACTION?
               BNE.S   DISK_DP_70           ;YOKAY (SORTA LIKE LOADING, ANYWAYS).
;
                                                 ;SAVING OR VERIFYING:
               CMP.L   #30343430H,CUR_MODEL_ID   ;DESCRIPTOR VALID - IS THIS A MODEL 440 DISK?
               BEQ.S   DISK_DP_40                ;BRANCH IF YES -
               MOVEQ   #NOT_440_DISK,D0          ;ELSE HALT - SAVE, VERIFY NOT ALLOWED.
               BRA     DISK_DP_EXIT
DISK_DP_40
               CMP     #REV_1,CUR_FIRMWR_REV     ;IS THIS A REV-1 FORMATTED DISK?
               BEQ.S   DISK_DP_60                ;BRANCH IF YAH, GO SEE ABOUT DISK/BANK TYPE TEST.
               CMP     #REV_0,CUR_FIRMWR_REV     ;NO?  HOW ABOUT REV-0?  (REV HISTORY IN DISKDEFS).
               BNE.S   DISK_DP_50                ;BRANCH IF NOT - WE DON'T KNOW FROM IT.
               BTST    #SAVE_BIT,D1         ;IF REV-0 (FLOPPY ONLY), SAVE OK - WILL BECOME REV-1.
               BNE.S   DISK_DP_A0           ;SAVING, SO GO TO IT (SKIP SCSI BANK-PROTECT TEST).
DISK_DP_50
               MOVEQ   #NEWER_DISK_REV,D0   ;ELSE HALT - SAVE AND/OR VERIFY NOT ALLOWED.
               BRA     DISK_DP_EXIT
DISK_DP_60
               BTST    #SAVE_BIT,D1         ;ARE WE SAVING?
               BNE.S   DISK_DP_98           ;BRANCH IF YES, PROCEED - DISK/BANK TYPE TESTED LATER.
               BRA.S   DISK_DP_90           ;ELSE, VERIFYING - MAKE SURE SOMETHING'S ON FILE HERE.
;
;
;
DISK_DP_70
                                                 ;READING/LOADING FROM DISK:
               CMP.L   #30343430H,CUR_MODEL_ID   ;IS THIS A MODEL 440 DISK?
               BNE.S   DISK_DP_B0                ;BRANCH IF NOT, ASSUME MODEL 2000/2002 DISK -
                                                 ;ONLY OTHER TYPE WHICH PASSES OUR DESCRIPTOR TEST.
;
DISK_DP_80
               CMP     #REV_1,CUR_FIRMWR_REV     ;IS THIS A REV-1 FORMATTED DISK?
               BEQ.S   DISK_DP_90                ;BRANCH IF YAH, SEE IF ANYTHING IS SAVED ON IT.
               CMP     #REV_0,CUR_FIRMWR_REV     ;AH - REV-0 (FLOPPY) IS OK TO LOAD, ALSO -
               BEQ.S   DISK_DP_90                ;BRANCH IF HE REV-0 BE.
               MOVEQ   #NEWER_DISK_REV,D0        ;ELSE DISPLAY WARNING, ALLOW USER TO OVERRIDE IT.
               BSR     QUERY
               BNE.S   DISK_DP_EXIT         ;EXIT IF DRIVE STATUS ERROR, DISPLAY ERROR MESSAGE.
               BCS.S   DISK_DP_EXIT         ;EXIT IF USER SAID QUIT.
;
DISK_DP_90
               CMP     #-1,CUR_FILE_TYPE    ;READ OR VERIFY - IS ANYTHING ON DISK?
               BNE.S   DISK_DP_A0           ;BRANCH IF YES, WE'LL TRY OUR LUCK -
               MOVEQ   #DATA_NOT_PRES,D0    ;ELSE, HALT WITH ERROR MESSAGE.
               BRA.S   DISK_DP_EXIT         ;STOP RIGHT THERE - TOO MUCH CRASH POTENTIAL
                                            ;IF WE LOAD FROM BOGUS DISK.
;
DISK_DP_98
               TST     CUR_WRT_PROT         ;SAVING - LOOK FOR SCSI BANK WRITE-PROTECT SWITCH.
               BEQ.S   DISK_DP_A0           ;BRANCH IF NOT SET (NOTE: THIS TEST DOES NOT CATCH
                                            ;FLOPPY DISK WRITE-PROTECT), KEEP GOING.
               MOVEQ   #PROTECTD_BANK,D0    ;ELSE TELL 'EM NO CAN DO.
               BRA.S   DISK_DP_EXIT
;
DISK_DP_A0
               BSR     TRANSFER             ;ALL KLEER - DO THE REQUESTED TRANSFER.
               BRA.S   DISK_DP_EXIT         ;RETURN CODES CHECKED BACK IN DISKWARD_HO.
;
;
;
DISK_DP_B0
               MOVE    DISK_OP_CODE,D1      ;WE GOT A 2000 DISK IN FLOPPY DRIVE -
               AND     #LOAD_MASK+SAM_MASK+MOV_ALL_MASK,D1      ;ONLY "LOAD ALL SOUNDS" ALLOWED -
               CMP     #LOAD_MASK+SAM_MASK+MOV_ALL_MASK,D1      ;DISREGARD KIT/CONFIG QUALIFIERS -
               BEQ.S   DISK_DP_C0           ;BRANCH IF THAT'S WHAT WE WERE DOING,
               MOVEQ   #NOT_440_DISK,D0     ;ELSE TERMINATE WITH ERROR MESSAGE.
               BRA.S   DISK_DP_EXIT
DISK_DP_C0
               BSR     TRANSFER_2000        ;ALL KLEER - DO THE REQUESTED TRANSFER FROM 2000 DISK.
               BRA.S   DISK_DP_EXIT         ;RETURN CODES CHECKED BACK IN DISKWARD_HO.
;
;
;
DISK_DP_D0
               CMP.B   #SCSICODEOFFS,D0     ;FORMATTING - LOOK FOR SCSI DIAGNOSTIC ERROR CODE.
               BCS.S   DISK_DP_D4           ;BRANCH IF WE DON'T HAVE ONE, KEEP GOING.
               TST.B   D0                   ;IF SCSI ERROR, CAN GO NO FURTHER - RESTORE CONDITION
               BRA.S   DISK_DP_EXIT         ;CODE BITS AND EXIT AT ONCE.
DISK_DP_D4
               CMP.B   #SELECT_FAILED,D0    ;ONE MORE SCSI ERROR CODE (NOT SO DIAGNOSTIC).
               BNE.S   DISK_DP_E0           ;BRANCH IF NOT THAT - KEEP GOING.
               TST     D0                   ;ELSE, REFRESH Z FLAG (FALSE),
               BRA.S   DISK_DP_EXIT         ;GIT AWAY.
DISK_DP_E0
               CMP.B   #NO_FORMAT,D0        ;SSSSSSO - WAS ANY FORMAT FOUND ON DISK?
               BEQ.S   DISK_DP_F0           ;BRANCH IF NOT, GO STRAIGHT INTO FORMATTING.
               MOVEQ   #NOT_BLANK,D0        ;ELSE NOTIFY USER OF NON-BLANK DISK BEFORE PROCEEDING -
                                            ;DON'T BOTHER MR. USER WITH ANYTHING MORE SPECIFIC.
               BSR     QUERY                ;POST MESSAGE, GET USER RESPONSE.
               BNE.S   DISK_DP_EXIT         ;HALT IF DRIVE STATUS ERROR, DISPLAY ERROR MESSAGE.
               BCS.S   DISK_DP_EXIT         ;EXIT WITH ABORT MESSAGE IF USER SAID QUIT.
DISK_DP_F0
               BSR     FORMAT_DISK          ;JUST GO FORMAT THE SUCKER.
                                            ;RETURN CODES CHECKED BACK IN DISKWARD_HO.
;
DISK_DP_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; EXECUTE A COMMAND FROM ALTERNATE FUNCTIONS LIST -
; THE "SIDE ENTRANCE" TO THE DISK SYSTEM.
; ALTERNATE FUNCTION CODE IS IN D1.
;
DO_ALT_FUN
;
;23MAR               CMP     #CHECK_FLOPPY,D1
;23MAR               BEQ     CHECK_DRIVE          ;QUIETLY CHECK FOR DISK IN FLOPPY DRIVE.
;
               CMP     #SCSI_RESET,D1
               BNE.S   DO_ALTFUN_EXIT       ;EXIT WITHOUT ACTION IF CODE NOT RECOGNIZED.
;
               BSR     SCSI_MULTIPLE_CONF   ;REINIT DATAFRAME INTERNAL CONTROLLER(S), PARK HEADS -
                                            ;WE COME IN THIS WAY TO SIDESTEP DESCRIPTOR READ.
               BEQ.S   DO_ALTFUN_EXIT       ;EXIT DIRECTLY IF ALL IS COOL ....
                                            ;ELSE, FALL THROUGH INTO ERROR-HANDLING SHIT.
;
;
DO_ALTFUN_ERR
               CMP.B   #SCSICODEOFFS,D0     ;ERROR - DO WE HAVE A SPECIAL SCSI ERROR CODE HERE?
               BCS.S   DO_ALTERR_10         ;BRANCH IF NOT, DO GENERIC HANDLING (MESSAGE, EXIT).
               BSR     SCSI_ERROR           ;ELSE, DO WHAT WE MUST FOR THIS ERROR CODE.
               BRA.S   DO_ALTERR_Z0         ;AND, EXIT WITH Z FLAG FALSE.
DO_ALTERR_10
               ST      ABORT_FLAG           ;WE GAVE UP (DON'T KEEP FLOPPY DRIVE SPINNING).
               BSR.S   GET_RESPONSE         ;DISPLAY A MESSAGE PER ERROR CODE IN D0.
DO_ALTERR_Z0
               MOVEQ   #GENERIC_ERROR,D0    ;RETURN INTO 440 MAIN SYSTEM OR WHATEVER WITH
               RTS                          ;Z FLAG FALSE (KEEPS ERROR MESSAGE IN LCD).
;
DO_ALTFUN_EXIT
               CLR     D0                   ;FOR UNRECOGNIZED FUNCTION CODE, RETURN ZERO CODE -
               RTS                          ;KEEP THINGS SMOOTH AND MELLOW.
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; DISPLAY AN ERROR MESSAGE - D0 CONTAINS CODE WHICH DETERMINES MESSAGE.
;
; NORMALLY D0 IS NOT = 0 WHEN WE GET HERE, BUT THERE IS A
; SPECIAL ESCAPE CASE:  IF D0 = 0, WE RETURN WITHOUT ACTION -
; THIS ALLOWS A SUCCESSFUL DISK OPERATION TO LEAVE ITS OWN MESSAGE IN
; LCD UPON COMPLETION BY EXITING VIA FATAL ERROR PATH, WHICH INSTRUCTS
; MAIN SYSTEM NOT TO WRITE OVER WHAT WE LEFT IN THE LCD (DISK ROUTINE
; DOES THIS BY RETURNING FROM DISK_DEPPIDY WITH Z FLAG FALSE, D0 = 0).
;
; IF ABORT_FLAG SET, WE CAME HERE ON A FATAL ERROR -
; WE DISPLAY THE MESSAGE AND SPLIT, ALLOWING DRIVE TO STOP SPINNING.
;
; ELSE, WE'RE QUERYING THE USER FOR GO/NO-GO RESPONSE TO A CONDITION
; WHICH REQUIRES A DECISION WHETHER OR NOT TO GO ON -
; IN THIS CASE, WE DISPLAY THE MESSAGE, THEN FALL INTO A LOOP IN WHICH:
;   * IF USING FLOPPY DRIVE (DRIVE_SEL = -1), DRIVE IS KEPT READY
;     (I.E., SPINNING) VIA PERIODIC STATUS CHECKING.
;   * "ENTER" LED FLASHES, HOPEFULLY DIRECTING USER'S ATTENTION TO
;     THAT SWITCH.
;   * ERROR MESSAGE ALTERNATES PERIODICALLY WITH A PROMPT MESSAGE
;     INDICATING THAT THE USER MUST HIT "ENTER" SWITCH TO CONTINUE.
;
; WE EXIT FROM THIS LOOP IN ERROR STATUS (Z FLAG FALSE) IF FLOPPY STATUS
; CHECK SHOWS DRIVE IS NOT READY (MOST LIKELY, DISK WAS REMOVED) -
; D0 CONTAINS THE ERROR CODE FOR "NO DISK IN DRIVE".
;
; ALTERNATIVELY, WE EXIT WHEN ANY SWITCH IS HIT, WITH Z FLAG TRUE AND
; SWITCH NUMBER IN D0 (NOTE THAT THIS IS THE ONLY PATH OF EXIT IF WE ARE
; USING A SCSI HARD DISK, SINCE NO PERIODIC DRIVE STATUS CHECK IS DONE).
;
; Note that interrupts are enabled while here (if waiting for user response)
; to allow realtime interrupt to be used for timeout functions -
; All interrupts are left disabled upon exit.
;
;
GET_RESPONSE
               TST     D0                   ;SPECIAL ESCAPE CASE?
               BEQ     GET_RESP_EXIT        ;U-BET, WEBEGONE.
               SUBQ    #1,D0                ;ELSE - CONVERT ERROR CODE INTO ERROR-STRING INDEX.
               LSL     #5,D0
               ADD.L   #CODED_MESSAGES,D0
               TST.B   ABORT_FLAG           ;USER QUERY OR FATAL ERROR?
               BEQ.S   GENL_GET_RESP        ;BRANCH IF USER QUERY, WE'S HEADIN' FER TH' BIG TIME.
               MOVE.L  D0,A1                ;ELSE, JUST DISPLAY MESSAGE ONCE AND SPLIT.
                ABS_LONG
               JMP     DISP_SCREEN
                ABS_SHORT
;
;
;
; THIS ENTRY POINT USED FOR ALTERNATIVE QUERY ROUTINE -
; D0.L CONTAINS POINTER TO MESSAGE TEXT, RATHER THAN AN ERROR CODE.
; NOTE THAT THIS TEXT MUST BE SOMEWHERE OTHER THAN IN SCREEN_BUFFER!
;
GENL_GET_RESP
               MOVE.L  D0,DISK_MSG_PTR      ;SAVE POINTER TO ERROR MESSAGE TEXT.
               SF      SWITCH_BLOCK         ;SET AS IF ALL SWITCHES ARE OPEN,
;890313                ABS_LONG
;890313               JSR     GLANCE_AT_SWITCHES   ;THEN DO A QUICK REALITY CHECK -
;890313                ABS_SHORT
;890313               BEQ.S   GET_RESP_20          ;BRANCH IF ALL SWITCHES OPEN, WE'RE COOL.
               MOVEQ   #1,D0                ; quick now - any switches closed?
               .ALONG
               JSR     SCAN_SWITCHES
               .AWORD
               BMI.S   GET_RESP_20          ; branch if all open, continue.
               ST      SWITCH_BLOCK         ;ELSE, BLOCK RESPONSE TO NEW CLOSURES UNTIL ALL OPEN.
;
GET_RESP_20
               TST     DRIVE_SEL            ;ARE WE OPERATING ON FLOPPY DRIVE?
               BPL.S   GET_RESP_40          ;BRANCH IF NOT, SKIP FLOPPY DISK DRIVE SYNCH-UP.
               BSR     CHECK_SPEED          ;USE CHECK_SPEED TO SYNCH LOOP TO DRIVE INDEX PULSES.
               BNE     GET_RESP_EXIT        ;RETURN ERROR CODE IF DRIVE NOT READY.
;
GET_RESP_40
               SF      DISK_MSG_STAT        ;START THINGS OFF WITH ERROR MESSAGE -
               MOVEQ   #5,D3                ;SWAP MESSAGES EVERY SIXTH STATUS CHECK (0.2 SEC EA).
;
;
                                            ;"THE LOOP."
GET_RESP_60
               MOVE.L  DISK_MSG_PTR,A1      ;FETCH MESSAGE TEXT POINTER,
               TST.B   DISK_MSG_STAT        ;SEE IF WE BE DISPLAYING IT THIS TIME AROUND -
               BEQ.S   GET_RESP_64          ;YES, WE BE -
               MOVE.L  #HIT_ENT_SW_SCRN,A1  ;ELSE, DISPLAY "ENTER" SWITCH PROMPT SCREEN.
GET_RESP_64
               DBRA    D3,GET_RESP_90       ;BRANCH IF NOT READY TO SWAP MESSAGES FOR NEXT TIME.
               MOVEQ   #5,D3                ;TIME (NEXT TIME) - RESTART SWAP COUNTDOWN,
               NOT.B   DISK_MSG_STAT        ;TOGGLE THE MESSAGE-SELECT FLAG.
GET_RESP_90
                ABS_LONG
               JSR     DISP_SCREEN          ;DISPLAY CURRENT MESSAGE.
                ABS_SHORT
;
;890313               MOVE.W  #GLANCE_TIME,FLASH_TIME   ;NUMBER OF TIMES WE GLANCE_AT_SWITCHES IN BETWEEN
;890313                                                 ;DOING DRIVE STATUS CHECKS - SUB-LOOP IS TIMED
;890313                                                 ;TO COINCIDE WITH AN INDEX PULSE FROM DISK DRIVE.
;
               MOVE    LED_OUT_STAT,D0      ;TURN "ENTER" LED ON NOW - OFF IT AT HALF GLANCE_TIME.
               BSET    #11,D0
               NOT     D0
                ABS_LONG
               MOVE    D0,LED_OUTPUT
                ABS_SHORT
;
               MOVE.W  #2000H,SR            ; enable ints for timeout use.
               MOVE.W  REAL_TIME,FLASH_TIME ; note time of entry into loop.
;
GET_RESP_A0
;
;890313                ABS_LONG
;890313               JSR     GLANCE_AT_SWITCHES   ;ALL OPEN OR NOT ALL OPEN?
;890313                ABS_SHORT
;890313               BNE.S   GET_RESP_C0          ;BRANCH IF ONE OR MORE SWITCHES CLOSED.
               MOVEQ   #1,D0                ; all switches open, or no?
               .ALONG
               JSR     SCAN_SWITCHES
               .AWORD
               BPL.S   GET_RESP_C0          ; branch if any switch is closed.
               SF      SWITCH_BLOCK         ;ALL OPEN, SO REMOVE NEW SWITCH BLOCK IF STILL THERE.
               BRA.S   GET_RESP_E0
GET_RESP_C0
               TST.B   SWITCH_BLOCK         ;ARE NEW SWITCHES BLOCKED FROM RECOGNITION?
               BEQ.S   GET_RESP_Q0          ;BRANCH IF NOT - EXIT.
;
GET_RESP_E0
;
;890313               SUBQ    #1,FLASH_TIME        ;HAVE WE DONE THIS ENOUGH TIMES YET?
;890313               BEQ.S   GET_RESP_G0          ;BRANCH IF YES, GO CHECK DRIVE STATUS.
;890313               CMP.W   #GLANCE_TIME/2,FLASH_TIME      ;ELSE - TIME FOR "ENTER" LED TO GO OFF?
;890313               BNE     GET_RESP_A0                    ;NO - NOT TIME.
               MOVE.W  REAL_TIME,D0         ; check timeout -
               SUB.W   FLASH_TIME,D0
               CMPI.W  #185,D0              ; expect a full disk rotation soon?
               BCC.S   GET_RESP_G0          ; br if yes, go see where disk is.
               CMPI.W  #92,D0               ; not yet - time to kill ENTER LED?
               BCS     GET_RESP_A0          ; nope, he may stay on.
               MOVE    LED_OUT_STAT,D0      ;YES - IT'S TIME - OFF HE GOES.
               BCLR    #11,D0
               NOT     D0
                ABS_LONG
               MOVE    D0,LED_OUTPUT
                ABS_SHORT
               BRA     GET_RESP_A0          ;CONTINUE WITH SECOND HALF.
;
GET_RESP_G0
                                            ; end of message/flash cycle:
               MOVE.W  #2700H,SR            ; disable ints now, in case we exit.
               TST     DRIVE_SEL            ;ARE WE OPERATING ON FLOPPY DRIVE?
               BPL     GET_RESP_60          ;BRANCH IF NOT, SKIP FLOPPY DISK DRIVE SYNCH-UP.
               BSR     INDEX_SYNC           ;ELSE, SHOULD BE ABOUT TIME FOR INDEX PULSE - GO SEE.
               BNE.S   GET_RESP_EXIT        ;EXIT IF WE DIDN'T SEE ONE IN TIME (DISK REMOVED?) -
                                            ;D0 CONTAINS DRIVE STATUS ERROR CODE.
               BRA     GET_RESP_60          ;DRIVE STILL READY - STAY IN LOOP.
;
GET_RESP_Q0
;
;890313               CLR     D0                   ;NEW SWITCH RECOGNIZED - GO GET SWITCH NUMBER INTO D0.
;890313                ABS_LONG
;890313               JSR     SCAN_SWITCHES
;890313                ABS_SHORT
                                            ; D0.W holds code of closed switch -
               MOVE.W  #2700H,SR            ; disable ints (system expects it),
               CMP.W   D0,D0                ;SET Z FLAG TRUE TO INDICATE NO-ERROR STATUS.
;
GET_RESP_EXIT
               RTS
;
;890313;
;890313GLANCE_TIME    EQU     4222                 ;SHOOTING FOR 190 MSEC HERE.
;890313;
;
;
; THE FOLLOWING MESSAGE SCREENS CORRESPOND ONE-TO-ONE WITH THE CLASS OF
; DISK SYSTEM ERROR CODES FOR WHICH A SPECIFIC ERROR OR WARNING MESSAGE
; IS APPROPRIATE AND NO FURTHER DIAGNOSTIC OR OTHER INFO IS NEEDED.
; COMMENT ALONGSIDE EACH INDICATES LABEL USED FOR ITS ERROR CODE VALUE,
; AS WELL AS THE PRECISE CONDITIONS UNDER WHICH EACH MESSAGE APPEARS.
; FLOPPY AND SCSI MESSAGES ARE INTERMIXED, SOME MESSAGES APPLY TO BOTH.
; ORDER OF MESSAGES IN TABLE IS ARBITRARY, BUT VALUES DEFINED FOR ERROR
; CODES MUST FOLLOW THE ORDER OF THE MESSAGES IN THE TABLE.
;
CODED_MESSAGES
               ASC     "DISK CONTROLLER "   ;FDC_IS_HUNG -      CANNOT OBTAIN FDC NOT-BUSY STATUS
               ASC     "NOT RESPONDING  "   ;                   FOLLOWING FORCE_INTERRUPT COMMAND.
;
               ASC     "NO DISK IN DRIVE"   ;NO_DISK -          TIMED OUT AWAITING DRQ TRUE OR
               ASC     "                "   ;                   INDEX BIT STATE CHANGE FROM FDC.
;
               ASC     "  UNSUCCESSFUL  "   ;SEEK_ERROR -       FDC TIMEOUT WHILE RECALIBRATING OR
               ASC     "   TRACK SEEK   "   ;                   SEEKING, OR TRACK 00 NOT DETECTED.
;
               ASC     "SORRY - DISK IS "   ;PROTECTD_DISK -    FLOPPY DISK WRITE-PROTECT TAB SET.
               ASC     "WRITE-PROTECTED "   ;
;
               ASC     "SORRY - BANK IS "   ;PROTECTD_BANK -    WRITE-PROTECT SWITCH SET IN BANK
               ASC     "WRITE-PROTECTED "   ;                   DESCRIPTOR ON SCSI HARD DISK.
;
               ASC     "FORMATTING ERROR"   ;FORMAT_INCMPLT -   INDEX PULSE DETECTED BEFORE FLOPPY
               ASC     "PLEASE TRY AGAIN"   ;                   DISK TRACK COMPLETELY FORMATTED.
;
               ASC     "DISK MOTOR SPEED"   ;OVER_SPEED -       FLOPPY DRIVE INDEX PULSES COMING IN
               ASC     "ABOVE TOLERANCE "   ;                   TOO CLOSE TOGETHER.
;
               ASC     "DISK MOTOR SPEED"   ;UNDER_SPEED -      FLOPPY DRIVE INDEX PULSES ARE BEING
               ASC     "BELOW TOLERANCE "   ;                   RECEIVED, BUT ARE TOO FAR APART.
;
               ASC     "HEY! IS THE DISK"   ;FORMAT_OVRUN -     INDEX PULSE NOT SEEN WHEN EXPECTED
               ASC     "MISSING OR WHAT?"   ;                   DURING FLOPPY TRACK FORMATTING.
;
               ASC     "   NO FORMAT    "   ;NO_FORMAT -        NO SECTOR ID SEEN ON FLOPPY DISK
               ASC     "DETECTED ON DISK"   ;                   TRACK BEING READ.
;
               ASC     "  CORRUPTED OR  "   ;INVAL_FORMAT -     DATA ON DISK DOES NOT CONFORM TO
               ASC     " UNKNOWN FORMAT "   ;                   SEQUENTIAL DISK DATA STRUCTURE, OR
                                            ;                   FLOPPY TRACK/SIDE NUMBER MISMATCH.
;
               ASC     " ** WARNING! ** "   ;NOT_BLANK -        SEQUENTIAL OR OTHER FORMAT DETECTED
               ASC     " DISK NOT BLANK "   ;                   ON DISK BY PRE-FORMATTING CHECK.
;
               ASC     " DATA ERROR OR  "   ;GENERIC_ERROR -    BLANKET CODE FOR MOST LOW LEVEL
               ASC     "  MEDIA DEFECT  "   ;                   DATA ERROR CONDITIONS FROM FDC.
;
               ASC     "  DATA COMPARE  "   ;VERIFY_ERR -       DATA COMPARE ERROR DURING ANY
               ASC     "     ERROR      "   ;                   VERIFY OPERATION.
;
               ASC     "NOT ENOUGH ROOM "   ;NO_ROOM -          INSUFFICIENT SPACE FOR REQUESTED
               ASC     "   IN MEMORY    "   ;                   ONE-SOUND OR ONE-SEQUENCE LOAD.
;
               ASC     "NOT ALLOWED - NO"   ;NOT_ALLOWED -      OPERATION OTHER THAN ALL SOUNDS OR
               ASC     "MAIN FILE SAVED "   ;                   ALL SEQS ON EMPTY DISK/BANK.
;
               ASC     "SOURCE SOUND NOT"   ;SOURCE_DELETED -   ATTEMPTED ONE-SOUND LOAD OF SOUND
               ASC     "PRESENT ON DISK "   ;                   NOT PRESENT ON DISK OR IN BANK.
;
               ASC     "  TARGET SOUND  "   ;TARGET_EXISTS -    ATTEMPTED ONE-SOUND LOAD OVER SOUND
               ASC     "  IS NOT EMPTY  "   ;                   CURRENTLY PRESENT IN MEMORY.
;
               ASC     " DISK FORMATTED "   ;NEWER_DISK_REV -   DISK FIRMWARE REV IS HIGHER THAN
               ASC     "FOR NEWER OP SYS"   ;                   THAT OF OPERATING FIRMWARE IN USE.
;
               ASC     " DISK IS NOT A  "   ;NOT_440_DISK -     DISK HAS VALID SEQUENTIAL FORMAT
               ASC     "STUDIO 440 DISK "   ;                   FROM PRODUCT OTHER THAN STUDIO 440.
;
               ASC     " ** WARNING! ** "   ;FILE_NOT_EMPTY -   WARNING OF SAVE OVER EXISTING
               ASC     " FILE NOT EMPTY "   ;                   FILE(S) WITH SAME TYPE OF DATA.
;
               ASC     " ** WARNING! ** "   ;SND_FILE_HERE -    WARNING OF SAVE OVER EXISTING SOUND
               ASC     "SOUND FILE HERE "   ;                   FILE(S) WITH ANOTHER TYPE OF DATA.
;
               ASC     " ** WARNING! ** "   ;SEQ_FILE_HERE -    WARNING OF SAVE OVER EXISTING SEQ
               ASC     " SEQ FILE HERE  "   ;                   FILE(S) WITH ANOTHER TYPE OF DATA.
;
               ASC     " ** WARNING! ** "   ;OTH_FILE_HERE -    WARNING OF SAVE OVER EXISTING OTHER
               ASC     "OTHER FILE HERE "   ;                   FILE(S) WITH ANOTHER TYPE OF DATA.
;
               ASC     "WRONG FILE TYPE "   ;DATA_NOT_PRES -    LOAD/VERIFY FROM EMPTY FILE OR FROM
               ASC     " OR EMPTY FILE  "   ;                   WRONG FILE TYPE FOR DATA REQUESTED.
;
               ASC     " SORRY - SOURCE "   ;SOURCE_SEQ_DEL -   ATTEMPTED ONE-SEQUENCE LOAD OF
               ASC     " SEQUENCE EMPTY "   ;                   EMPTY SEQUENCE FROM DISK.
;
               ASC     "TARGET SEQUENCE "   ;TARGET_SEQ_EST -   WARNING OF ONE-SEQUENCE LOAD INTO
               ASC     " IS NOT EMPTY - "   ;                   SEQUENCE WHICH IS NOT EMPTY.
;
               ASC     " UNRECOVERABLE  "   ;UNRECOVERABLE -    SEQUENCE DATA READ ERROR RECOVERY
               ASC     "  READ ERROR    "   ;                   ATTEMPT UNSUCCESSFUL (FLOPPY DISK).
;
               ASC     "SEQUENCE MEMORY "   ;MEM_ALLOC_ERR -    REACHED END OF FREE MEMORY STRING
               ASC     "ALLOCATION ERROR"   ;                   UNEXPECTEDLY DURING ONE-SEQ LOAD.
;
               ASC     "INVALID DATA IN "   ;BAD_SEQ_DIR -      ONE-SEQ LOAD: SOURCE SEQUENCE START
               ASC     " SEQ DIRECTORY  "   ;                   BLOCK INDEX ON DISK IS INVALID.
;
               ASC     "  SCSI DEVICE   "   ;SELECT_FAILED -    TARGET SCSI DEVICE DID NOT RESPOND
               ASC     " NOT RESPONDING "   ;                   TO SELECTION ATTEMPT.
;
               ASC     "  ERROR - MUST  "   ;MUST_SEL_SCSI -    ATTEMPT TO EXECUTE SCSI DISK UTIL
               ASC     "SELECT SCSI DISK"   ;                   WITH DRIVE_SEL = -1 (FLOPPY DRIVE).
;
               ASC     "  NO SUCH BANK  "   ;NO_SUCH_BANK -     ATTEMPT TO ACCESS BANK WITH NUMBER
               ASC     "  ON THIS DRIVE "   ;                   TOO HIGH FOR EXISTING DIRECTORY.
;
               ASC     "MUST SET JUMPERS"   ;SET_JUMPERS -      ATTEMPT TO USE SCSI ID CHANGE UTIL
               ASC     "  INSIDE DRIVE  "   ;                   ON OLDER DATAFRAME WITH ID JUMPERS.
;
               ASC     "ERROR - NEW SCSI"   ;SCSI_ID_USED -     ATTEMPT TO CHANGE DEVICE SCSI ID TO
               ASC     "ID ALREADY USED "   ;                   ONE ALREADY USED BY ANOTHER DEVICE.
;
;
;
; OTHER SCREENS, REFERENCED DIRECTLY BY NAME -
; THESE ARE THE SECONDARY MESSAGE SCREENS.
;
COURTESY_SCREEN
               ASC     "Accessing disk -"   ;SERVICE WITH A GENERAL LACK OF IMAGINATION ....
               ASC     "                "
HIT_ENT_SW_SCRN
               ASC     "HIT ENTER SWITCH"
               ASC     "  TO CONTINUE   "
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;
;
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; DISPLAY MESSAGE PER CODE IN D0, GET USER RESPONSE -
; IF USING FLOPPY DISK DRIVE, KEEP IT READY (SPINNING) WHILE WAITING.
;
; WHEN A SWITCH IS HIT, RETURNS WITH:
;  -  Z FLAG TRUE, CARRY FLAG FALSE IF RESPONSE IS "ENTER" SWITCH -
;     AND D0 CONTAINS 0-RELATIVE SWITCH NUMBER FOR "ENTER" SWITCH.
;     GENERALLY IMPLIES "IGNORE THE ERROR AND CONTINUE WITH OPERATION".
;  -  Z FLAG AND CARRY FLAG TRUE IF ANY OTHER SWITCH IS HIT -
;     AND D0 CONTAINS 1-RELATIVE SWITCH_HIT VALUE FOR THE HIT SWITCH.
;     GENERALLY IMPLIES "FORGET IT, LET'S ABORT THE OPERATION."
;
; RETURNS Z FLAG FALSE, ERROR CODE IN D0 IF DRIVE STATUS ERROR OCCURS
; (E.G., IF USER RESPONDS BY REMOVING FLOPPY DISK FROM DRIVE).
;
QUERY
               SF      ABORT_FLAG           ;GET_RESPONSE WILL KEEP DRIVE READY WHILE WAITING.
               BSR     GET_RESPONSE
               BNE.S   QUERY_EXIT           ;ABORT WITH Z FLAG FALSE IF DRIVE STATUS ERROR.
QUERY_10
               CMP     #39,D0               ;WAS "ENTER" SWITCH HIT?
               BEQ.S   QUERY_EXIT           ;BRANCH IF YES, ALL CPU FLAGS CORRECTLY SET.
               ADDQ    #1,D0                ;ELSE, CONVERT SWITCH NUMBER TO SWITCH_HIT VALUE,
               OR      #5,CCR               ;SET Z AND CARRY FLAGS TRUE FOR OPERATION ABORT.
QUERY_EXIT
               RTS
;
;
;
; ALTERNATE VERSION OF USER QUERY ROUTINE -
; IT IS DIFFERENT FROM THE NORMAL QUERY ROUTINE IN THAT, UPON ENTRY,
; D0.L POINTS TO MESSAGE TEXT RATHER THAN CONTAINING AN ERROR CODE
; FROM WHICH THE MESSAGE TEXT IS DERIVED.
; NOTE THAT THIS TEXT MUST BE SOMEWHERE OTHER THAN IN SCREEN_BUFFER!
; ALSO (DETAIL) BYPASSES THE ABORT_FLAG TEST IN GET_RESPONSE,
; HENCE DOES NOT ALTER THE STATE OF ABORT_FLAG.
; OTHER BEHAVIOR AND RETURN CONDITIONS ARE IDENTICAL TO NORMAL QUERY.
;
ALT_QUERY
               BSR     GENL_GET_RESP
               BRA     QUERY_10
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; ERROR HANDLER FOR SCSI BUS ERROR CONDITIONS -
; USED WHERE THE "ONE CODE, ONE SCREEN" REPORTING SYSTEM IS INADEQUATE.
; COME HERE WITH SCSI ERROR CODE IN D0 - WE MAY CHECK CUR_SCSI_STAT,
; CUR_SCSI_MSG ALSO - FOR CHECK_CONDITION STATUS, WE MAY EVEN ISSUE
; ANOTHER COMMAND TO THE TARGET DEVICE (REQUEST_SENSE, TO LEARN WHAT THE
; PROBLEM WAS).
; AT PRESENT THIS IS PRIMARILY A DIAGNOSTIC-ORIENTED HANDLER TO ASSIST
; IN SYSTEM DEVELOPMENT - IT PROVIDES MORE INFORMATION THAN MOST USERS
; WILL EVER WANT TO SEE, IN A FORM THEY CAN NEVER HOPE TO UNDERSTAND.
; SINCE IT IS USUALLY LAST THING THAT HAPPENS, NO REGISTER-SAVE SPEC'D.
;
; 921008-02:01pm
; status_error handling has been slightly modified to allow 
; commonly-occurring syquest errors (drive not ready, write protect)
; to appear in english on the display when they occur.
;
;
;
SCSI_ERROR
               MOVE    D0,D1                ;COPY ERROR CODE TO SET POINTER TO ERROR MESSAGE.
               SUB     #SCSICODEOFFS,D1     ;SUBTRACT OFFSET FOR SCSI ERROR CODES.
               LSL     #5,D1                ;MULTIPLY - 32 BYTES PER SCREEN.
               MOVE.L  #SCSI_ERR_SCREENS,A1 ;SET POINTER TO BLOCK OF ERROR MESSAGE SCREENS,
               ADD     D1,A1                ;ADD OFFSET TO GET THE ONE WE WANT.
                ABS_LONG
               JSR     WRITE_SCREEN         ;BASIC ERROR MESSAGE TEXT OUT TO SCREEN_BUFFER.
                ABS_SHORT
               MOVE    D0,D2                ;COPY ERROR CODE FOR INSPECTION AFTER DISPLAY WRITE.
               CMP.B   #BUS_NOT_FREE,D0     ;BUS NOT FREE DURING SELECTION ATTEMPT?
               BEQ.S   SCSI_ERR_30          ;BRANCH IF YES - DISPLAY 5380 REGISTER STATUS.
               CMP.B   #STUCK_PHASE,D0      ;ARE WE STUCK IN ONE OF THE BUS PHASES?
               BEQ.S   SCSI_ERR_20          ;BRANCH IF YES, DISPLAY PHASE NAME AND 5380 REGISTERS.
               CMP.B   #REQ_TIMEOUT,D0      ;DO LIKEWISE IF WE TIMED OUT AWAITING /REQ FROM TARGET.
               BNE.S   SCSI_ERR_50          ;IF NOT, GO ON TO CHECK FOR OTHER ERROR CODES.
SCSI_ERR_20
               MOVE.B  CUR_SCSI_PHS,D0      ;FETCH PHASE CODE FOR THE CURRENT PHASE,
               CLR     D1                   ;WRITE PHASE-NAME STRING AT START OF SCREEN_BUFFER.
               BSR     WRITE_PHASE
SCSI_ERR_30
               MOVE.B  SCSI_BS_REG,D0       ;DISPLAY CONTENTS OF CURRENT SCSI BUS STATUS AND
               MOVE    #1302H,D1            ;SCSI BUS-AND-STATUS (5380) REGISTERS.
                ABS_LONG
               JSR     WRITE_HEX_VALUE
                ABS_SHORT
SCSI_ERR_40
               MOVE.B  SCSI_CUR_STAT,D0
               MOVE    #1D02H,D1
                ABS_LONG
               JSR     WRITE_HEX_VALUE
                ABS_SHORT
               CMP.B   #REQ_TIMEOUT,D2      ;DID WE HAVE A /REQ TIMEOUT?
               BNE     SCSI_ERR_X0          ;NO - DISPLAY ERROR MESSAGE, RETURN Z FLAG FALSE.
               AND     #1CH,D0              ;YES - SEE IF SCSI BUS IS NOW IN STATUS PHASE.
               CMP.B   #STATUS_PHASE,D0
               BNE     SCSI_ERR_X0          ;IF NOT, GET OUT OF HERE - DISPLAY MESSAGE AND EXIT.
               CMP.B   CUR_SCSI_PHS,D0      ;IF YES - WERE WE IN THAT PHASE BEFORE TIMEOUT?
               BEQ     SCSI_ERR_X0          ;BRANCH IF YES, DISPLAY ERROR MESSAGE AND EXIT.
                ABS_LONG
               JSR     DISP_BUFFER          ;ELSE, DISPLAY MESSAGE WE'VE BUILT IN SCREEN_BUFFER,
                ABS_SHORT
               BSR     WAIT_TWO_SECS        ;THEN LET MESSAGE SIT IN LCD FOR A BIT.
               MOVE.L  #STAT_PHASE_SCRN,A1  ;TELL 'EM WE SWITCHED UNEXPECTEDLY TO STATUS PHASE,
                ABS_LONG
               JSR     WRITE_SCREEN
                ABS_SHORT
               BRA.S   SCSI_ERR_60          ;THEN GO ON TO READ AND DISPLAY STATUS, ETC.
;
SCSI_ERR_50
               CMP.B   #WRONG_PHASE,D0      ;DID WE GO TO A NEW PHASE OTHER THAN WHAT WE EXPECTED?
               BNE.S   SCSI_ERR_70          ;BRANCH IF NOT THAT -
               MOVE.B  CUR_SCSI_PHS,D0      ;ELSE - WRITE NEW (SPECIAL-GUEST) PHASE NAME,
               CLR     D1
               BSR     WRITE_PHASE
               MOVE.B  LAST_SCSI_PHS,D0     ;ALSO WRITE NAME OF LAST PHASE WE WERE IN.
               MOVEQ   #24,D1
               BSR     WRITE_PHASE
               CMP.B   #STATUS_PHASE,CUR_SCSI_PHS     ;DID WE ENTER STATUS PHASE UNEXPECTEDLY?
               BNE     SCSI_ERR_X0          ;BRANCH IF NOT - DISPLAY MESSAGE, RETURN Z FLAG FALSE -
                                            ;NO REAL IDEA OF WHAT TO DO WITH OTHER PHASES.
SCSI_ERR_60
                ABS_LONG
               JSR     DISP_BUFFER          ;ELSE, DISPLAY MESSAGE WE'VE BUILT IN SCREEN_BUFFER,
                ABS_SHORT
               BSR     WAIT_TWO_SECS        ;THEN LET MESSAGE SIT IN LCD FOR A BIT.
               BSR     FINISH_SCSI_SEQ      ;GET COMPLETION STATUS FROM TARGET.
               BNE     SCSI_ERROR           ;IF NOT "GOOD", BACK TO TOP - DEAL WITH ERROR.
               MOVE.L  #BUT_OKAY_SCRN,A1    ;ELSE, WRITE A SCREEN TO THIS EFFECT,
                ABS_LONG
               JSR     WRITE_SCREEN
                ABS_SHORT
               BRA.S   SCSI_ERR_X0          ;DISPLAY IT AND RETURN Z FLAG FALSE (TO KEEP SCREEN
                                            ;IN LCD).
;
SCSI_ERR_70
               MOVE.B  TARG_STATUS,D0       ;STATUS_ERROR - FETCH TARGET STATUS BYTE,
               MOVE    #0B02H,D1            ;WRITE IT INTO SCREEN_BUFFER.
                ABS_LONG
               JSR     WRITE_HEX_VALUE
                ABS_SHORT
;
;10MAR               CMP.B   #02H,D0              ;DID WE GET "CHECK CONDITION" STATUS?
;10MAR               BNE.S   SCSI_ERR_X0          ;BRANCH IF NOT - DISPLAY SCREEN, RETURN Z FLAG FALSE -
;10MAR                                            ;NO REAL IDEA OF WHAT TO DO WITH OTHER STATUS.
;
                                            ;NO - JUST ASSUME IT WAS CHECK-CONDITION ....
;
                ABS_LONG
               JSR     DISP_BUFFER          ;ELSE, DISPLAY MESSAGE WE'VE BUILT IN SCREEN_BUFFER,
                ABS_SHORT
               BSR.S   WAIT_TWO_SECS        ;THEN LET MESSAGE SIT IN LCD FOR A BIT.
               BSR     REQUEST_SENSE        ;NOW, ATTEMPT TO READ SENSE KEY FROM TARGET -
               BEQ.S   SCSI_ERR_80          ;IF SENSE KEY SUCCESSFULLY READ, GO DISPLAY IT.
               MOVE.L  #CANT_SENSE_SCRN,A1  ;ELSE - SAY WE COULDN'T READ SENSE KEY,
                ABS_LONG
               JSR     DISP_SCREEN
                ABS_SHORT
               BSR.S   WAIT_TWO_SECS        ;.... SAY IT FOR A WHILE ....
               BRA     SCSI_ERROR           ;NOW, BACK TO THE TOP WITH NEW ERROR CODE IN D0.
SCSI_ERR_80
               MOVE.L  #SENSE_KEY_SCRN,A1   ;DISPLAY SENSE KEY READ FROM TARGET.
                ABS_LONG
               JSR     WRITE_SCREEN
                ABS_SHORT
               MOVE.B  TARG_SENSE_KEY,D0
		andi.w	#000fh,d0			; mask to significant bits.
               MOVE    #0C02H,D1
                ABS_LONG
               JSR     WRITE_HEX_VALUE
                ABS_SHORT

		cmpi.b	#2,d0				; device not ready?
		bne.s	scsi_err_88
		lea	not_ready_strng(pc),a2
		bra.s	scsi_err_8q
scsi_err_88
		cmpi.b	#7,d0				; data protect?
		bne.s	scsi_err_8z
		lea	data_prot_strng(pc),a2
scsi_err_8q
		move.w	#1010h,d1
		.along
		jsr	WRITE_STRING		; leave intelligible msg if approp.
		.aword
scsi_err_8z
                                            ;FALL THRU, DISPLAY SCREEN AND RETURN Z FLAG FALSE.
;
SCSI_ERR_X0
                ABS_LONG
               JSR     DISP_BUFFER          ;DISPLAY SCREEN_BUFFER CONTENTS,
                ABS_SHORT
               MOVEQ   #GENERIC_ERROR,D0    ;REFRESH Z FLAG FALSE AND EXIT.
;
SCSI_ERR_Z0
                                            ;UNSTACK REGISTERS HERE, IF ANY ARE STACKED.
SCSI_ERR_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; MINDLESS DELAY TO SLOW THE ACTION DOWN, LET POOR ME SEE WHAT THE
; SYSTEM IS TRYING TO TELL ME VIA THE LCD -
; ALL REGISTERS PRESERVED.
;
WAIT_TWO_SECS
               BSR     WAIT_A_SECOND        ;WAIT A SECOND,
                                            ;THEN FALL THROUGH AND WAIT A SECOND SECOND.
;
WAIT_A_SECOND
               MOVEM.L D0,-(A7)
               MOVE.L  #444444,D0
WAIT_1_LOOP
               SUBQ.L  #1,D0
               BNE     WAIT_1_LOOP
               MOVEM.L (A7)+,D0
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;
;
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; WRITE A STRING INTO SCREEN_BUFFER PER PHASE CODE IN D0.B -
; D1.B INDICATES POSITION (LENGTH IS ALWAYS = 8).
; ALL REGISTERS PRESERVED.
;
WRITE_PHASE
               MOVEM.L D0-D1/A2,-(A7)
               CMP.B   #1CH,D0              ;VALID PHASE CODE, OR .... NO PHASE AT ALL?
               BCS.S   WR_PHS_10            ;VALID, GOFORIT.
               MOVEQ   #20H,D0              ;ELSE - SET INDEX TO "IDLE/SEL" STRING.
WR_PHS_10
               ADD     D0,D0                ;PHASE CODES ARE MULTIPLES OF 4 - BUMP IT TO 8.
               AND     #0FFH,D0             ;WIPE OUT M.S.BYTE TRASH.
               MOVE.L  #PHASE_STRINGS,A2    ;POINT TO PHASE STRING TABLE,
               ADD     D0,A2                ;OFFSET THE POINTER AS REQ'D.
               LSL     #8,D1                ;SHIFT FIELD POSITION OVER,
               MOVE.B  #8,D1                ;TACK ON THE 8-CHARACTER FIELD LENGTH.
                ABS_LONG
               JSR     WRITE_STRING         ;WRITE THAT PHASE STRING, NOW!
                ABS_SHORT
               MOVEM.L (A7)+,D0-D1/A2
WR_PHS_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; SCSI ERROR MESSAGES PER INTERNAL ERROR CODES -
; MINIMAL STUFF, INTO WHICH OTHER INFO IS INSERTED.
;
SCSI_ERR_SCREENS
               ASC     "  BUS NOT FREE  "   ;BUS_NOT_FREE.
               ASC     "BS:  H    CS:  H"
               ASC     "         STUCK  "   ;STUCK_PHASE.
               ASC     "BS:  H    CS:  H"
               ASC     "         PHASE  "   ;WRONG_PHASE.
               ASC     "  AFTER         "
               ASC     "        - NO REQ"   ;REQ_TIMEOUT.
               ASC     "BS:  H    CS:  H"
               ASC     "  STATUS =   H  "   ;STATUS_ERROR.
               ASC     "                "
;
;
; STRINGS TO REPRESENT THE VARIOUS SCSI INFO TRANSFER PHASES:
;
PHASE_STRINGS
               ASC     "DATA-OUT"           ;DAT_OUT_PHASE.
               ASC     "DATA-IN "           ;DAT_IN_PHASE.
               ASC     "COMMAND "           ;CMD_PHASE.
               ASC     "STATUS  "           ;STATUS_PHASE.
               ASC     " wasted "           ;UNDEFINED.
               ASC     " space  "           ;UNDEFINED.
               ASC     "MSG-OUT "           ;MSG_OUT_PHASE.
               ASC     "MSG-IN  "           ;MSG_IN_PHASE.
               ASC     "IDLE/SEL"           ;BUS IDLE, OR SELECTION PHASE (BOMB-OUT).
;
;
; OTHER SPECIFIC SCREEN-TYPE STUFF:
;
BUT_OKAY_SCRN
               ASC     "BUT, STATUS OKAY"
               ASC     "COMMAND COMPLETE"
CANT_SENSE_SCRN
               ASC     " UNABLE TO READ "
               ASC     " SENSE KEY ...  "
SENSE_KEY_SCRN
               ASC     "SENSE KEY =   H "
               ASC     "COMMAND ABORTED "
not_ready_strng
               ASC     "drive not ready!"
data_prot_strng
               ASC     "write-protected!"
STAT_PHASE_SCRN
               ASC     "UNEXPECT. CHANGE"
               ASC     "TO STATUS PHASE "
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
