               INCLUDE HPFIXUPS
               TITLE "GNRCSCSI"
***************************************************************************************************
***************************************************************************************************
***                                                                                             ***
***            GNRCSCSI - GENERIC LOW-LEVEL SCSI DRIVERS FOR NCR 5380 SCSI INTERFACE CHIP       ***
***                                                                                             ***
***************************************************************************************************
***************************************************************************************************
;
NEG_EXT        EQU     0FFFFFF00H      ;USE IN MOVEQ INSTRUCTIONS WHERE ARG IS
                                       ;80H OR LARGER - HP XASM DOES NOT HANDLE
                                       ;SIGN-EXTEND CORRECTLY.  COSMETIC, KEEPS
                                       ;ACTUAL BYTE VALUE CLEARER.
;
               INCLUDE EQUATES         ;HDW ADDR AND CONSTANT DEFS, ABS_SHORT DIRECTIVE.
;
               INCLUDE DISKDEFS        ;DISK SYSTEM DEFINITIONS.
;
               GLB     RESET_SCSI
               GLB     SELECT_DEVICE
               GLB     PHASE_CHANGE
               GLB     SCSI_RAM_WRITE
               GLB     SCSI_RAM_READ
               GLB     SCSI_RAM_VERIFY
		.export filler_command_byte
               GLB     SIX_BYTE_CMD
               GLB     TEN_BYTE_CMD
               GLB     FINISH_SCSI_SEQ
               GLB     READ_STATUS
               GLB     READ_MESSAGE
               GLB     CHECK_STATUS
               GLB     REQUEST_SENSE
               GLB     SCSI_SAM_WRITE
               GLB     SCSI_SAM_READ
               GLB     SCSI_SAM_VERIFY
               .export read_capacity
               .export test_unit_ready
;
               EXTERNAL  CUR_SCSI_PHS
               EXTERNAL  LAST_SCSI_PHS
               EXTERNAL  SCSI_CMD_BUF
               EXTERNAL  TARG_STATUS
               EXTERNAL  TARG_MESSAGE
               EXTERNAL  TARG_SENSE_KEY
               EXTERNAL  SCSI_VER_FLAG
               EXTERNAL  DRIVE_SEL
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; ISSUE BUS RESET COMMAND (RESETS US TOO) -
; INITIALIZE 5380 FOR INITIATOR MODE OPERATION.
; ALL REGISTERS PRESERVED.
;
RESET_SCSI
               MOVE.L  D0,-(A7)             ;SAVE HIM.
               MOVE.B  #80H,SCSI_ICMD_WR    ;ASSERT /RST ON BUS.
               MOVEQ   #-1,D0               ;HOLD IT THERE FOR APPROX 80 MSEC (THAT'S ENOUGH).
RST_SCSI_10
               DBRA    D0,RST_SCSI_10
               MOVE.B  #0,SCSI_ICMD_WR      ;DEASSERT /RST.
               MOVE.B  #0,SCSI_MODE_WR      ;SET 5380 INTO INITIATOR MODE -
                                            ;ALSO DISABLE ALL CHECK, INTERRUPT AND DMA OPTIONS,
                                            ;ARBITRATION REQUEST.
               MOVE.B  #0,SCSI_SEL_ENB      ;DISABLE SELECT INTERRUPTS BY MASKING ALL ID BITS OFF.
               TST.B   SCSI_RST_PRTY        ;CLEAR ANY INTERRUPTS WHICH MIGHT BE HANGING AROUND.
               MOVE.L  (A7)+,D0             ;RESTORE REGISTER, SCRAM.
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; SELECT AN EXTERNAL SCSI DEVICE AS A TARGET -
; DRIVE_SEL(.W) CONTAINS TARGET DEVICE NUMBER 0-6.
; MUST DETECT BUS-FREE FIRST - WE'RE THE ONLY INITIATOR (AT PRESENT),
; THUS WE WON'T BOTHER TO ARBITRATE FOR THE BUS - WE JUST TAKE IT.
; RETURNS Z FLAG TRUE IF TARGET IS SUCCESSFULLY SELECTED,
; OR Z FLAG FALSE AND D0 = #SELECT_FAILED.
; ALWAYS CLEARS PHASE-TRACKING VARIABLES.
; DESTROIZ D0, PRESERVES OTHER REGISTERS.
;
SELECT_DEVICE
               MOVEM.L D1-D2,-(A7)
               ST      CUR_SCSI_PHS         ;PHASE VARIABLES = 0FFH MEAN "NOTHING YET".
               ST      LAST_SCSI_PHS
               MOVE.L  #500000,D2           ;TIMEOUT TO DETECT BUS-FREE CONDITION.
SEL_DEV_10
               BTST    #6,SCSI_CUR_STAT     ;IS /BSY CLEAR?
               BEQ.S   SEL_DEV_20           ;BRANCH IF YES, GO TO SELECTION PHASE.
               SUBQ.L  #1,D2                ;NO - NOTCH THE TIMEOUT DOWN,
               BNE     SEL_DEV_10           ;LOOP BACK IF NOT TIMED OUT,
               MOVEQ   #BUS_NOT_FREE,D0     ;ELSE EXIT WITH ERROR CODE.
               BRA.S   SEL_DEV_90
SEL_DEV_20
               MOVE.B  #0,SCSI_MODE_WR      ;MAKE SURE 5380 DMA MODE IS NOT ENABLED.
               MOVE.B  #0,SCSI_TCMD_WR      ;FOR HEKUVIT, 5380 PHASE BITS SHOULD MATCH THE BUS.
               MOVEQ   #NEG_EXT+80H,D1      ;SET UP ID BYTE - BIT 7 FOR DEVICE 7 (THAT'S US),
               MOVE    DRIVE_SEL,D0         ;PLUS ID BIT FOR DESIRED TARGET DEVICE.
               BSET    D0,D1                ;(A SCHOLARLY NOTE:  DURING SELECTION PHASE, A TARGET
                                            ;RECOGNIZES AND RESPONDS TO ITS OWN ID BIT ON THE DATA
                                            ;BUS - WHERE MULTI-THREADED I/O (I.E. DISCONNECT AND
                                            ;RECONNECT) IS USED, THE TARGET DEVICE MUST KNOW WHO
                                            ;THE INITIATOR WAS, HENCE THE EXTRA ID BIT - WE DON'T
                                            ;USE IT IN THE 440, THE INITIATOR ID BIT IS REALLY ONLY
                                            ;FOR FORM'S SAKE AND IS NOT ACTUALLY REQUIRED.)
               MOVE.B  D1,SCSI_DATA_OUT     ;PUT ID BYTE INTO DATA OUT REG.
               MOVE.B  #1,SCSI_ICMD_WR      ;ASSERT DATA BUS, PUT OUT THE IDs.
               MOVE.B  #5,SCSI_ICMD_WR      ;MERE NANOSECONDS LATER, ASSERT /SEL ALSO.
               MOVE.W  #52632,D0            ;WAIT UP TO 250 MSEC FOR TARGET TO ASSERT /BSY.
SEL_DEV_60
               BTST    #6,SCSI_CUR_STAT     ;(20) TEST /BSY STATUS.
               BNE.S   SEL_DEV_80           ;(8)  SKIP OUT IF IT'S THERE - WE GOT TARGET.
               DBRA    D0,SEL_DEV_60        ;(10) IF NOT, KEEP TIMING OUT.
;
               MOVE.B  #0,SCSI_DATA_OUT     ;TIMED OUT - PULL ID BITS OFF BUS,
               MOVEQ   #42,D0               ;WAIT ANOTHER 200 USEC FOR TARGET TO RESPOND.
SEL_DEV_70
               BTST    #6,SCSI_CUR_STAT     ;(20) TEST /BSY STATUS.
               BNE.S   SEL_DEV_80           ;(8)  SKIP OUT IF IT'S THERE - WE GOT TARGET.
               DBRA    D0,SEL_DEV_70        ;(10) IF NOT, KEEP TIMING OUT.
;
               MOVE.B  #0,SCSI_ICMD_WR      ;TARGET DID NOT RESPOND - DEASSERT /SEL, RELEASE BUS.
               MOVEQ   #SELECT_FAILED,D0    ;RETURN ERROR CODE.
               BRA.S   SEL_DEV_90
;
SEL_DEV_80
               MOVE.B  #0,SCSI_ICMD_WR      ;TARGET RESPONDED TO SELECTION -
                                            ;DEASSERT /SEL AND DATABUS, RETURN Z FLAG TRUE.
SEL_DEV_90
               MOVEM.L (A7)+,D1-D2
SEL_DEV_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; STUMBLE THROUGH A SCSI BUS PHASE TRANSITION -
; D0 CONTAINS A CODE FOR THE PHASE WE'RE EXPECTING TO ENTER NEXT.
; IF THIS PHASE IS SEEN WITHIN THE TIMEOUT PERIOD, THE NEW PHASE CODE IS
; STASHED IN CUR_SCSI_PHS TO ALLOW TRACKING OF PHASE SEQUENCE PROGRESS.
; NEXT, BITS IN THE 5380 TARGET COMMAND REGISTER ARE UPDATED TO MATCH
; THE NEW BUS PHASE (NECESSARY IN ORDER FOR THE 5380 TO BE ABLE TO DRIVE
; THE SCSI DATA BUS IN INITIATOR DMA MODE) AND THE PHASE MISMATCH FLAG
; IS RESET (SO WE CAN USE IT TO DETECT THE NEXT PHASE MISMATCH).
; FINALLY, THE 5380 DATA DIRECTION IS ESTABLISHED PER THE I/O BIT IN THE
; PHASE CODE, DMA TRANSFER MODE IS ENABLED, AND WE RETURN Z FLAG TRUE.
;
; IF, ON THE OTHER HAND, THE TARGET CHANGES TO A PHASE OTHER THAN THE
; ONE WE WERE EXPECTING, THEN CUR_SCSI_PHS IS UPDATED TO REFLECT ACTUAL
; SCSI REALITY INSTEAD - WE RETURN WITH D0 = #WRONG_PHASE, Z FLAG FALSE.
; FINALLY, IF NO PHASE CHANGE IS DETECTED AT ALL, WE RETURN WITH
; CUR_SCSI_PHS UNCHANGED, D0 = #STUCK_PHASE AND Z FLAG FALSE.
;
; NOTE THAT THE TIMEOUT FOR DETECTING PHASE CHANGE (APPROX 440 MSEC. AT
; PRESENT) IS PART OF A TIMEOUT LOOP IN THE CONF_DATAFR_20 CONTROLLER
; INITIALIZATION ROUTINE - THE READ_STATUS LOOP COUNT IN THAT ROUTINE
; WILL NEED TO BE CHANGED IF THE TIMEOUT HERE IS CHANGED.
;
; IN ALL CASES, THE EXISTING CUR_SCSI_PHS VALUE IS COPIED INTO
; LAST_SCSI_PHS SO WE KNOW WHERE WE WERE COMING FROM.
;
; ALL REGISTERS OTHER THAN D0 ARE PRESERVED.
;
PHASE_CHANGE
               MOVEM.L D1-D2,-(A7)
               MOVE.L  #80000H,D2           ;SET TIMEOUT FOR DETECTION OF PHASE MISMATCH (3 SECS).
               MOVE.B  CUR_SCSI_PHS,LAST_SCSI_PHS     ;REMEMBER WHERE WE WERE, IN CASE OF ERROR.
               MOVE.B  #0,SCSI_ICMD_WR      ;GET OFF THE SCSI DATA BUS - JUST IN CASE.
PHS_CHG_10
               MOVE.B  SCSI_CUR_STAT,D1     ;HAVE A LOOK AT BUS PHASE SIGNALS -
               AND.B   #1CH,D1              ;TEST PHASE BITS ONLY - IGNORE OTHER SIGNALS.
               CMP.B   D0,D1                ;DID WE GET THE PHASE WE WERE EXPECTING?
               BEQ.S   PHS_CHG_30           ;BRANCH IF WE GOT IT -
               SUBQ.L  #1,D2                ;ELSE - LOOP AGAIN IF NOT TIMED OUT.
               BNE     PHS_CHG_10
;
                                            ;WELL, WE'VE TIMED OUT -
               MOVE.B  D1,CUR_SCSI_PHS      ;SAVE THE NEW ACTUAL BUS PHASE, WHATEVER IT IS.
               CMP.B   LAST_SCSI_PHS,D1     ;IS CURRENT PHASE DIFFERENT FROM WHAT IT WAS BEFORE?
               BNE.S   PHS_CHG_20           ;BRANCH IF YES - RETURN CODE FOR UNEXPECTED NEW PHASE.
               MOVEQ   #STUCK_PHASE,D0      ;SAME AS IT EVER WAS - SAY WE GOT A STUCK PHASE.
               BRA.S   PHS_CHG_80
PHS_CHG_20
               MOVEQ   #WRONG_PHASE,D0
               BRA.S   PHS_CHG_80
;
PHS_CHG_30
               MOVE.B  D1,CUR_SCSI_PHS      ;WE GOT THE NEW PHASE WE WERE EXPECTING - SAVE IT.
               ROR.B   #2,D1                ;ROTATE PHASE CODE FOR 5380 TARGET COMMAND REGISTER,
               MOVE.B  D1,SCSI_TCMD_WR      ;SET 5380 PHASE BITS TO MATCH IT NEW PHASE.
               MOVE.B  #0,SCSI_RST_PRTY     ;CLEAR PHASE-MISMATCH INTERRUPT.
               MOVE.B  #2,SCSI_MODE_WR      ;SET DMA MODE BIT TO ALLOW PSEUDO-DMA TRANSFERS.
               BTST    #2,D0                ;"I/O" BIT OF PHASE CODE INDICATES TRANSFER DIRECTION -
               BEQ.S   PHS_CHG_40           ;BRANCH IF DATA DIRECTION IS OUT TO TARGET.
               MOVE.B  #0,SCSI_IDMA_RCV     ;THIS ALLOWS DMA RECEIVE OPERATION TO BEGIN.
               BRA.S   PHS_CHG_50           ;DONE - EXIT WITH Z FLAG TRUE.
PHS_CHG_40
               MOVE.B  #0,SCSI_DMA_SEND     ;THIS ALLOWS DMA SEND OPERATION TO BEGIN.
               MOVE.B  #1,SCSI_ICMD_WR      ;ASSERT SCSI DATA BUS OUTPUTS,
PHS_CHG_50
               CLR     D0                   ;RETURN Z FLAG TRUE.
;
PHS_CHG_80
               MOVEM.L (A7)+,D1-D2
PHS_CHG_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; WRITE 8-BIT CPU RAM DATA TO TARGET -
; USED FOR DATA/COMMAND/MESSAGE OUT - D0 CONTAINS APPLICABLE PHASE CODE.
; A0 POINTS TO CPU RAM BLOCK TO BE WRITTEN OUT TO TARGET.
; D2.L INDICATES NUMBER OF "REAL" BYTES TO WRITE,
; D3.W INDICATES NUMBER OF ADDITIONAL FILLER BYTES (00H) TO TRANSMIT
; (WHERE NEEDED, IN ORDER TO FINISH WRITING THE LAST LOGICAL BLOCK).
; NOTE: WHERE AN EXTRA BYTE WRITE IS REQUIRED FOR FINAL /ACK HANDSHAKE,
; IT SHOULD BE INCLUDED IN ONE OF THE TRANSFER COUNTS.
; RETURNS Z FLAG TRUE IF TRANSFER IS SUCCESSFUL, ELSE RETURNS Z FLAG
; FALSE AND ERROR CODE IN D0.
; IN ALL CASES, 5380 DMA MODE IS DISABLED BEFORE RETURNING.
;
; 921008-10:47am
; today's modification makes it legitimate to call here with a "real" byte
; count of zero, as a special provision for the filler_command_byte routine
; also created today.
;
; DESTROYS D0-D3/A0.
;
SCSI_RAM_WRITE
               MOVEM.L D4,-(A7)
               BSR     PHASE_CHANGE         ;AWAIT/ACCOMMODATE EXPECTED OUTPUT PHASE.
               BNE.S   SC_RAM_WR_50         ;EXIT IF IT DIDN'T HAPPEN.
;
               MOVE.L  #500000,D4           ;SET UP /REQ TIMEOUT.
;
		tst.l	d2				; check for "real" byte count == 0.
		beq.s	sc_ram_wr_2z		; if so, skip to filler byte loop.
;
SC_RAM_WR_10
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_RAM_WR_20         ;BRANCH IF YES - DO THAT DATA THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_RAM_WR_10         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_RAM_WR_50
SC_RAM_WR_20
                                            ;GOT /REQ FROM TARGET -
               MOVE.B  (A0)+,SCSI_DMA_WR    ;FETCH AND WRITE A BYTE.
               SUBQ.L  #1,D2                ;HAVE WE WRITTEN ENOUGH "REAL" DATA YET?
               BNE     SC_RAM_WR_10         ;NO - GO BACK FOR ANOTHER BYTE.
sc_ram_wr_2z
;
               TST     D3                   ;ALL "REAL" DATA SENT - ANY TRASH BYTES TO SEND?
               BEQ.S   SC_RAM_WR_48         ;BRANCH IF NOT, GO DO FINAL /ACK DISABLE.
               SUBQ    #1,D3                ;ELSE - SEND INDICATED NUMBER OF FILLER BYTES:
SC_RAM_WR_30
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_RAM_WR_40         ;BRANCH IF YES - DO THAT FILLER-DATA THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_RAM_WR_30         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_RAM_WR_50
SC_RAM_WR_40
                                            ;GOT /REQ FROM TARGET -
               MOVE.B  #0,SCSI_DMA_WR       ;WRITE A FILLER BYTE.
               DBRA    D3,SC_RAM_WR_30      ;LOOP AGAIN IF WE'RE NOT DONE WITH FILLER BYTE WRITE.
SC_RAM_WR_48
               CLR     D0                   ;NO-ERROR RETURN, Z FLAG TRUE.
;
SC_RAM_WR_50
               MOVE.B  #0,SCSI_MODE_WR      ;DISABLE DMA MODE TO TURN OFF /ACK.
               TST     D0                   ;REFRESH Z FLAG BEFORE RETURNING.
SC_RAM_WR_60
               MOVEM.L (A7)+,D4
SC_RAM_WR_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; READ 8-BIT CPU RAM DATA FROM TARGET -
; USED FOR DATA/STATUS/MESSAGE IN - D0 CONTAINS APPLICABLE PHASE CODE.
; A0 POINTS TO CPU RAM BLOCK TO READ TARGET DATA INTO.
; D1.W INDICATES NUMBER OF BYTES TO DISCARD BEFORE STORE BEGINS,
; D2.L INDICATES NUMBER OF "REAL" BYTES TO READ,
; D3.W INDICATES NUMBER OF ADDITIONAL FILLER BYTES TO READ
; (WHERE NEEDED, IN ORDER TO FINISH READING THE LAST LOGICAL BLOCK).
; RETURNS Z FLAG TRUE IF TRANSFER IS SUCCESSFUL, ELSE RETURNS Z FLAG
; FALSE AND ERROR CODE IN D0.
; IN ALL CASES, 5380 DMA MODE IS DISABLED BEFORE RETURNING.
; DESTROYS D0-D3/A0.
;
SCSI_RAM_READ
               MOVEM.L D4,-(A7)
               BSR     PHASE_CHANGE         ;AWAIT/ACCOMMODATE EXPECTED INPUT PHASE.
               BNE.S   SC_RAM_RD_70         ;EXIT IF IT DIDN'T HAPPEN.
;
               MOVE.L  #500000,D4           ;SET UP /REQ TIMEOUT (NOTE: TIMEOUT IS NOT RESTARTED -
                                            ;IF THIS MUCH DEAD-AIR TIME ELAPSES, SOMETHING WRONG).
;
               TST     D1                   ;DO WE NEED TO SKIP ANY DATA BEFORE STORING TO RAM?
               BEQ.S   SC_RAM_RD_30         ;BRANCH IF NOT, GO STRAIGHT INTO DATA-STORE LOOP.
               SUBQ    #1,D1                ;ELSE - SKIP INDICATED NUMBER OF BYTES:
SC_RAM_RD_10
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_RAM_RD_20         ;BRANCH IF YES - DO THAT FILLER-DATA THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_RAM_RD_10         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_RAM_RD_70
SC_RAM_RD_20
                                            ;GOT /REQ FROM TARGET -
               MOVE.B  SCSI_DMA_RD,D0       ;READ AND DISCARD A SKIP BYTE.
               DBRA    D1,SC_RAM_RD_10      ;LOOP AGAIN IF WE'RE NOT DONE WITH SKIP BYTE READ.
;
SC_RAM_RD_30
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_RAM_RD_40         ;BRANCH IF YES - DO THAT DATA THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_RAM_RD_30         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_RAM_RD_70
SC_RAM_RD_40
                                            ;GOT /REQ FROM TARGET -
               MOVE.B  SCSI_DMA_RD,(A0)+    ;READ AND STORE A BYTE.
               SUBQ.L  #1,D2                ;HAVE WE READ ENOUGH "REAL" DATA YET?
               BNE     SC_RAM_RD_30         ;NO - GO BACK FOR ANOTHER BYTE.
;
               TST     D3                   ;ALL "REAL" DATA READ - ANY TRASH BYTES TO READ?
               BEQ.S   SC_RAM_RD_68         ;BRANCH IF NOT, GO DO FINAL /ACK DISABLE.
               SUBQ    #1,D3                ;ELSE - READ INDICATED NUMBER OF FILLER BYTES:
SC_RAM_RD_50
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_RAM_RD_60         ;BRANCH IF YES - DO THAT FILLER-DATA THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_RAM_RD_50         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_RAM_RD_70
SC_RAM_RD_60
                                            ;GOT /REQ FROM TARGET -
               MOVE.B  SCSI_DMA_RD,D0       ;READ AND DISCARD A FILLER BYTE.
               DBRA    D3,SC_RAM_RD_50      ;LOOP AGAIN IF WE'RE NOT DONE WITH FILLER BYTE READ.
SC_RAM_RD_68
               CLR     D0                   ;NO-ERROR RETURN, Z FLAG TRUE.
;
SC_RAM_RD_70
               MOVE.B  #0,SCSI_MODE_WR      ;DISABLE DMA MODE TO TURN OFF /ACK -
               TST     D0                   ;REFRESH Z FLAG BEFORE RETURNING.
SC_RAM_RD_80
               MOVEM.L (A7)+,D4
SC_RAM_RD_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; VERIFY 8-BIT CPU RAM DATA AGAINST TARGET DATA -
; A0 POINTS TO CPU RAM BLOCK TO COMPARE TARGET DATA WITH.
; D2.L INDICATES NUMBER OF "REAL" BYTES TO VERIFY,
; D3.W INDICATES NUMBER OF ADDITIONAL FILLER BYTES TO READ
; (WHERE NEEDED, IN ORDER TO FINISH READING THE LAST LOGICAL BLOCK).
; SETS SCSI_VER_FLAG IF ANY COMPARE ERRORS ARE ENCOUNTERED -
; ELSE RETURNS SCSI_VER_FLAG = 00H.
; RETURNS Z FLAG TRUE IF NO SCSI TRANSFER ERRORS OCCUR,
; ELSE RETURNS Z FLAG FALSE AND ERROR CODE IN D0 -
; I.E., Z FLAG TRUE DOES NOT NECESSARILY MEAN NO COMPARE ERRORS.
; IN ALL CASES, 5380 DMA MODE IS DISABLED BEFORE RETURNING.
; DESTROYS D0-D3/A0.
;
SCSI_RAM_VERIFY
               MOVEM.L D4,-(A7)
               SF      SCSI_VER_FLAG        ;CLEAR COMPARE-ERROR FLAG.
               MOVEQ   #DAT_IN_PHASE,D0     ;WE'LL BE READING (BUT NOT STORING).
               BSR     PHASE_CHANGE         ;AWAIT/ACCOMMODATE EXPECTED INPUT PHASE.
               BNE.S   SC_RAM_VR_70         ;EXIT IF IT DIDN'T HAPPEN.
;
               MOVE.L  #500000,D4           ;SET UP /REQ TIMEOUT (NOTE: TIMEOUT IS NOT RESTARTED -
                                            ;IF THIS MUCH DEAD-AIR TIME ELAPSES, SOMETHING WRONG).
;
SC_RAM_VR_30
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_RAM_VR_40         ;BRANCH IF YES - DO THAT DATA-COMPARE THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_RAM_VR_30         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_RAM_VR_70
SC_RAM_VR_40
                                            ;GOT /REQ FROM TARGET -
               MOVE.B  SCSI_DMA_RD,D0       ;READ AND COMPARE A BYTE.
               CMP.B   (A0)+,D0
               BEQ.S   SC_RAM_VR_44         ;BRANCH IF COMPARE WAS OK,
               ST      SCSI_VER_FLAG        ;ELSE SET COMPARE-ERROR FLAG.
SC_RAM_VR_44
               SUBQ.L  #1,D2                ;HAVE WE COMPARED ENOUGH "REAL" DATA YET?
               BNE     SC_RAM_VR_30         ;NO - GO BACK FOR ANOTHER BYTE.
;
               TST     D3                   ;ALL "REAL" DATA COMPARED - ANY TRASH BYTES TO READ?
               BEQ.S   SC_RAM_VR_68         ;BRANCH IF NOT, GO DO FINAL /ACK DISABLE.
               SUBQ    #1,D3                ;ELSE - READ INDICATED NUMBER OF FILLER BYTES:
SC_RAM_VR_50
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_RAM_VR_60         ;BRANCH IF YES - DO THAT FILLER-DATA THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_RAM_VR_50         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_RAM_VR_70
SC_RAM_VR_60
                                            ;GOT /REQ FROM TARGET -
               MOVE.B  SCSI_DMA_RD,D0       ;READ AND DISCARD A FILLER BYTE.
               DBRA    D3,SC_RAM_VR_50      ;LOOP AGAIN IF WE'RE NOT DONE WITH FILLER BYTE READ.
SC_RAM_VR_68
               CLR     D0                   ;NO-ERROR RETURN, Z FLAG TRUE.
;
SC_RAM_VR_70
               MOVE.B  #0,SCSI_MODE_WR      ;DISABLE DMA MODE TO TURN OFF /ACK -
               TST     D0                   ;REFRESH Z FLAG BEFORE RETURNING.
SC_RAM_VR_80
               MOVEM.L (A7)+,D4
SC_RAM_VR_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;900424;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;900424;
;900424; ISSUE A COMMAND TO TARGET -
;900424; ASSUMES TARGET DEVICE HAS RESPONDED TO SELECTION PROCEDURE.
;900424; SEPARATE ENTRY POINTS FOR SIX-BYTE AND TEN-BYTE COMMANDS.
;900424; COMMAND STRING IS PREASSEMBLED IN SCSI_CMD_BUF (NO REGISTER INPUTS).
;900424;
;900424; THINGS YA MIGHT LIKE TO KNOW:
;900424; OMTI CONTROLLER IN DATAFRAME 20 DOES NOT SUPPORT ANY 12-BYTE COMMANDS.
;900424; FOR ANY GIVEN COMMAND LENGTH, AN EXTRA BYTE WRITE OCCURS AFTER THE
;900424; ACTUAL COMMAND STRING HAS BEEN WRITTEN - THIS IS NEEDED TO FORCE THE
;900424; 5380 TO DEASSERT /ACK FOR THE LAST TIME AND ALLOW BUS PHASE SEQUENCES
;900424; TO GO FORWARD.  ALTHOUGH THE 5380 MANUAL CLAIMS THAT TOGGLING THE DMA
;900424; MODE BIT IS ADEQUATE TO ACHIEVE THIS RESULT, SUCH IS APPARENTLY THE
;900424; CASE ONLY IN ACTUAL DATA-OUT PHASE - WHEN IN COMMAND PHASE, THIS EXTRA
;900424; BYTE WRITE IS NECESSARY.
;900424;
;900424; LATE NOTE - NO TEN-BYTE COMMANDS AS OF THE DATAFRAME-ONLY RELEASE.
;900424;
;900424; DESTROYS D0.
;900424;
;900424SIX_BYTE_CMD
;900424               MOVEM.L D1-D3/A0,-(A7)
;900424               MOVEQ   #6,D2                ;SET UP BYTE TRANSFER COUNT - SIX "REAL" BYTES.
;900424;
;900424;31MAR               BRA.S   ISS_CMD_10           ;ALL ELSE IS SAME FROM HERE.
;900424;31MAR;
;900424;31MARTEN_BYTE_CMD
;900424;31MAR               MOVEM.L D1-D3/A0,-(A7)
;900424;31MAR               MOVEQ   #10,D2               ;SET UP BYTE TRANSFER COUNT - TEN "REAL" BYTES.
;900424;31MAR;
;900424;31MARISS_CMD_10
;900424;
;900424               MOVEQ   #1,D3                ;TACK ON ONE FILLER BYTE FOR FINAL /ACK HANDSHAKE.
;900424               MOVEQ   #CMD_PHASE,D0        ;THIS IS THE PHASE WE EXPECT TO BE DEALING WITH.
;900424               MOVE    #SCSI_CMD_BUF,A0     ;THIS IS WHERE THE COMMAND DESCRIPTOR BLOCK IS.
;900424               BSR     SCSI_RAM_WRITE       ;JUST WHANG IT OUT THERE - PASS RETURN STATUS THROUGH.
;900424;
;900424               MOVEM.L (A7)+,D1-D3/A0
;900424ISS_CMD_EXIT
;900424               RTS
;900424;
;900424;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA


















;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; ISSUE A COMMAND TO TARGET -
; ASSUMES TARGET DEVICE HAS RESPONDED TO SELECTION PROCEDURE.
; SEPARATE ENTRY POINTS FOR SIX-BYTE AND TEN-BYTE COMMANDS.
; COMMAND STRING IS PREASSEMBLED IN SCSI_CMD_BUF (NO REGISTER INPUTS).
;
; THINGS YA MIGHT LIKE TO KNOW:
; OMTI CONTROLLER IN DATAFRAME 20 DOES NOT SUPPORT ANY 12-BYTE COMMANDS.
; FOR ANY GIVEN COMMAND LENGTH, AN EXTRA BYTE WRITE OCCURS AFTER THE
; ACTUAL COMMAND STRING HAS BEEN WRITTEN - THIS IS NEEDED TO FORCE THE
; 5380 TO DEASSERT /ACK FOR THE LAST TIME AND ALLOW BUS PHASE SEQUENCES
; TO GO FORWARD.  ALTHOUGH THE 5380 MANUAL CLAIMS THAT TOGGLING THE DMA
; MODE BIT IS ADEQUATE TO ACHIEVE THIS RESULT, SUCH IS APPARENTLY THE
; CASE ONLY IN ACTUAL DATA-OUT PHASE - WHEN IN COMMAND PHASE, THIS EXTRA
; BYTE WRITE IS NECESSARY.
;
; LATE NOTE - NO TEN-BYTE COMMANDS AS OF THE DATAFRAME-ONLY RELEASE.
; Later note - ten-byte commands reinstated, to support read_capacity command.
;
; 921008-10:43am
; new addition filler_command_byte was created expressly for help in handling 
; cranky response of syquest or other ccs drives to illegal commands really 
; intended for dataframe drives but which get issued to other drives anyway.
;
; DESTROYS D0.
;
;
filler_command_byte
;
		movem.l d1-d3/a0,-(a7)
               moveq   #0,d2                ; send no "real" bytes,
               bra.s   ISS_CMD_10           ; just one filler byte.
;
;
SIX_BYTE_CMD
               MOVEM.L D1-D3/A0,-(A7)
               MOVEQ   #6,D2                ;SET UP BYTE TRANSFER COUNT - SIX "REAL" BYTES.
;
               BRA.S   ISS_CMD_10           ;ALL ELSE IS SAME FROM HERE.
;
TEN_BYTE_CMD
               MOVEM.L D1-D3/A0,-(A7)
               MOVEQ   #10,D2               ;SET UP BYTE TRANSFER COUNT - TEN "REAL" BYTES.
;
ISS_CMD_10
;
               MOVEQ   #1,D3                ;TACK ON ONE FILLER BYTE FOR FINAL /ACK HANDSHAKE.
               MOVEQ   #CMD_PHASE,D0        ;THIS IS THE PHASE WE EXPECT TO BE DEALING WITH.
               MOVE    #SCSI_CMD_BUF,A0     ;THIS IS WHERE THE COMMAND DESCRIPTOR BLOCK IS.
               BSR     SCSI_RAM_WRITE       ;JUST WHANG IT OUT THERE - PASS RETURN STATUS THROUGH.
;
               MOVEM.L (A7)+,D1-D3/A0
ISS_CMD_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA


















;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; USUAL FINAL STEPS FOR SCSI BUS SEQUENCE -
; READ TARGET STATUS AND MESSAGE BYTES, THEN INSPECT STATUS BYTE.
; RETURNS Z FLAG TRUE IF ALL IS WELL, ELSE RETURNS Z FLAG FALSE AND
; ERROR CODE IN D0 - NO INPUTS, ALL OTHER REGISTERS PRESERVED.
;
FINISH_SCSI_SEQ
               BSR.S   READ_STATUS          ;ATTEMPT TO READ STATUS BYTE FROM TARGET.
               BNE.S   FIN_SEQ_EXIT         ;RETURN ERROR CODE IF UNSUCCESSFUL.
               BSR.S   READ_MESSAGE         ;ATTEMPT TO READ MESSAGE BYTE FROM TARGET.
               BNE.S   FIN_SEQ_EXIT         ;RETURN ERROR CODE IF UNSUCCESSFUL.
               BSR.S   CHECK_STATUS         ;IF STATUS AND MESSAGE BYTES READ, SEQUENCE COMPLETE -
                                            ;INSPECT STATUS BYTE AND RETURN WITH COMPLETION CODES.
FIN_SEQ_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; READ TARGET STATUS BYTE INTO TARG_STATUS -
; IF STATUS READ IS SUCCESSFUL, RETURNS WITH Z FLAG TRUE -
; ELSE RETURNS Z FLAG FALSE AND ERROR CODE IN D0.
; ALL OTHER REGISTERS PRESERVED.
;
READ_STATUS
               MOVEM.L D1-D3/A0,-(A7)
               MOVEQ   #STATUS_PHASE,D0     ;THIS IS THE PHASE WE EXPECT TO DEAL WITH.
               CLR     D1                   ;READ THE VERY FIRST BYTE -
               MOVEQ   #1,D2                ;READ JUST ONE BYTE -
               CLR     D3                   ;NO TRASH BYTES.
               MOVE    #TARG_STATUS,A0      ;HERE IS WHERE TO PUT IT.
               BSR     SCSI_RAM_READ        ;SO, GIT DOWN TO IT - PASS RETURN STATUS THROUGH.
;
               MOVEM.L (A7)+,D1-D3/A0
RD_STAT_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;
;
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; READ TARGET MESSAGE BYTE INTO TARG_MESSAGE -
; IF STATUS READ IS SUCCESSFUL, RETURNS WITH Z FLAG TRUE -
; ELSE RETURNS Z FLAG FALSE AND ERROR CODE IN D0.
; ALL OTHER REGISTERS PRESERVED.
;
READ_MESSAGE
               MOVEM.L D1-D3/A0,-(A7)
               MOVEQ   #MSG_IN_PHASE,D0     ;THIS IS THE PHASE WE EXPECT TO DEAL WITH.
               CLR     D1                   ;READ THE VERY FIRST BYTE -
               MOVEQ   #1,D2                ;READ JUST ONE BYTE -
               CLR     D3                   ;NO TRASH BYTES.
               MOVE    #TARG_MESSAGE,A0     ;HERE IS WHERE TO PUT IT.
               BSR     SCSI_RAM_READ        ;SO, GIT DOWN TO IT - PASS RETURN STATUS THROUGH.
;
               MOVEM.L (A7)+,D1-D3/A0
RD_MSG_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;
;
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; CHECK STATUS BYTE READ FROM TARGET -
; CALL HERE AFTER COMPLETION OF COMMAND IF NO OTHER ERROR WAS SEEN.
; IF STATUS WAS "GOOD", RETURNS Z FLAG TRUE -
; ELSE RETURNS Z FLAG FALSE, D0 = #STATUS_ERROR.
; DESTROYS D0.
;
CHECK_STATUS
               MOVE.B  TARG_STATUS,D0       ;THIS IS THE STATUS BYTE LAST READ FROM TARGET -
               BEQ.S   CHK_STAT_EXIT        ;IF = 00H, WELL THAT'S "GOOD".
               MOVEQ   #STATUS_ERROR,D0     ;FOR ANY OTHER STATUS, LET SOMEONE SMARTER SORT IT OUT.
CHK_STAT_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; READ SENSE KEY FROM TARGET DEVICE INTO TARG_SENSE_KEY -
; CALL AFTER COMPLETION OF A COMMAND IN WHICH TARGET HAS RETURNED
; CHECK-CONDITION STATUS BYTE.
; WE GO AFTER THE DEVICE INDICATED BY THE CURRENT VALUE OF DRIVE_SEL.
; RETURNS Z FLAG TRUE IF SENSE KEY IS SUCCESSFULLY READ,
; ELSE RETURNS Z FLAG FALSE AND ERROR CODE IN D0.
; NOTE:  TRIGGERS A COMPLETE SCSI SEQUENCE.
; DESTRAUIZE D0, PRESERVES OTHEREGISTERS.
;
REQUEST_SENSE
               MOVEM.L D1-D3/A0,-(A7)
               BSR     SELECT_DEVICE        ;TRY TO SELECT TARGET DEVICE.
               BNE.S   REQ_SENSE_Z0         ;EXIT IF SELECTION UNSUCCESSFUL.
;
                                            ;TARGET RESPONDED TO SELECTION -
               CLR.L   SCSI_CMD_BUF         ;SET UP COMMAND DESCRIPTOR BLOCK.
               CLR     SCSI_CMD_BUF+4
               MOVE.B  #03H,SCSI_CMD_BUF
               BSR     SIX_BYTE_CMD         ;ISSUE REQUEST-SENSE COMMAND TO TARGET.
               BNE.S   REQ_SENSE_Z0         ;EXIT IF COMMAND NOT ISSUED SUCCESSFULLY.
;
                                            ;SET UP TO READ FOUR DATA BYTES INTO SCSI_CMD_BUF.
               MOVEQ   #DAT_IN_PHASE,D0     ;WE'RE EXPECTING DATA-IN PHASE FOR THIS.
               CLR     D1                   ;SKIP NONE OF THE INCOMING DATA.
               MOVEQ   #4,D2                ;READ FOUR DATA BYTES.
               CLR     D3                   ;NO EXCESS BYTES TO DISCARD.
               MOVE    #SCSI_CMD_BUF,A0     ;PUT DATA BYTES INTO COMMAND BUFFER (WHAT THE HELL).
               BSR     SCSI_RAM_READ        ;GET DEM BYTE.
               BNE.S   REQ_SENSE_Z0         ;EXIT IF DATA READ WAS UNSUCCESSFUL.
               MOVE.B  SCSI_CMD_BUF,TARG_SENSE_KEY    ;COPY THE SENSE KEY BYTE (IGNORE OTHERS).
               BSR     FINISH_SCSI_SEQ      ;GET COMPLETION STATUS, RETURN THROUGH WITH RESULTS.
;
REQ_SENSE_Z0
               MOVEM.L (A7)+,D1-D3/A0
REQ_SENSE_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA


















;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; Note - this routine adapted from 3002 sources,
; which is more or less fitting, since the 3002 sources were
; largely adapted from 440 sources in the first place ....
;
; READ CAPACITY OF SCSI DRIVE -
; DRIVE_SEL.W INDICATES WHICH SCSI CHANNEL TO DEAL WITH.
;
; RETURNS Z FLAG TRUE AND D0.W undefined IF CAPACITY IS SUCCESSFULLY READ,
; WITH CAPACITY (AS LOGICAL BLOCK ADDR OF HIGHEST RECORD) IN D1.L.
; ELSE RETURNS Z FLAG FALSE AND ERROR CODE IN D0, WITH D1 UNDEFINED.
;
; NOTE:  TRIGGERS A COMPLETE SCSI SEQUENCE.
; ASSUME D0-D1 PLASTERED, OTHER REGISTERS CLEAN AND SOBER.
;
;
read_capacity
               MOVEM.L D2-D3/A0,-(A7)       ;SAVE REGISTERS WE NEED TO USE (BUT NOT DESTROY).
               SUBQ.L  #8,A7                ;RESERVE SPACE ON STACK FOR READ-CAPACITY DATA.
;
               BSR     SELECT_DEVICE        ;TRY TO SELECT TARGET DEVICE -
               BNE.S   READCAPAC_Z0         ;EXIT IF SELECTION UNSUCCESSFUL.
;
                                            ;TARGET RESPONDED TO SELECTION -
;
               move.w  #2500h,SCSI_CMD_BUF  ; set up read-capacity command
               clr.l   SCSI_CMD_BUF+2       ; in command buffer.
               clr.l   SCSI_CMD_BUF+6
;
               BSR     TEN_BYTE_CMD         ;ISSUE READ CAPACITY COMMAND TO TARGET.
               BNE.S   READCAPAC_Z0         ;EXIT IF COMMAND NOT ISSUED SUCCESSFULLY.
;
                                            ;SET UP TO READ EIGHT DATA BYTES INTO TEMP BUFFER:
               MOVEQ   #DAT_IN_PHASE,D0     ;WE'RE EXPECTING DATA-IN PHASE FOR THIS.
               clr.w   D1                   ;SKIP NONE OF THE INCOMING DATA.
               MOVEQ   #8,D2                ;READ EIGHT DATA BYTES.
               clr.w   D3                   ;NO EXCESS BYTES TO DISCARD.
;
               movea.l A7,A0                ;SET POINTER TO TEMP BUFFER RESERVED AT TOP OF STACK.
               BSR     SCSI_RAM_READ        ;GET DEM BYTE.
               BNE.S   READCAPAC_Z0         ;EXIT IF DATA READ WAS UNSUCCESSFUL.
;
               MOVE.L  (A7),D1              ;COPY THE CAPACITY VALUE (IGNORE BLOCK LENGTH).
;
               BSR     FINISH_SCSI_SEQ      ;GET COMPLETION STATUS, RETURN THROUGH WITH RESULTS.
;
READCAPAC_Z0
               ADDQ.L  #8,A7                ;CLEAR TEMP READ CAPACITY BUFFER FROM STACK.
               MOVEM.L (A7)+,D2-D3/A0
;
READCAPAC_EXIT
               RTS
;
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA


















;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
;
;
; 921008-12:17pm
; this routine derived from read_capacity (above).
;
; issue test unit ready command to target device.
; DRIVE_SEL.W indicates which scsi channel to deal with.
;
; returns z flag true and d0.w undefined if target responds as ready,
; else returns z flag false and error code in d0.
; 921008-12:29pm
; note that this is assumed, but not necessarily tested -
; as of this date, we're mainly using it as a no-op scsi command to clear
; pending unit attention if present, and we don't look at what it sends back.
;
; note:  triggers a complete scsi sequence.
; assume d0 plastered, other registers clean and sober.
;
;
;
test_unit_ready
;
       bsr     SELECT_DEVICE      ; try to select target device -
       bne.s   tstr_z0            ; exit if selection unsuccessful.
;                                   
					; target responded to selection -
;                                   
       clr.l   SCSI_CMD_BUF       ; set up test unit ready command
       clr.w   SCSI_CMD_BUF+4     ; in command buffer.
;                                   
       bsr     SIX_BYTE_CMD       ; issue command to target.
       bne.s   tstr_z0            ; exit if command not issued successfully.
;                                   
					; no data phase ....
;                                   
       bsr     FINISH_SCSI_SEQ    ; get completion status, return through 
                                  ; with results.
;                                     
tstr_z0                          
tstr_ex
	rts
;
;
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA


















;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; WRITE 12-BIT SAMPLE RAM DATA TO TARGET -
; USES DATA-PACKING PER FLOPPY DISK SAMPLE DATA FORMAT.
; NO INPUT PARAMETERS, SINCE WE ALWAYS SAVE ALL OF SAMPLE RAM,
; WHICH HAPPENS TO FIT EVENLY INTO 600H RECORDS (AT 512 BYTES PER) -
; THIS ROUTINE DOES 10000H 12-BIT WORDS (0C0H RECORDS) PER CALL,
; MUST BE CALLED EIGHT TIMES IN ORDER TO COVER ALL OF SAMPLE MEMORY.
; ASSUMES THAT SAMPLE RAM INTERFACE HAS ALREADY BEEN SET UP AS NEEDED.
; RETURNS Z FLAG TRUE IF TRANSFER IS SUCCESSFUL, ELSE RETURNS Z FLAG
; FALSE AND ERROR CODE IN D0.
; IN ALL CASES, 5380 DMA MODE IS DISABLED BEFORE RETURNING.
; DESTROYS D0.
;
;      THE DATA PACKING/UNPACKING ALGORITHM LOOKS LIKE THIS:
;
;        IN 12-BIT RAM                           ON DISK:
;      (AS READ BY CPU):
;              1   1
;              5   1      4                            7      0        .
;   WORD 1     bbbbyyyyyyyy0000              BYTE 2    yyyyyyyy       /|\
;   WORD 0     aaaaxxxxxxxx0000              BYTE 1    bbbbaaaa        |
;                                            BYTE 0    xxxxxxxx        |    HIGHER ADDRESSES
;                                                                      |
SCSI_SAM_WRITE
               MOVEM.L D1-D5,-(A7)
               MOVEQ   #DAT_OUT_PHASE,D0    ;AWAIT/ACCOMMODATE DATA-OUT PHASE.
               BSR     PHASE_CHANGE
               BNE     SC_SAM_WR_B0         ;EXIT IF IT DIDN'T HAPPEN.
;
               MOVE.L  #10000H,D2           ;WRITE 128*512 12-BIT WORDS.
               MOVE.L  #500000,D4           ;SET UP /REQ TIMEOUT COUNTER.
SC_SAM_WR_10
               MOVE    RD_SAM_RAM,D0        ;FETCH WORD 0,
               ;
               ;       DELAY HERE AS NEEDED ....
               ;
;881025               REPT    16
               .FOR COUNT = 1,16
               NOP
               .ENDFOR

               LSR     #4,D0                ;SET UP BYTE 0 FOR WRITE TO TARGET.
SC_SAM_WR_20
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_SAM_WR_30         ;BRANCH IF YES - DO THAT DATA THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_SAM_WR_20         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_SAM_WR_B0
SC_SAM_WR_30
               MOVE.B  D0,SCSI_DMA_WR       ;WRITE BYTE 0 TO TARGET.
               MOVE    RD_SAM_RAM,D1        ;FETCH WORD 1,
               ;
               ;       DELAY HERE AS NEEDED ....
               ;
               MOVE    D1,D5                ;COPY FOR BYTE 1 ASSEMBLY.
               AND     #0F000H,D5           ;ISOLATE WORD 1 M.S.NIBBLE,
               OR      D5,D0                ;DROP IN ALONGSIDE THAT OF WORD 0,
               LSR     #8,D0                ;SHIFT DOWN TO CREATE BYTE 1 IN D0.B.
SC_SAM_WR_40
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_SAM_WR_50         ;BRANCH IF YES - DO THAT DATA THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_SAM_WR_40         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_SAM_WR_B0
SC_SAM_WR_50
               MOVE.B  D0,SCSI_DMA_WR       ;WRITE BYTE 1 TO TARGET.
               LSR     #4,D1                ;SET UP BYTE 2 IN D1.B.
SC_SAM_WR_60
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_SAM_WR_70         ;BRANCH IF YES - DO THAT DATA THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_SAM_WR_60         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_SAM_WR_B0
SC_SAM_WR_70
               MOVE.B  D1,SCSI_DMA_WR       ;WRITE BYTE 2 TO TARGET.
;
   ;;;; OPTIMIZATION NOTE - MOVE THIS TEST UP TO THE TOP, FOLLOWING SAMPLE READ ....
               SUBQ.L  #2,D2                ;HAVE WE WRITTEN ALL "REAL" WORDS YET?
               BNE     SC_SAM_WR_10         ;BRANCH IF NOT, DO S'MORE.
;
SC_SAM_WR_A0
               CLR     D0                   ;NO-ERROR RETURN, Z FLAG TRUE.
;
SC_SAM_WR_B0
               MOVE.B  #0,SCSI_MODE_WR      ;DISABLE DMA MODE TO TURN OFF /ACK.
               TST     D0                   ;REFRESH Z FLAG BEFORE RETURNING.
SC_SAM_WR_C0
               MOVEM.L (A7)+,D1-D5
SC_SAM_WR_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; READ 12-BIT SAMPLE RAM DATA FROM TARGET -
; USES DATA-UNPACKING PER FLOPPY DISK SAMPLE DATA FORMAT.
;
;17MAR;
;17MAR; D1.W INDICATES NUMBER OF TARGET BYTES TO DISCARD BEFORE STORE BEGINS,
;17MAR;
;
; D2.L INDICATES NUMBER OF "REAL" 12-BIT WORDS (NOT BYTES) TO READ,
;
;17MAR; D3.W INDICATES NUMBER OF ADDITIONAL FILLER BYTES TO DISCARD
;17MAR; (WHERE NEEDED, IN ORDER TO FINISH READING THE LAST LOGICAL BLOCK).
;
;              NOTE: SINCE SAMPLES ARE ALWAYS DEALT WITH IN BLOCKS OF
;              1K-WORD, WHICH AT 12-BITS PER WORD FITS EVENLY INTO THREE
;              WHOLE RECORDS OF 512 BYTES EACH, WE SHOULD NEVER NEED TO
;              USE THE SKIP/FILLER PARAMETERS.  IF RECORD SIZE EVER GETS
;              CHANGED, WELL, THAT WILL BE ANOTHER STORY ALTOGETHER.
;
; ASSUMES THAT SAMPLE RAM INTERFACE HAS ALREADY BEEN SET UP AS NEEDED.
; RETURNS Z FLAG TRUE IF TRANSFER IS SUCCESSFUL, ELSE RETURNS Z FLAG
; FALSE AND ERROR CODE IN D0.
; IN ALL CASES, 5380 DMA MODE IS DISABLED BEFORE RETURNING.
; DESTROYS D0.
;
SCSI_SAM_READ
               MOVEM.L D1-D5,-(A7)
               MOVEQ   #DAT_IN_PHASE,D0     ;AWAIT/ACCOMMODATE DATA-IN PHASE.
               BSR     PHASE_CHANGE
               BNE     SC_SAM_RD_D0         ;EXIT IF IT DIDN'T HAPPEN.
;
               MOVE.L  #500000,D4           ;SET UP /REQ TIMEOUT COUNTER.
;
;17MAR               TST     D1                   ;DISCARD ANY TARGET BYTES BEFORE STORE BEGINS?
;17MAR               BEQ.S   SC_SAM_RD_30         ;BRANCH IF NOT, STORE FROM BEGINNING.
;17MAR               SUBQ    #1,D1                ;ELSE, READ AND DISCARD THE INDICATED NUMBER OF BYTES.
;17MARSC_SAM_RD_10
;17MAR               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
;17MAR               BNE.S   SC_SAM_RD_20         ;BRANCH IF YES - DO THAT DATA-SKIP THING.
;17MAR               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
;17MAR               BNE     SC_SAM_RD_10         ;LOOP AGAIN IF STILL TIME LEFT.
;17MAR               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
;17MAR               BRA     SC_SAM_RD_D0
;17MARSC_SAM_RD_20
;17MAR                                            ;GOT /REQ FROM TARGET -
;17MAR               MOVE.B  SCSI_DMA_RD,D0       ;READ AND DISCARD A BYTE.
;17MAR               DBRA    D1,SC_SAM_RD_10      ;LOOP AGAIN IF WE'RE NOT DONE WITH BYTE-SKIP READ.
;
SC_SAM_RD_30
               CLR     D0                   ;CLEAR THE WAY FOR BYTE 0.
SC_SAM_RD_40
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_SAM_RD_50         ;BRANCH IF YES - DO THAT DATA THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_SAM_RD_40         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA     SC_SAM_RD_D0
SC_SAM_RD_50
               MOVE.B  SCSI_DMA_RD,D0       ;READ BYTE 0 (WORD 0 L.S.BYTE) FROM TARGET.
               LSL     #4,D0                ;POSITION FOR COMBINE WITH WORD 0 M.S.NIBBLE.
               CLR     D1                   ;CLEAR THE WAY FOR BYTE 1.
SC_SAM_RD_60
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_SAM_RD_70         ;BRANCH IF YES - DO THAT DATA THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_SAM_RD_60         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_SAM_RD_D0
SC_SAM_RD_70
               MOVE.B  SCSI_DMA_RD,D1       ;READ BYTE 1 FROM TARGET.
               MOVE    D1,D5                ;COPY FOR WORD 0 ASSEMBLY.
               ROR     #4,D5                ;POSITION WORD 0 M.S.NIBBLE,
               OR      D5,D0                ;COMBINE WITH WORD 0 L.S.BYTE,
               MOVE    D0,WR_SAM_RAM        ;STORE WORD 0 TO SAMPLE RAM.
               ;
               ;       DELAY HERE AS NEEDED ....
               ;
;881025               REPT    14
               .FOR COUNT = 1,14
               NOP
               .ENDFOR

               LSL     #4,D1                ;POSITION WORD 1 M.S.NIBBLE FOR COMBINE WITH L.S.BYTE.
SC_SAM_RD_80
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_SAM_RD_90         ;BRANCH IF YES - DO THAT DATA THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_SAM_RD_80         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_SAM_RD_D0
SC_SAM_RD_90
               MOVE.B  SCSI_DMA_RD,D1       ;READ BYTE 2, COMBINE WITH WORD 1 M.S.NIBBLE.
               LSL     #4,D1                ;POSITION WORD 1 FOR STORE TO SAMPLE RAM,
               MOVE    D1,WR_SAM_RAM        ;STORE IT.
               ;
               ;       DELAY HERE AS NEEDED ....
               ;
               SUBQ.L  #2,D2                ;DONE READING "REAL" SAMPLE WORDS YET?
               BNE     SC_SAM_RD_30         ;LOOP AGAIN IF NOT.
               CLR     D0                   ;NO-ERROR RETURN: Z FLAG TRUE, D0 = 0.
;
;17MAR               TST     D3                   ;WE'VE READ ALL "REAL" WORDS - ANY EXTRA TO READ?
;17MAR               BEQ.S   SC_SAM_RD_C0         ;BRANCH IF NOT, DO NORMAL EXIT.
;17MAR               SUBQ    #1,D3                ;ELSE, READ INDICATED NUMBER OF EXTRA BYTES.
;17MARSC_SAM_RD_A0
;17MAR               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
;17MAR               BNE.S   SC_SAM_RD_B0         ;BRANCH IF YES - DO THAT DATA-SKIP THING.
;17MAR               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
;17MAR               BNE     SC_SAM_RD_A0         ;LOOP AGAIN IF STILL TIME LEFT.
;17MAR               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
;17MAR               BRA.S   SC_SAM_RD_D0
;17MARSC_SAM_RD_B0
;17MAR                                            ;GOT /REQ FROM TARGET -
;17MAR               MOVE.B  SCSI_DMA_RD,D0       ;READ AND DISCARD A BYTE.
;17MAR               DBRA    D3,SC_SAM_RD_A0      ;LOOP AGAIN IF WE'RE NOT DONE READING EXTRA BYTES.
;17MARSC_SAM_RD_C0
;17MAR               CLR     D0                   ;NO-ERROR RETURN, Z FLAG TRUE.
;
SC_SAM_RD_D0
               MOVE.B  #0,SCSI_MODE_WR      ;DISABLE DMA MODE TO TURN OFF /ACK.
               TST     D0                   ;REFRESH Z FLAG BEFORE RETURNING.
SC_SAM_RD_E0
               MOVEM.L (A7)+,D1-D5
SC_SAM_RD_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; COMPARE 12-BIT SAMPLE RAM DATA WITH DATA FROM TARGET -
; USES DATA-UNPACKING PER FLOPPY DISK SAMPLE DATA FORMAT.
; NO INPUT PARAMETERS, SINCE WE ALWAYS COMPARE ALL OF SAMPLE RAM,
; WHICH HAPPENS TO FIT EVENLY INTO 600H RECORDS (AT 512 BYTES PER) -
; THIS ROUTINE DOES 10000H 12-BIT WORDS (0C0H RECORDS) PER CALL,
; MUST BE CALLED EIGHT TIMES IN ORDER TO COVER ALL OF SAMPLE MEMORY.
; ASSUMES THAT SAMPLE RAM INTERFACE HAS ALREADY BEEN SET UP AS NEEDED,
; AND THAT SCSI_VER_FLAG (.B) = 00H UPON ENTRY (NO ERRORS).
; SETS SCSI_VER_FLAG IF ANY COMPARE ERRORS ARE ENCOUNTERED -
; ELSE RETURNS SCSI_VER_FLAG = 00H.
; RETURNS Z FLAG TRUE IF NO SCSI TRANSFER ERRORS OCCUR,
; ELSE RETURNS Z FLAG FALSE AND SYSTEM ERROR CODE IN D0 -
; I.E., Z FLAG TRUE DOES NOT NECESSARILY MEAN NO COMPARE ERRORS.
; IN ALL CASES, 5380 DMA MODE IS DISABLED BEFORE RETURNING.
; DESTROYS D0.
;
SCSI_SAM_VERIFY
               MOVEM.L D1-D5,-(A7)
               SF      SCSI_VER_FLAG        ;CLEAR COMPARE-ERROR FLAG.
               MOVEQ   #DAT_IN_PHASE,D0     ;AWAIT/ACCOMMODATE DATA-IN PHASE.
               BSR     PHASE_CHANGE
               BNE     SC_SAM_VR_B0         ;EXIT IF IT DIDN'T HAPPEN.
;
               MOVE.L  #10000H,D2           ;COMPARE 128*512 12-BIT WORDS.
               MOVE.L  #500000,D4           ;SET UP /REQ TIMEOUT COUNTER.
SC_SAM_VR_10
               MOVE    RD_SAM_RAM,D0        ;FETCH WORD 0,
               ;
               ;       DELAY HERE AS NEEDED ....
               ;
;881025               REPT    16
               .FOR COUNT = 1,16
               NOP
               .ENDFOR

               LSR     #4,D0                ;SET UP BYTE 0 FOR COMPARE TO TARGET DATA.
SC_SAM_VR_20
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_SAM_VR_30         ;BRANCH IF YES - DO THAT DATA-COMPARE THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_SAM_VR_20         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_SAM_VR_B0
SC_SAM_VR_30
               CMP.B   SCSI_DMA_RD,D0       ;COMPARE BYTE 0.
               BEQ.S   SC_SAM_VR_34         ;BRANCH IF COMPARE OK,
               ST      SCSI_VER_FLAG        ;ELSE SET COMPARE-ERROR FLAG.
SC_SAM_VR_34
               MOVE    RD_SAM_RAM,D1        ;FETCH WORD 1,
               ;
               ;       DELAY HERE AS NEEDED ....
               ;
               MOVE    D1,D5                ;COPY FOR BYTE 1 ASSEMBLY.
               AND     #0F000H,D5           ;ISOLATE WORD 1 M.S.NIBBLE,
               OR      D5,D0                ;DROP IN ALONGSIDE THAT OF WORD 0,
               LSR     #8,D0                ;SHIFT DOWN TO CREATE BYTE 1 IN D0.B.
SC_SAM_VR_40
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_SAM_VR_50         ;BRANCH IF YES - DO THAT DATA-COMPARE THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_SAM_VR_40         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_SAM_VR_B0
SC_SAM_VR_50
               CMP.B   SCSI_DMA_RD,D0       ;COMPARE BYTE 1.
               BEQ.S   SC_SAM_VR_54         ;BRANCH IF COMPARE OK,
               ST      SCSI_VER_FLAG        ;ELSE SET COMPARE-ERROR FLAG.
SC_SAM_VR_54
               LSR     #4,D1                ;SET UP BYTE 2 IN D1.B.
SC_SAM_VR_60
               BTST    #6,SCSI_BS_REG       ;DO WE HAVE A DMA REQUEST (I.E., /REQ FROM TARGET)?
               BNE.S   SC_SAM_VR_70         ;BRANCH IF YES - DO THAT DATA-COMPARE THING.
               SUBQ.L  #1,D4                ;ELSE - TIME'S RUNNING OUT ....
               BNE     SC_SAM_VR_60         ;LOOP AGAIN IF STILL TIME LEFT.
               MOVEQ   #REQ_TIMEOUT,D0      ;TIME'S UP - RETURN ERROR CODE.
               BRA.S   SC_SAM_VR_B0
SC_SAM_VR_70
               CMP.B   SCSI_DMA_RD,D1       ;COMPARE BYTE 2.
               BEQ.S   SC_SAM_VR_74         ;BRANCH IF COMPARE OK,
               ST      SCSI_VER_FLAG        ;ELSE SET COMPARE-ERROR FLAG.
SC_SAM_VR_74
;
   ;;;; OPTIMIZATION NOTE - MOVE THIS TEST UP TO THE TOP, FOLLOWING SAMPLE READ ....
               SUBQ.L  #2,D2                ;HAVE WE WRITTEN ALL "REAL" WORDS YET?
               BNE     SC_SAM_VR_10         ;BRANCH IF NOT, DO S'MORE.
;
SC_SAM_VR_A0
               CLR     D0                   ;NO-ERROR RETURN, Z FLAG TRUE.
;
SC_SAM_VR_B0
               MOVE.B  #0,SCSI_MODE_WR      ;DISABLE DMA MODE TO TURN OFF /ACK.
               TST     D0                   ;REFRESH Z FLAG BEFORE RETURNING.
SC_SAM_VR_C0
               MOVEM.L (A7)+,D1-D5
SC_SAM_VR_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

