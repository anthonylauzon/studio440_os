               INCLUDE HPFIXUPS
               TITLE "TEMPO CONTROL SUBROUTINES"
***************************************************************************************************
***************************************************************************************************
***                                                                                             ***
***             TEMPO_SUBS - ROUTINES FOR CHANGING TEMPO                                        ***
***                                                                                             ***
***************************************************************************************************
***************************************************************************************************
;
NEG_EXT        EQU     0FFFFFF00H      ;USE IN MOVEQ INSTRUCTIONS WHERE ARG IS
                                       ;80H OR LARGER - HP XASM DOES NOT HANDLE
                                       ;SIGN-EXTEND CORRECTLY.  COSMETIC, KEEPS
                                       ;ACTUAL BYTE VALUE CLEARER.
;
               INCLUDE EQUATES         ;HDW ADDR AND CONSTANT DEFS, ABS_SHORT DIRECTIVE.
;
               INCLUDE SEQDEFS         ;SEQUENCER CONSTANT DEFINITIONS.
;
               GLB     TEMPO_UP_SWITCH,TEMPO_DOWN_SWITCH,TAP_BUTTON
               GLB     START_ACC_RIT,UPDATE_ACC_RIT
               GLB     TAP_TIME_OFFSET
               GLB     TAP_STOP,TAP_RECORD
               GLB     INIT_TEMPO_TO_ALL,USEC_TO_ALL
;
                                            ;EXTERNAL ROM.
               EXTERNAL  UNPLUG_ALL_EDITS,WRITE_SCREEN,WRITE_VALUE
               EXTERNAL  DISP_BUFFER,DISP_FIELD,SET_AUTOSCROLL
               EXTERNAL  CLOCK_TEMPO_SUB,UH_UH_TAP_SUB
               EXTERNAL  WRITE_TO_TC
               EXTERNAL  TEMPO_CHANGE_SUB
               EXTERNAL  SEQ_WRITE
               EXTERNAL  SEQ1_DSTR_READ
               EXTERNAL  SEQ1_RMW_EATER
               EXTERNAL  BAR_MARKER_HANDLER
               EXTERNAL  SEQ1_DRD_SETUP
               EXTERNAL  SEQ_CONSOLIDATE,SEQ_TURNAROUND,UPDATE_SEQ_SIZE
               EXTERNAL  GET_CUR_SEQ_DIR,Q_INIT_TEMPO
;
                                            ;RAM
               EXTERNAL  LED_STEADY,LED_EXTINGUISH,NOW_LAST_BAR
               EXTERNAL  CUR_TEMPO_BPM,CUR_TEMPO_USEC,INIT_TEMPO_USEC
               EXTERNAL  ACCEL_RIT_B_LEFT,ACCEL_RIT_BEATS,ACCEL_RIT_DELTA,ACCEL_RIT_REM
               EXTERNAL  HITSTORY_1,HITSTORY_2,HITSTORY_3,HITSTORY_4,HITSTORY_5,HITSTORY_6,HITSTORY_7
               EXTERNAL  HITSTORY_8,TAP_SLEW_AMOUNT,TAP_SLEW_COUNT,LAST_TAP_TIME,TAP_DIV_FLAG
               EXTERNAL  INIT_TEMPO_FPB,NOW_SEQ_STATUS
               EXTERNAL  INIT_TEMPO_BPM
               EXTERNAL  SHOWING_TEMPO
               EXTERNAL  CUR_T_BPM_8
               EXTERNAL  REAL_TIME
               EXTERNAL  REAL_LONG_TIME
               EXTERNAL  SCRN_DM_TIMER
               EXTERNAL  SCRN_DM_PERIOD
               EXTERNAL  SCROLLING
               EXTERNAL  NOW_CLICK,NOW_BAR,CLICKS_THIS_BAR
               EXTERNAL  SMPTE_NOW_T_1
               EXTERNAL  SMPTE_NOW_HR,SMPTE_NOW_BT
               EXTERNAL  SMPTE_START_HR,SMPTE_START_BT
               EXTERNAL  CUR_TEMPO_FPB
               EXTERNAL  REF_TEMPO_USEC
               EXTERNAL  COUNT_IN_METHOD
               EXTERNAL  TAP_TRACK_ON_FLAG
               EXTERNAL  CUR_SUB_BLOCK
               EXTERNAL  SUBFUN_INSTALL,UPDATE_LCD,REDISP_FIELD
               EXTERNAL  XPORT_STATE
               EXTERNAL  LAST_TAP_LENGTH
               EXTERNAL  TAP_TIME_START,BG_TEMP_9_B
               EXTERNAL  NOW_BEAT
               EXTERNAL  CLICKS_PER_TAP
               EXTERNAL  HOLDING_EVENT
               EXTERNAL  SEQ_WR_PTR
               EXTERNAL  SEQ1_DRD_PTR
               EXTERNAL  STARTED_TAPPING
               EXTERNAL  CURSOR_ENABLE
               EXTERNAL  DIAGS_ENABLED
               EXTERNAL  RAW_DENOMINATOR
               EXTERNAL  PARAM_LO_LIM
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; HERE IS WHERE ALL TEMPO MANAGEMENT TAKES PLACE ....
;
; TEMPO CHANGES FROM ANY SOURCE ARE (UNDER MOST CONDITIONS) TRANSMITTED
; TO THE 6803 TIMING SUBSYSTEM, WHICH PUTS THEM INTO EFFECT FOR THE NEXT
; 96th NOTE (CLICK).  TEMPO IS GIVEN TO THE TIME CHIP IN TERMS OF uSEC
; PER CLICK.
;
; TEMPO IS SET/CHANGED BY THE FOLLOWING MECHANISMS OR ENTITIES:
;
; 1. SEQUENCE INITIAL TEMPO.  DOWNLOADED WHENEVER A NEW SEQUENCE IS CUED
;    UP OR WHEN SEQUENCER IS STOPPED - WHO KNOWS, PROBABLY EVEN WHEN THE
;    CURRENT SEQUENCE'S INITIAL TEMPO IS EDITED.
;
; 2. THE TEMPO UP/DOWN SWITCHES.  THESE ALLOW TEMPO CHANGES OF AS LITTLE
;    AS 0.1 BPM, WITH ACCELERATING AUTOSCROLL.
;
; 3. THE TAP BUTTON.  IT'S ALWAYS ALIVE - JUST HITTING IT A FEW TIMES
;    CHANGES THE CURRENT TEMPO (UNDER INTERNAL TIMEBASE OR SMPTE SYNC).
;    DEPENDING UPON SYSTEM SETTING, TEMPO IS SLEWED OVER ANYWHERE FROM
;    TWO TO EIGHT TAP STROKES.  WHEN THE SEQUENCER IS NOT RUNNING, THE
;    TAPPED-IN TEMPO BECOMES THE INITIAL TEMPO FOR THE CURRENT SEQUENCE,
;    AND THE SEQUENCER STARTS AFTER n TAPS IF TAP-IN START IS ACTIVATED.
;
; 4. ACCELERANDO/RITARDANDO EVENTS.  GIVEN AS AN OFFSET FROM THE CURRENT
;    TEMPO AND THE NUMBER OF BEATS OVER WHICH IT IS TO BE DISTRIBUTED.
;    THIS IS TRANSLATED INTO A TEMPO DELTA PER 96th NOTE AND A NUMBER OF
;    96th NOTES OVER WHICH TO CHANGE TEMPO - POSSIBLY WITH AN EXTRA 96th
;    NOTE TO COVER ANY REMAINDER.  A ROUTINE IN THIS MODULE IS CALLED AT
;    THE END OF PROCESSING OF EACH CLICK TO NUDGE ANY TEMPO CHANGE
;    IN PROGRESS ALONG BY THE PER-CLICK AMOUNT (IT'S RESOLVED TO 0.0125
;    BPM, HENCE POSSIBILITY OF A REMAINDER AND EXTRA CLICK TO FINISH).
;
; 5. TAP-TRACK EVENTS.  RECORDED INTO A SEQUENCE UNDER TAP-TRACK RECORD
;    MODE AS DELTAS FROM A REFERENCE TEMPO (THE INITIAL TEMPO IN EFFECT
;    AT THAT TIME).  SINCE, DURING ANY PLAYBACK, THE CURRENT TEMPO AT
;    ANY POINT MAY BE DIFFERENT FROM THE RECORDED REFERENCE TEMPO (OWING
;    TO EFFECTS OF ANY OF THE ABOVE TEMPO-CHANGING DEVICES), TAP-TRACK
;    EVENTS ARE HANDLED BY FORMING A RATIO BETWEEN THE CURRENT TEMPO AND
;    THE RECORDED REFERENCE TEMPO, AND THEN USING THIS RATIO TO SCALE
;    THE RECORDED TEMPO DELTA BEFORE PUTTING IT INTO EFFECT.
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; TEMPO UP/DOWN SWITCH HANDLER - AUT-TOE-SCROLE AN' EVER'THANG.
; OVERALL, PRETTY SELF-EXPLANATORY.  THE FUNNY BIZNISS A LITTLE WAYS IN
; ABOUT LOOKING FOR BOTH OF THE SWITCHES BEING HELD DOWN AT ONCE IS A
; CHEEP KLUDGE ALLOWING THE TEMPO UP/DOWN SWITCHES TO HOLD THE TEMPO IN
; THE DISPLAY WITHOUT AUTOSCROLLING IT - IN REALITY, HOWEVER, THE FIRST
; SWITCH HIT (AND ONE OF THEM IS ALWAYS HIT FIRST) WILL REGISTER A 0.1
; BPM STEP.  WITH A LITTLE PRACTICE YOU CAN GET IT TO WHERE THE OPPOSITE
; INCREMENT TAKES PLACE ON THE UPSTROKE, LEAVING TEMPO WHERE IT WAS ....
; OR, YOU CAN CHEAT AND USE THE "CURRENT TEMPO" DISPLAY SCREEN.
;
; ANYWAY - PUTS UP A SCREEN WHICH PERSISTS UNTIL 1 SEC. AFTER SWITCH(ES)
; ARE RELEASED, AT WHICH POINT REINSTALLATION OF THE CURRENT SUBFUNCTION
; IS REQUESTED (BACKGROUND TIMES OUT, PICKS UP THE INSTALL REQUEST).
;
TEMPO_UP_SWITCH
               MOVEQ   #51,D1               ;SWITCH NUMBER FOR TEMPO UP SWITCH.
               MOVEQ   #1,D0                ;INCREMENT CUR_TEMPO_BPM.
               BRA.S   TEMPO_SWITCH         ;HEAD FOR GENERAL HANDLER.
;
;
;
TEMPO_DOWN_SWITCH
               MOVEQ   #52,D1               ;SWITCH NUMBER FOR TEMPO UP SWITCH.
               MOVEQ   #-1,D0               ;DECREMENT CUR_TEMPO_BPM.
                                            ;FALL THROUGH INTO GENERAL HANDLER.
;
;
TEMPO_SWITCH
               MOVE    SWITCH_INPUT+0CH,D2  ;DUAL-SWITCH CATCH-OUT ....
               BTST    #5,D2
               BNE     TEMP_SW_Z0
;
                ABS_LONG
               JSR     SET_AUTOSCROLL       ;START UP THE AUTOSCROLL-THING, IF NOT ALREADY STARTED.
                ABS_SHORT
;
                                            ;NOW - ARE BOTH TEMPO SWITCHES BEING HELD DOWN?
               AND     #18H,D2              ;MASK SWITCH IMAGE TO ONLY THESE TWO SWITCHES -
               CMP     #18H,D2              ;WE GOT 'EM BOTH?
               BEQ.S   TEMP_SW_50           ;BRANCH IF YES - NO UPDATE, RESTART AUTOSCROLL (SLOW).
;
               ADD     CUR_TEMPO_BPM,D0     ;ELSE - UPDATE PER INCREMENT OR DECREMENT VALUE IN D0.
               CMP     #400,D0              ;LOW LIMIT (40.0).
               BGE.S   TEMP_SW_30
               MOVE    #400,D0
TEMP_SW_30
               CMP     #2500,D0             ;HIGH LIMIT (250.0).
               BLE.S   TEMP_SW_40
               MOVE    #2500,D0
TEMP_SW_40
               MOVE    D0,CUR_TEMPO_BPM     ;STORE NEW BEATS-PER-MINUTE VALUE.
;
               MOVEM.L D0-D1/A0,-(A7)       ;NOW, UPDATE OTHER TEMPO VARS, NOTIFY TIMING CHIP TOO.
               MOVE.L  #25000000,D1         ;CONVERT FROM BPM TO usec/CLICK,
               DIVU    D0,D1                ;BY TAKING 25000000/BPM*10.
               MOVE    D1,CUR_TEMPO_USEC
               BSR     USEC_TO_ALL          ;CONVERT TO ALL OTHER FORMS, TELL TIMING CHIP.
               MOVE    CUR_TEMPO_USEC,REF_TEMPO_USEC  ;MAKE NEW REF TEMPO (FOR TAP TRACK).
               MOVEM.L (A7)+,D0-D1/A0
;
               BRA.S   TEMP_SW_60           ;DON'T BOTHER RESTARTING AUTOSCROLL.
;
TEMP_SW_50
               CLR     SCROLLING            ;BOTH SWITCHES HELD - RESTART AUTOSCROLL (SLOW).
                ABS_LONG
               JSR     SET_AUTOSCROLL
                ABS_SHORT
;
TEMP_SW_60
               MOVE    REAL_TIME,SCRN_DM_TIMER   ;START/RESTART SCREEN_DAEMON -
               BSET    #0,SCRN_DM_TIMER+1        ;THIS MAY BE THE LAST TIME THROUGH HERE FOR A BIT.
                                                 ;REMEMBER? TIMER MUST BE NON-ZERO TO BE ACTIVE.
               MOVE    #1000,SCRN_DM_PERIOD      ;SET IT TO GO OFF IN ABOUT A SECOND.
;
                                            ;NOW IT'S "TIME" (HACE TIEMPO) TO DISPLAY TEMPO:
               SF      CURSOR_ENABLE        ;FIRST OFF - WE DON'T WANNA SEE THE CURSOR ON-SCREEN.
               MOVE    CUR_TEMPO_BPM,D0     ;FETCH CUR_TEMPO_BPM AGAIN FOR DISPLAY -
               MOVE    #0705H,D1            ;ALSO FETCH FIELD POSITION/LENGTH SPEC,
               MOVEQ   #21H,D2              ;SET DISPLAY CTRLS - LEADING-ZERO BLANK, 1 DEC PLACE.
               TST.B   SHOWING_TEMPO        ;IS TEMPO SCREEN ALREADY UP IN LCD?
               BNE.S   TEMP_SW_70           ;BRANCH IF YES, JUST REDISPLAY FIELD.
               ST      SHOWING_TEMPO        ;ELSE, SET FLAG AND DO IT UP -
               SF      SUBFUN_INSTALL       ;ALSO, CLEAR ANY OTHER FLAGS WHICH COULD WASTE THE
               SF      UPDATE_LCD           ;SCREEN DATA IF THEY WERE ALREADY SET WHEN WE GOT HERE.
               SF      REDISP_FIELD
                ABS_LONG
               JSR     UNPLUG_ALL_EDITS     ;DISCONNECT ALL NORMAL EDIT PATHWAYS.
               MOVE.L  #LIV_TEMP_SCREEN,A1  ;SET UP SCREEN TEXT IN SCREEN_BUFFER.
               JSR     WRITE_SCREEN
               JSR     WRITE_VALUE          ;DISPLAY TEMPO BPM VALUE (IT'S STILL IN D0).
                ABS_SHORT
               MOVEQ   #21H,D2              ;SET DISPLAY CTRLS - LEADING-ZERO BLANK, 1 DEC PLACE.
               MOVE    #1404H,D1            ; SET WHERE IT WILL APPEAR
               MOVE    CUR_TEMPO_FPB,D0     ;  SET FPB VALUE TO DISPLAY
                ABS_LONG
               JSR     WRITE_VALUE          ;WRITE D0 VALUE INTO SCREEN_BUFFER PER D1-D2 CTRLS.
               JSR     DISP_BUFFER          ;PUT OUT THE SCREEN TEXT RIGHT NOW -
                                            ;OTHERWISE, SEQUENCER-INDUCED SUBFUN-INSTALL (E.G., BAR
                                            ;AND BEAT SCREEN UPDATE) MAY WHOMP THE TEMPO SCREEN
                                            ;BUFFER DATA BEFORE IT GETS OUT TO LCD.
                ABS_SHORT
               BRA.S   TEMP_SW_EXIT
;
TEMP_SW_70
                                            ;COME HERE TO UPDATE AN ALREADY-DISPLAYED TEMPO SCREEN:
                ABS_LONG
                                            ;D0 CONTAINS CUR_TEMPO_BPM VALUE -
               JSR     WRITE_VALUE          ;WRITE D0 VALUE INTO SCREEN_BUFFER PER D1-D2 CTRLS.
               JSR     DISP_FIELD           ;COPY BUFFER FIELD TO LCD PER SAME CONTROLS.
                ABS_SHORT
                                            ;NOW DO IT AGAIN FOR FRAMES-PER-BEAT VERSION OF TEMPO.
               MOVEQ   #21H,D2              ;SET DISPLAY CTRLS - LEADING-ZERO BLANK, 1 DEC PLACE.
               MOVE    #1404H,D1            ; SET WHERE IT WILL APPEAR
               MOVE    CUR_TEMPO_FPB,D0     ;  SET FPB VALUE TO DISPLAY
                ABS_LONG
               JSR     WRITE_VALUE          ;WRITE D0 VALUE INTO SCREEN_BUFFER PER D1-D2 CTRLS.
               JSR     DISP_FIELD           ;COPY BUFFER FIELD TO LCD PER SAME CONTROLS.
                ABS_SHORT
               BRA.S   TEMP_SW_EXIT
;
TEMP_SW_Z0
               BCHG    #0,DIAGS_ENABLED
;
TEMP_SW_EXIT
               RTS
;
;
LIV_TEMP_SCREEN
               ASC     "TEMPO:       BPM"
               ASC     "   (     FPB)   "
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; PROCESS AN ACCELERANDO/RITARDANDO EVENT PARSED FROM A SEQUENCE -
; CALLED WITH THE A-R EVENT IN D7.L, LOOKING AS FOLLOWS:
;
;              00bb bbbb bbbb 1011  cccc cccc cccc cccc
;
;    bbbbbbbbbb        = NUMBER OF (QUARTER-NOTE) BEATS OVER WHICH TEMPO
;                        CHANGE IS TO TAKE PLACE (24 CLICKS PER BEAT).
;    cccccccccccccccc  = THE TEMPO CHANGE VALUE EXPRESSED AS A DELTA IN
;                        BPM * 10 (11 BITS SIGNED, EXTENDED TO 16 BITS).
;
; CALCULATE TEMPO CHANGE PER 96th NOTE (CLICK), RESOLVED TO 1/80th BPM -
; IF THIS DOESN'T COME OUT EVEN, TAKE CARE OF THE REMAINDER WITH ONE
; ADDITIONAL CLICK.
;
; WE DON'T EFFECT ANY TEMPO CHANGE HERE - THAT'S HANDLED BY SEPARATE
; CALLS TO UPDATE_ACC_RIT WHICH HAPPEN ONCE PER CLICK.
;
; REMEMBER, WE'RE IN A SEQUENCE-PARSING CONTEXT AT THIS POINT -
; COMPORT YOURSELF PROPERLY (WITH RESPECT TO REGISTERS, ETC).
; BE WARNED THAT WE WILL DESTROY THE CONTENTS OF D7.
;
START_ACC_RIT
               MOVE.L  D7,D0                ;MAKE A WORK COPY.
               SWAP    D0                   ;WORK ON # OF BEATS FIRST -
               ASR     #4,D0                ;GET RID OF THE CHAFF (EVENT ID CODE),
               MULU    #24,D0               ;CONVERT TO NUMBER OF CLICKS,
               MOVE    D0,ACCEL_RIT_BEATS   ;SAVE THE RESULT (TOTAL DURATION IN CLICKS) -
               MOVE    D0,ACCEL_RIT_B_LEFT  ;INITIALIZE NUMBER OF CLICKS REMAINING IN THIS A-R.
               BEQ.S   ST_A_R_20            ;IF # OF BEATS = 0, 'SUDDEN' A-R - HANDLE ALL AT ONCE.
;
               ADDQ    #1,ACCEL_RIT_B_LEFT  ;ELSE, BIZ AS USUAL - ADD 1 TO HANDLE REMAINDER
               EXT.L   D7                   ;LOWER WORD OF D7 = DELTA IN BPM * 10 -
               LSL     #3,D7                ;CONVERT IT TO BPM * 80,
               MOVE.L  D7,D6                ;SAVE RESULT FOR ROUNDING COMPENSATION BELOW,
               DIVS    D0,D7                ;DIVIDE BY NUMBER OF CLICKS IT EXTENDS ACROSS -
               MOVE    D7,ACCEL_RIT_DELTA   ;THIS IS AMOUNT TO CHANGE BY PER CLICK (IN BPM*80).
               MULU    D0,D7                ;NOW SCALE THIS RESULT BACK UP TO FULL-DURATION VALUE,
               SUB     D7,D6                ;TAKE DIFFERENCE FROM REAL ORIGINAL AS REMAINDER DELTA,
               MOVE    D6,ACCEL_RIT_REM     ;STORE IT FOR USE ON LAST CLICK OF A-R.
               BRA.S   ST_A_R_EXIT          ;OKAY, THAT'S ALL.
;
ST_A_R_20
                                            ;INSTANTANEOUS TEMPO CHANGE:
               MOVE    #1,ACCEL_RIT_B_LEFT  ;SET UP TO INVOKE LAST-CLICK A-R PROCESSING.
               LSL     #3,D7                ;SAVE TEMPO DELTA IN BPM*80 FORMAT,
               MOVE    D7,ACCEL_RIT_REM     ;IN THE VARIABLE WHICH HOLDS LAST-CLICK DELTA.
               CLR     ACCEL_RIT_DELTA      ;NO DELTA ON "OTHER" CLICKS (BEFORE THE LAST CLICK).
;
ST_A_R_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; PER-CLICK PROCESSING OF AN ACTIVE ACCELERANDO/RITARDANDO -
; CALLED ONCE PER CLICK PROCESSED WHILE SEQUENCER IS RUNNING, CHASING
; OR CUEING.
; IF AN A-R IS IN PROGRESS, THE PER-CLICK TEMPO DELTA IS COMBINED WITH
; THE CURRENT TEMPO, AND THE NUMBER-OF-CLICKS COUNT IS NOTCHED DOWN.
; IF THE A-R HAS GOTTEN TO THE LAST CLICK, THE LAST-CLICK (REMAINDER)
; TEMPO DELTA IS USED INSTEAD OF PER-CLICK DELTA, AND A-R IS PUT TO BED.
; THE NEW TEMPO IS PASSED TO THE TIME CHIP AND IS ALSO USED TO OFFSET
; THE REFERENCE TEMPO (I.E., THE REFERENCE FOR TAP-TRACK TEMPO CHANGES).
;
UPDATE_ACC_RIT
               TST     ACCEL_RIT_B_LEFT     ;IS THERE AN A-R IN PROGRESS ANYWAY?
               BEQ.S   UP_A_R_EXIT          ;EXIT IF NOT, DON'T WASTE "R" TIME.
               MOVE    CUR_T_BPM_8,D0       ;ELSE - WORK ON CURRENT TEMPO (HI-RES, BPM*80 VERSION).
               SUBQ    #1,ACCEL_RIT_B_LEFT  ;NOTCH DOWN THE COUNT OF CLICKS REMAINING IN THIS A-R.
               BEQ.S   UP_A_R_20            ;IF THIS IS THE LAST CLICK, USE REMAINDER TEMPO DELTA -
               ADD     ACCEL_RIT_DELTA,D0   ;ELSE, USE THE PER-CLICK TEMPO DELTA VALUE.
               BRA.S   UP_A_R_40
UP_A_R_20
               ADD     ACCEL_RIT_REM,D0     ;FOR LAST CLICK, USE REMAINDER TEMPO DELTA.
UP_A_R_40
               CMP     #20001,D0            ;CLIP NEW TEMPO AT LIMITS OF 250.0 & 40.0 BPM -
               BCS.S   UP_A_R_60            ;REMEMBER - TEMPO IS BEING HANDLED AS BPM*80 ....
               MOVE    #20000,D0
               BRA.S   UP_A_R_80
UP_A_R_60
               CMP     #3200,D0
               BCC.S   UP_A_R_80
               MOVE    #3200,D0
UP_A_R_80
               MOVE.L  #200000000,D1        ;CONVERT TO uSEC/CLICK BY DIVIDING INTO 200,000,000 -
               DIVU    D0,D1                ;FOR DETAILS OF THIS COMPUTATION, SEE BELOW.
;
               MOVE    CUR_TEMPO_USEC,D0    ;CAPTURE CURRENT DIFF 'TWEEN CUR_ AND REF_TEMPO_USEC,
               SUB     REF_TEMPO_USEC,D0    ;BEFORE CURRENT TEMPO IS UPDATED.
               MOVE    D0,BG_TEMP_9_B       ;STASH IT HERE WHILE WE GO OFF INTO SPACE.
;
               MOVE    D1,CUR_TEMPO_USEC    ;STORE NEW CURRENT TEMPO (IN uSEC PER CLICK FORM).
               BSR     USEC_TO_ALL          ;CONVERT TEMPO TO OTHER FORMS, TELL TIMING CHIP.
;
                                            ;NOW, OFFSET REFERENCE TEMPO AS APPROPRIATE:
               MOVEQ   #0,D0                ;USE LONG-WORD ARITHMETIC ....
               MOVE    BG_TEMP_9_B,D1       ;RETRIEVE (OLD CUR_TEMP - REF_TEMP) DIFFERENCE,
               EXT.L   D1
               MOVE    CUR_TEMPO_USEC,D0    ;APPLY THIS DELTA IN REVERSE TO NEW CURRENT TEMPO -
               SUB.L   D1,D0
                                            ;AS A NERD-LY NOTE, I'M NOT SURE IF THIS IS REALLY WHAT
                                            ;WE WANT - SOME DELTA SCALING MIGHT BE IN ORDER HERE.
;
               BVS.S   UP_A_R_C0            ;IF SUBTRACTION OVERFLOWED, CLIP AT MINIMUM TEMPO.
               CMPI.L  #10000,D0            ;CLIP AT LIMITS - FIRST, 250 BPM (10000usec/CLICK) -
               BCC.S   UP_A_R_A0
               MOVE.L  #10000,D0
UP_A_R_A0
               CMPI.L  #62500H,D0           ;NEXT, CHECK 40 BPM (62500 usec/CLICK) -
               BCS.S   UP_A_R_E0
UP_A_R_C0
               MOVE.L  #62500H,D0
UP_A_R_E0
               MOVE    D0,REF_TEMPO_USEC    ;AND, STORE OUR NEW, CLIPPED, WAY-COOL REFERENCE TEMPO.
;
UP_A_R_EXIT
               RTS
;
;
; DETAILS OF THE CONVERSION TO uSEC PER CLICK:
; IF Q = OUR BPM * 80 VALUE, THEN -
;    24Q = CLICKS/MIN * 80
;    24Q/80 = CLICKS/MIN
;    24Q/(80*60) = CLICKS/SEC = 24Q/4800 = Q/200
;    Q/(200*1,000,000) = CLICKS/USEC
; THUS, USEC/CLICK = 200,000,000/Q     (PRID QUO PRO ....)
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; PROCESS A TAP-TRACK TEMPO OFFSET EVENT PARSED FROM A SEQUENCE -
; CALLED WITH THE TAP-TRACK EVENT IN D7.L, LOOKING AS FOLLOWS:
;
;              rrrr rrrr rrrr 1010  cccc cccc cccc cccc
;
;    rrrrrrrrrrrr      =  RECORDED REFERENCE TEMPO (AS BPM * 10).
;    cccccccccccccccc  =  SIGNED OFFSET FROM RECORDED REFERENCE TEMPO
;                         (IN uSEC/CLICK).
;
; WE COMPUTE THE RATIO OF THE CURRENT (I.E., ACTUAL) REFERENCE TEMPO AND
; THE REFERENCE TEMPO ENCODED INTO THE TAP-TRACK EVENT WE ARE HANDLING -
; SINCE NATURALLY THE ACTUAL REFERENCE TEMPO MAY BE DIFFERENT FROM THE
; ONE IN EFFECT WHEN THIS TAP-TRACK EVENT WAS RECORDED - FOR EXAMPLE,
; IF THE INITIAL TEMPO OF THE SEQUENCE WAS LATER EDITED.  THIS RATIO IS
; USED TO SCALE THE TEMPO OFFSET ENCODED IN THE TAP-TRACK EVENT SO THAT
; IT RELATES TO THE ACTUAL REFERENCE TEMPO - TO WHICH THE SCALED OFFSET
; IS THEN APPLIED, TO ARRIVE AT THE NEW CURRENT TEMPO.  FINALLY, THE NEW
; CURRENT TEMPO IS STORED AND PROPAGATED THROUGHOUT THE SYSTEM -
; INCLUDING BEING PASSED TO THE TIMING CHIP.
;
TAP_TIME_OFFSET
               MOVE.L  D7,D0                ;MAKE A WORK COPY.
               SWAP    D0                   ;WORK ON RECORDED REFERENCE TEMPO FIRST -
               LSR     #4,D0                ;GET RID OF EXCESS (EVENT TYPE CODE),
               MOVE.L  #25000000,D1         ;CONVERT TO usec/CLICK -
               DIVU    D0,D1                ;25,000,000/(BPM * 10) = usec/CLICK (FIGURE IT OUT).
;
                                            ;COMPUTE RATIO OF RECORDED TO ACTUAL REFERENCE TEMPO:
               MOVEQ   #0,D0                ;CLEAR REGISTER FOR USE IN LONG-WORD ARITHMETIC,
               MOVE    REF_TEMPO_USEC,D0    ;FETCH ACTUAL REFERENCE TEMPO INTO LONG-WORD REALITY,
               MOVE.L  D0,D2                ;SAVE COPY FOR USE BELOW,
               DIVU    D1,D0                ;COMPUTE DEM RATIO IN D0 (MAX IS 250BPM/40BPM = 6.25).
               SWAP    D0                   ;PLACE REMAINDER ON BOTTOM (WHERE IT BELONGS),
               ASR.L   #3,D0                ;PRE-DIVIDE BY 8 SO MULTIPLY BELOW WON'T OVERFLOW.
;
                                            ;SCALE THE RECORDED TEMPO OFFSET:
               MOVE    D7,D1                ;GET uSEC/CLICK DELTA FROM RECORDED REFERENCE TEMPO,
               MULS    D0,D1                ;SCALE IT BY THE RECORDED-TO-ACTUAL REF TEMPO RATIO.
               ASL.L   #3,D1                ;SCALE RESULT BACK UP BY EIGHT (UNDO ABOVE PRE-SCALE),
               SWAP    D1                   ;DOWN TO 16-BITS (TELL REMAINDER TO TAKE FLYING LEAP),
               EXT.L   D1                   ;AND SIGN EXTEND BACK TO LONG-WORD REALITY.
;
                                            ;NOW, MAKE A NEW (CURRENT) TEMPO:
               ADD.L   D2,D1                ;COMBINE SCALED DELTA WITH EXISTING REFERENCE TEMPO.
               BVS.S   TTO_40               ;IF OVERFLOW, CLIP AT LONGEST TIME.
               CMPI.L  #10000,D1            ;CLIP AT LIMITS - FIRST, 250 BPM (10000usec/CLICK).
               BCC.S   TTO_20
               MOVE.L  #10000,D1
TTO_20
               CMPI.L  #62500H,D1           ;NEXT, CHECK 40 BPM (62500 usec/CLICK).
               BCS.S   TTO_60
TTO_40
               MOVE.L  #62500H,D1
TTO_60
               MOVE    D1,CUR_TEMPO_USEC    ;SAVE RESULT AS NEW CURRENT TEMPO -
               BSR     USEC_TO_ALL          ;CONVERT TO OTHER FORMS, PROPAGATE IT THROUGHOUT THE
                                            ;SYSTEM - INCLUDING THE TIME CHIP.
;
TTO_EXIT
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; TAP-TEMPO SWITCH HANDLER -
; CALLED WHENEVER THE TAP BUTTON IS - WELL, ER, TAPPED.
; THIS MEANS AN IMMEDIATE CHANGE IN THE CURRENT TEMPO - ALSO, IF THE
; SEQUENCER IS NOT RUNNING, THE CHANGE IS PROPAGATED TO THE INITIAL
; TEMPO OF THE CURRENT SEQUENCE (IF THE SEQUENCE EXISTS, OF COURSE).
; THE ENTIRE SYSTEM, INCLUDING THE TIME CHIP, GETS NOTICE OF THE CHANGE.
;
; FROM 2 TO 8 TAPS ARE MEASURED AND AVERAGED TO DERIVE THE CURRENT TEMPO.  TAPS MAY
; BE QUARTER OR EIGHTH NOTES.  TAPS THAT COME TOO CLOSE TOGETHER ARE IGNORED; TAPS
; THAT ARE TOO FAR APART ARE CONSIDERED TO BE THE START OF A NEW TRAIN OF TAPS.  THIS
; IS ALL REFERENCED TO LIMITS OF 40.0 AND 250.0 BPM.
;
; WHEN A TAP COMES THAT HAS NOT HAD A PREVIOUS FOR SOME WHILE, WE CLEAR OUT OUR SLEW
; BUFFERS AND LOAD THE TIME BETWEEN THE FIRST TWO AS THE TIME FOR ALL OF THEM.
;
; THERE ARE A COUPLE OF OTHER SPECIAL CASES WE MUST ALSO SERVICE - SUCH AS TAP IN
; TO START A SEQUENCE, AND RECORDING TAP TIME OFFSETS FOR TEMPO CONTROL IN A SEQUENCE.
;
TAP_BUTTON
               MOVE.L  REAL_LONG_TIME,D0    ;WHAT WHAT TIME IT REALLY IS
               SUB.L   LAST_TAP_TIME,D0     ; KNOCK OFF TIME LAST ONE HIT
               MOVE.L  D0,LAST_TAP_LENGTH   ;  (REMEMBER HOW LONG IT WAS)
               MOVE.L  REAL_LONG_TIME,LAST_TAP_TIME   ;...AND REMEMBER THIS TIME AS LAST TIME
               SWAP    D0                   ;SEE IF TIME WAS WAY TOO LONG
               TST     D0                   ;    A BIG DIFF MEANS LOWER WORD WRAPPED (OVER A MINUTE)
               BNE     TOO_LONG_A_TAP
               SWAP    D0                   ;         ELSE, CONTINUE & PROCESS
;
               MOVE.L  #7502DCH,D1          ;COMPARE AGAINST LIMITS (MINIMUM IN THE MSW, MAX IN LSW)
               TST     TAP_DIV_FLAG         ;ARE THE TAPS QUARTERS OR EIGHTHS?
               BNE.S   EIGHTH_TAPS          ;    IF EIGHTHS, COOL
               LSL.L   #1,D1                ;         ELSE, MULT BY 2 FOR PROPER COMPARISONS
EIGHTH_TAPS
               CMP     D0,D1                ;FIRST - SLOWER THAN 40.0 BPM?
               BCS     TOO_LONG_A_TAP       ;    IF SO, GOTTA RESTART OURSELVES
               SWAP    D1                   ;NEXT - FASTER THAT 250.0 BPM?
               CMP     D0,D1
               BCS.S   COOL_TAP             ;    IF TOO FAST, ROUND DOWN TO 250 BPM
               MOVE    D1,D0
COOL_TAP
               EXT.L   D0
;
; IF MADE IT THIS FAR, IN THE MIDDLE OF A RUN OF TAPS
;
               CMP     #1,TAP_SLEW_COUNT    ;IF THIS IS THE 2nd TAP IN A SKEIN, SPECIAL PROCESSING
               BEQ     INIT_TAP_TIMING
;
TAP_AVERAGING  ;PROPAGATE NEW TAP TIME THROUGH 8-LONG LIST
               MOVE    HITSTORY_7+2,HITSTORY_8+2 ;THESE VALUES ARE LONG WORDS TO EASE ADDING LETER -
               MOVE    HITSTORY_6+2,HITSTORY_7+2 ; BUT VALUE STORED IS ONLY A WORD.  SO, SLIGHT OFFSET
               MOVE    HITSTORY_5+2,HITSTORY_6+2 ; TRICKERY HERE TO SPEED THE MOVE/STORE UP.
               MOVE    HITSTORY_4+2,HITSTORY_5+2
               MOVE    HITSTORY_3+2,HITSTORY_4+2
               MOVE    HITSTORY_2+2,HITSTORY_3+2
               MOVE    HITSTORY_1+2,HITSTORY_2+2
               MOVE    D0,HITSTORY_1+2      ;D0 HELD THE LATEST HIT (HEH, HEH)
TEMPURA
               CLR.L   D1
;
               MOVE    TAP_SLEW_AMOUNT,D2   ;SEE HOW MANY WE ARE ACTUALLY SUPPOSED TO AVERAGE
               SUBQ    #1,D2                ; (WILL USE 1-7 DELTA TIMES TO AVERAGE 2-8 TAPS)
               LSL     #2,D2                ; (ROTATE INTO A JUMP TABLE OFFSET)
               MOVE.L  TAP_ENTRY_TABLE(PC,D2),A0
               JMP     (A0)
;
TAP_ENTRY_TABLE
               DC.L    T_AV_0               ;(NOTE - MIN SLEW AMOUNT IS 2 - FIRST 2 JUMPS = DUMMIES)
               DC.L    T_AV_1
               DC.L    T_AV_2
               DC.L    T_AV_3
               DC.L    T_AV_4
               DC.L    T_AV_5
               DC.L    T_AV_6
               DC.L    T_AV_7
               DC.L    T_AV_8
;
T_AV_8         ;ADD TOGETHER AS MANY TAPS AS WE ARE SUPPOSED TO AVERAGE
               ADD.L   HITSTORY_8,D1
T_AV_7
               ADD.L   HITSTORY_7,D1
T_AV_6
               ADD.L   HITSTORY_6,D1
T_AV_5
               ADD.L   HITSTORY_5,D1
T_AV_4
               ADD.L   HITSTORY_4,D1
T_AV_3
               ADD.L   HITSTORY_3,D1
T_AV_2
               ADD.L   HITSTORY_2,D1
T_AV_1
               ADD.L   HITSTORY_1,D1
T_AV_0
               LSR     #2,D2                ;(KNOCK TAP SLEW COUNT BACK DOWN TO NORMAL)
AVERAGE_THE_TAPS
               DIVU    D2,D1                ;CALC AVERAGE TIME PER TAP
               AND.L   #0FFFFH,D1           ; CLEAR OUT REMAINDER
               LSL.L   #8,D1                ;  MULTIPLY BY 1024 (1 REALTIME CLOCK = 1024 usec)
               LSL.L   #2,D1
               MOVEQ   #12,D3               ;NOW, CONVERT FROM QUARTER/EIGHTS TO CLICKS
               TST     TAP_DIV_FLAG         ; (IF QUARTERS, DIVIDE BY TWICE AS MUCH)
               BNE.S   MOTHERS_1
               ADD     D3,D3
MOTHERS_1
               DIVU    D3,D1                ;NOW DOWN TO usec/CLICK
               MOVE    D1,CUR_TEMPO_USEC
;
               BSR     USEC_TO_ALL          ;CONVERT TO OTHER FORMS, TELL THE TC
;
               ADDQ    #1,TAP_SLEW_COUNT    ;INC # OF TAPS IN THIS SKEIN
               MOVE    TAP_SLEW_COUNT,D2    ;RECOVER HOW MANY TIMES WE'VE TAPPED
;
               TST.B   TAP_TRACK_ON_FLAG    ;ARE WE IN TAP TRACK MODE?
               BNE     TAP_WHILE_RECORDING  ;    IF YES, GO LOOK INTO IT
;
               MOVE    CUR_TEMPO_USEC,REF_TEMPO_USEC  ;MAKE NEW REF TEMPO (FOR TAP TRACK)
;
;
TEST_FOR_TAP_IN        ;SEEING IF IN THE MODE TO TAP IN TO A START
               MOVE    COUNT_IN_METHOD,D0   ;ONLY IF TAP IN MODE SELECTED....
               CMP     #2,D0
               BNE.S   EXIT_TAP_HANDLER     ;    IF OFF OR MET CLICK, GIT....
;
               BTST    #6,XPORT_STATE       ;IF PLAY ON AND PAUSE OFF, GIT!  ALREADY STARTED
               BNE.S   OKAY_TO_TAP_IN       ;    (PAUSE ON - COOL CONDITION)
               BTST    #3,XPORT_STATE
               BNE.S   EXIT_TAP_HANDLER     ;    (PAUSE OFF, PLAY ON - GIT)
OKAY_TO_TAP_IN
               CMP     TAP_SLEW_AMOUNT,D2   ;    ELSE - HAVE WE TAPPED IN?
               BNE.S   EXIT_TAP_HANDLER
;
               MOVE.L  REAL_LONG_TIME,D0    ;SET UP TIMEOUT FOR MACHINE TO TAKE OFF
               ADD.L   LAST_TAP_LENGTH,D0   ; (DEMON IN BACKGROUND TO PICK THIS UP & LAUNCH IT)
               MOVE.L  D0,TAP_TIME_START
;
               MOVE    CUR_TEMPO_FPB,INIT_TEMPO_FPB   ;SINCE USEC_TO_ALL WAS KIND ENOUGH TO FIND
               MOVE    CUR_TEMPO_BPM,INIT_TEMPO_BPM   ; TYPES, COPY THEM FOR INIT_'s USE (TAP IN
               MOVE    CUR_TEMPO_USEC,INIT_TEMPO_USEC ; DOES INDEED RESET INIT TEMPO).
                ABS_LONG
               JSR     GET_CUR_SEQ_DIR      ;PLACE IN DIRECTORY
                ABS_SHORT
               MOVE    INIT_TEMPO_USEC,Q_INIT_TEMPO(A0)
;
               CMP.L   #TEMPO_CHANGE_SUB,CUR_SUB_BLOCK     ;ARE WE DISPLAYING INITIAL TEMPO?
               BNE.S   KRAFT_1                             ;BRANCH IF NOT, EXIT -
               ST      SUBFUN_INSTALL       ;ELSE, REQUEST REDISPLAY TO SHOW THE NEW TEMPO.
KRAFT_1
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
TOO_LONG_A_TAP ;IF TAP AT SLOWER TEMPO THAN 40.0 BPM, CONSIDER A NEW SKEIN STARTED
               MOVE    #1,TAP_SLEW_COUNT
;
               TST.B   TAP_TRACK_ON_FLAG    ;BE WE IN TAP_TRACK MODE?
               BEQ.S   EXIT_TAP_HANDLER     ;    IF NOT, CONTINUE...
;
               BTST    #1,XPORT_STATE       ;USER TURNED ON TRANSPORT?
               BEQ.S   EXIT_TAP_HANDLER     ;    IS NOT, THEN SPLIT
;
               TST     NOW_SEQ_STATUS       ;IF CURRENT SEQUENCE DOES NOT EXIST
               BEQ.S   EXIT_TAP_HANDLER     ;    THEN SPLIT
;
               TST.B   STARTED_TAPPING      ;IF PICKING UP WHERE WE LEFT OFF
               BNE     REINIT_TAP_TRACK     ;    THEN RESET
               BRA     INIT_TAP_TRACK       ;         ELSE, INITILAIZE RECORDING
;
NORMAL_FOIST_TAP
EXIT_TAP_HANDLER
               RTS     ; THE TIME OF ONE TAP TAPPING IS NOT OF INTEREST....
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
INIT_TAP_TIMING        ;2nd TAP - TAKE THIS TIME AS NEWEST; FILL OUT TABLE WITH CURRENT TEMPO
; TO REPRESENT OLD 'TAPS' FOR SLEWING PURPOSES.
               MOVE    CUR_TEMPO_USEC,D1
               TST     TAP_DIV_FLAG         ;(IF WE'RE DEALING IN EIGHTS, HALF TIME OF CURRENT TEMPO)
               BEQ.S   ATEM_1
               LSR     #1,D1
ATEM_1
               MULU    #24,D1                ;24 CLICKS/BEAT
               LSR.L   #8,D1                ; 1024 usec/'msec'
               LSR.L   #2,D1
;
;10NOV               EXT.L   D1
;10NOV               MOVEQ   #43,D3               ;GOTTA CONVERT FROM usec/CLICK TO msec/BEAT (1024/24)
;10NOV               DIVU    D3,D1
;
               TST.B   TAP_TRACK_ON_FLAG    ;ARE WE CREATING A TAP TRACK?
               BEQ.S   TULL_6               ;    IF NOT, CONTINUE...
               MOVE    D0,D1                ;         ELSE, IN SPITE OF SLEWING STEP, RECORD THIS
                                            ;         FIRST TAP TIME AS ALL OF HISTORY
TULL_6
               MOVE    D0,HITSTORY_1+2      ;NEW TIME IS NEW TIME
               MOVE    D1,HITSTORY_2+2      ; CURRENT TIME IS ALL OLD TIMES
               MOVE    D1,HITSTORY_3+2
               MOVE    D1,HITSTORY_4+2
               MOVE    D1,HITSTORY_5+2
               MOVE    D1,HITSTORY_6+2
               MOVE    D1,HITSTORY_7+2
               MOVE    D1,HITSTORY_8+2
               BRA     TEMPURA              ;    GO ON WITH THE SHOW
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               TITLE   "TAP TRACK STUFF"
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
TAP_WHILE_RECORDING    ;HMMM....  MAY BE RECORDING LIVE TAP TRACK
               BTST    #RECORD_BIT,XPORT_STATE   ;BE WE READY TO RECORD A TAP TRACK?
               BEQ     EXIT_TAP_HANDLER
;
;10NOV               CMP.L   #10000H,NOW_BAR      ;AT VERY START?
;10NOV               BEQ     INIT_TAP_TRACK       ;    IF SO, SET UP READ/WRITE
;
;10NOV               BTST    #PAUSE_BUTT,XPORT_STATE   ;RESTARTING PROCESS AFTER PAUSING?
;10NOV               BEQ     REINIT_TAP_TRACK     ;         IF SO, GET GOING AGAIN
                                            ;              ELSE.....
               MOVE.L  SEQ_WR_PTR,A6        ;LOAD UP CURRENT READ/WRITE POINTERS
               MOVE.L  SEQ1_DRD_PTR,A5
;
               MOVE    INIT_TEMPO_BPM,D0    ;ASSEMBLE DELTA TIME.  FIRST, LOAD REF TEMPO
               MOVE    CUR_TEMPO_USEC,D1    ; LOAD UP OUR MOST RECENTLY TAPPED TEMPO
               SUB     INIT_TEMPO_USEC,D1   ;  FORM DIFFERENCE
               LSL     #4,D0                ;FINISH FORMING TAP TRACK FIRST WORD
               OR      #10,D0               ; MASK ON ID
;
; THIS EVENT NOW LOOKS LIKE:
;              a bbbbbbbbbbb 1010      a = SIGN, b's = REF TEMPO IN BPM * 10 - 40
;               cccccccccccccccc       c's = OFFSET FROM REF TEMPO, IN usec/CLICK
;
               MOVE    D0,D7
                ABS_LONG
               JSR     SEQ_WRITE            ;WRITE EVENT
               MOVE    D1,D7
               JSR     SEQ_WRITE
                ABS_SHORT
;
               ADDQ    #1,NOW_BEAT          ;UPDATE BEAT ABOUT TO TAP
;
               MOVE    NOW_CLICK,D1         ;NOW - SEARCH FOR WHERE NEXT TAP TIME IS SUPPOSED TO
               ADD     CLICKS_PER_TAP,D1   ; GO.  LOCATION DESIRED IS WHERE WE ARE PLUS THE NUMBER
               CMP     CLICKS_THIS_BAR,D1   ; OF CLICKS PER TAP.  LOOKING FOR A TIME_ OR BAR_MARKER
               BEQ     TAP_INTO_NEXT_BAR    ; ON AFTER THE DESIRED TIME.  IF ONE WE FIND IS AFTER,
               MOVE    D1,NOW_CLICK         ; HAVE TO CREATE A TIME-MARKER AND PLACE IT.
;
               MOVE    HOLDING_EVENT,D7     ;ARE WE HOLDING ONTO A -MARKER FORM OUR LAST SEARCH?
               BNE.S   TULL_1               ;    IF YES, THAT'S 'THE NEXT WORD WE READ'
                ABS_LONG                    ;         ELSE, READ THE NEXT WORD
               JSR     SEQ1_DSTR_READ
                ABS_SHORT
TULL_1
               MOVE    D7,D0                ;COPY
               AND     #0FH,D0              ; STRIP TO ID
PLACEMAT_LOOP
               CMP     #0FH,D0              ;IF END_OF_SEQ
               BEQ     TAPPED_OUT           ;    THEN STOP PROCESS
               CMP     #8,D0                ;IF BAR_MARKER
               BEQ.S   CREATE_TIME_MARK     ;    THEN NEED TO CREATE A TIME_MARKER FOR NEXT TAP
               CMP     #9,D0                ;IF NOT TIME_MARKER
               BNE.S   EAT_AWAY             ;    THEN LOOK FURTHER
               MOVE    D7,D3                ;         ELSE, NEED TO FIND TIME
               LSR     #4,D3
               CMP     D1,D3                ;IS IT TIME WE'RE LOOKING FOR?
               BEQ     WAIT_HERE            ;    IF YES, PARK HERE
               BCC.S   CREATE_TIME_MARK     ;    IF AFTER, INSERT A TIME_MARKER FOR OURSELF
EAT_AWAY                                    ;         ELSE, KEEP LOOKING....
                ABS_LONG
               JSR     SEQ1_RMW_EATER       ;READ/WRITE THRU THIS EVENT, GET NEW ONE IN D7 (ID IN D0)
                ABS_SHORT
               BRA     PLACEMAT_LOOP
;
;
CREATE_TIME_MARK       ; NEED TO CREATE A TIME_MARKER FOR OUR NEXT TAP
               MOVE    D7,HOLDING_EVENT     ;MAKE COPY OF EVENT WE PRE-FETCHED AND FOUND INADEQUATE
               MOVE    D1,D7                ; GET  TIME OF NEXT TAP
               LSL     #4,D7                ;  MAKE ROOM FOR ID
               OR      #9,D7                ;   MASK ON THAT ID
                ABS_LONG
               JSR     SEQ_WRITE            ;    WRITE TIME_MARKER
                ABS_SHORT
               BRA     WAIT_PLUS_PENDING    ;     GET OUT, WAIT.
;
;
WAIT_HERE              ; FOUND A SUITABLE TIME_MARKER.  WRITE HIM, SAY NO-ONE PENDING, SPLIT.
                ABS_LONG
               JSR     SEQ_WRITE            ;WRITE TIME_MARKER WE FOUND - PERFECT FOR NEXT TAP.
                ABS_SHORT
               CLR     HOLDING_EVENT        ; SAY NO EVENT PENDING A WRITE.
               BRA     WAIT_FOR_NEXT_TAP    ;  GIT
;
;
TAP_INTO_NEXT_BAR      ; NEXT TAP IS SUPPOSED TO BE PLACED ON THE DOWNBEAT - AFTER THE NEXT
; BAR_MARKER.  LOOK FOR IT, DECODE IT (SO AS TO GET HOW MANY TAPS IN IT, ETC.), AND SET UP TO
; PLANT NEXT TAP_TIME HERE.
               MOVE    #1,NOW_BEAT          ;RESET BEAT NUMBER USER ABOUT TO HIT
;
               MOVE    HOLDING_EVENT,D7     ;ARE WE HOLDING ONTO A _MARKER FORM OUR LAST SEARCH?
               BNE.S   TULL_2               ;    IF YES, THAT'S 'THE NEXT WORD WE READ'
                ABS_LONG                    ;         ELSE, READ THE NEXT WORD
               JSR     SEQ1_DSTR_READ
                ABS_SHORT
TULL_2
               MOVE    D7,D0                ;COPY
               AND     #0FH,D0              ; STRIP TO ID
FACEMAT_LOOP
               CMP     #0FH,D0              ;IF END_OF_SEQ
               BEQ     TAPPED_OUT           ;    THEN STOP PROCESS
               CMP     #8,D0                ;IF BAR_MARKER
               BEQ.S   FOUND_BAR_MARK       ;    THEN FOUND WHAT WE'RE LOOKING FOR
                ABS_LONG                    ;         ELSE, KEEP LOOKING....
               JSR     SEQ1_RMW_EATER       ;READ/WRITE THRU THIS EVENT, GET NEW ONE IN D7 (ID IN D0)
                ABS_SHORT
               BRA     FACEMAT_LOOP
;
FOUND_BAR_MARK         ; READ, COPY, DECODE, SEE IF AN A/R FOLLOWING (IF SO, ALSO COPY), SPLIT
                ABS_LONG
               JSR     SEQ_WRITE            ;COPY 1st WORD
               SWAP    D7                   ; SAVE ASIDE
               JSR     SEQ1_DSTR_READ       ;  GET 2nd WORD
               JSR     SEQ_WRITE            ;   COPY
               JSR     BAR_MARKER_HANDLER   ;    DECODE (INTO BAR, CLICKS_THIS_BAR, RESET NOW_CLICK)
;
               MOVE    NOW_LAST_BAR,D0      ;     IF BAR_MARKER 'FORE END-OF-SEQ
               ADDQ    #1,D0
               CMP     NOW_BAR,D0           ;         THEN DONE.
               BNE     BEER_IS_GOOD
               CLR     HOLDING_EVENT
               BRA     TAP_STOP
BEER_IS_GOOD                                ;ELSE....
               MOVE    0(A5),D7             ;     SEE WHO'S AFTERWARDS
                ABS_SHORT
               MOVE    D7,D0
               AND     #0FH,D0              ;      (MASK TO ID)
               CMP     #0FH,D0              ;IF END_OF_SEQ
               BEQ     TAPPED_OUT           ;    THEN STOP PROCESS
               CMP     #11,D0               ;        A/R? (ACCELERANDO/RITARDO?)
               BNE.S   WAIT_FOR_NEXT_TAP    ;         IF NOT, COOL
                ABS_LONG                    ;              ELSE, COPY
               JSR     SEQ1_DSTR_READ       ;(READ FIRST WORD)
               JSR     SEQ_WRITE            ; (WRITE)
               JSR     SEQ1_DSTR_READ       ;  (READ SECOND)
               JSR     SEQ_WRITE            ;   (WRITE)
                ABS_SHORT
WAIT_FOR_NEXT_TAP      ; SAVE POINTERS, GET OUTA HERE.
               CLR     HOLDING_EVENT        ;NOTHING PENDING
WAIT_PLUS_PENDING
               MOVE.L  A6,SEQ_WR_PTR
               MOVE.L  A5,SEQ1_DRD_PTR
               ST      SUBFUN_INSTALL       ;REDISPLAY TEMPO, BEAT WE'RE ON
               RTS
;
;
INIT_TAP_TRACK         ; FIRST TAP AFTER DECIDING TO CREATE A TAP_TRACK - SET UP SEQUENCE READ/WRITE,
; SPLIT - WAITING FOR NEXT TAP UNTIL CAN START TELLING THE TIME OF THEM.
               ST      STARTED_TAPPING      ;FLAG TAP_STOP ROUTINE THAT IT'S OKAY TO TURNAROUND
;
               MOVE.L  SMPTE_NOW_HR,SMPTE_START_HR    ;FOR PURPOSES OF TAPPING AGAINST A SMPTE STRIPE
               MOVE.B  SMPTE_NOW_BT,SMPTE_START_BT    ; A LIVE PERFORMANCE, COPY SMPTE TIME USER HIT
                                                      ; THE FIRST TAP - IN THEORY, THAT'S WHEN THE
                                                      ; PERFORMANCE STARTED.
                ABS_LONG
               JSR     SEQ1_DRD_SETUP       ;PREP READ & WRITE ON CURRENT SEQUENCE
;
               MOVE.L  SEQ_WR_PTR,A6        ; LOAD UP CURRENT READ/WRITE POINTERS
               MOVE.L  SEQ1_DRD_PTR,A5
;
               JSR     SEQ1_DSTR_READ       ;  READ & COPY FIRST BAR_MARKER - FIRST TAP_TIME GOES HERE
               JSR     SEQ_WRITE
               SWAP    D7
               JSR     SEQ1_DSTR_READ
               JSR     SEQ_WRITE
               JSR     BAR_MARKER_HANDLER
               JSR     SEQ1_DSTR_READ       ;     SEE WHO'S AFTERWARDS
                ABS_SHORT
               MOVE    D7,HOLDING_EVENT
               MOVE    D7,D0
               AND     #0FH,D0              ;      (MASK TO ID)
               CMP     #11,D0               ;        A/R? (ACCELERANDO/RITARDO?)
               BNE.S   WAIT_FOR_SECOND_TAP  ;         IF NOT, COOL
                ABS_LONG                    ;              ELSE, COPY
               JSR     SEQ_WRITE            ;(FIRST WORD)
               JSR     SEQ1_DSTR_READ       ; (READ SECOND)
               JSR     SEQ_WRITE            ;  (WRITE SECOND)
                ABS_SHORT
               CLR     HOLDING_EVENT        ;NOTHING PENDING
WAIT_FOR_SECOND_TAP
               MOVE.L  A6,SEQ_WR_PTR        ;SAVE MEM POINTERS
               MOVE.L  A5,SEQ1_DRD_PTR
;
REINIT_TAP_TRACK       ; FROM HERE, FLICK 'PAUSE' OFF, AND WAIT FOR SECOND TAP.
               OR      #PAUSE_LED_MASK,LED_EXTINGUISH
               BCLR    #6,XPORT_STATE
;
               ST      SUBFUN_INSTALL       ;REDISPLAY - IF IN TAP SCREEN, SHOWING BRA & BEAT
;
               RTS
;
;
TAPPED_OUT             ; TAPPED UNTIL END_OF_SEQUENCER - WRITE THAT MARKER, TURNAROUND, KILL TRANSPORT.
                ABS_LONG
               JSR     SEQ_WRITE            ;CAP SEQUENCE
               MOVE.L  A6,SEQ_WR_PTR        ; SAVE POINTERS
               MOVE.L  A5,SEQ1_DRD_PTR
               BRA     TAPPED_OFF           ;  TURNAROUND SEQUENCE.
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
               SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
;             TAP TRANSPORT - WE TAKE OVER THE FUNCTIONS OF A COUPLE OF BUTTONS WHILST RECORDING
;              THE TAP TRACK.  THE NORMAL TRANSPORT ROUTINE ONLY CALLS US IF IN THIS MODE.  WE
;              IGNORE THE ERASE, REWIND, AND FAST FORWARD BUTTONS IN THIS MODE.  HITTING PLAY,
;              PAUSE, OR RECORD IMMEDIATELY PUTS ALL 3 LEDS ON.  TAPPING IN THE APROPOS NUMBER OF
;              TAPS STARTS US UP (AND TAKES THE PAUSE BUTTON OFF).  WAITING TOO LONG 'TWEEN TAPS
;              (DETECTED BOTH ABOVE AND BY TAP_DEMON_2, IN THE BACKGROUND) PUTS PAUSE ON AND WAITS
;              FOR A CONTINUATION.  STOP TURNS EVERYTHING OFF.
;
;03JUN;
;03JUNTAP_PAUSE
;03JUNTAP_PLAY
;03JUNTAP_REC
;03JUN;
;
TAP_RECORD
               TST     NOW_SEQ_STATUS       ;IF SEQUENCE NOT ALLOCATED
               BEQ.S   EXIT_TAP_TRANS       ;    THEN SPLIT
;
                                            ;ELSE:
                                            ;TURN ON ALL TRANSPORT LEDs (EXCEPT ERASE, NATCH).
               OR      #PLAY_LED_MASK+PAUSE_LED_MASK+RECORD_LED_MASK,LED_STEADY
                                            ;TURN ON CORRESPONDING BITS IN TRANSPORT STATUS BYTE.
               OR.B    #PLAY_MASK+PAUSE_MASK+RECORD_MASK,XPORT_STATE
;
EXIT_TAP_TRANS
               RTS
;
;
;
;
TAP_STOP
               TST.B   STARTED_TAPPING      ;IF NOT STARTED
               BEQ.S   TULL_5               ;    THEN DO NOT PLAY WITH SEQUENCER
               MOVE    HOLDING_EVENT,D7     ;HANGING ONTO A _MARKER?
               BEQ.S   TULL_7               ;    IF NO, GO
                                            ;         ELSE, COPY THIS EVENT OVER
               MOVE.L  SEQ_WR_PTR,A6        ; LOAD UP CURRENT READ/WRITE POINTERS
               MOVE.L  SEQ1_DRD_PTR,A5
               JSR     SEQ_WRITE
               JSR     SEQ1_DSTR_READ       ;  READ & COPY SECOND WORD
               JSR     SEQ_WRITE
               MOVE.L  A6,SEQ_WR_PTR
               MOVE.L  A5,SEQ1_DRD_PTR
TULL_7
               JSR     SEQ_CONSOLIDATE      ;IF HIT STOP BEFORE DONE, FINISH COPYING SEQUENCE
TAPPED_OFF
               JSR     SEQ_TURNAROUND       ; TURN AROUND, CLEAN UP
               JSR     UPDATE_SEQ_SIZE
;
TULL_5
                                            ;TURN OFF PLAY, RECORD, PAUSE LEDs:
               OR      #PLAY_LED_MASK+PAUSE_LED_MASK+RECORD_LED_MASK,LED_EXTINGUISH
;
               SF      XPORT_STATE          ;CLEAN OUT THE XPORT STATE
;
               MOVE.L  #10000H,NOW_BAR      ;RESET BAR & CLICK
               MOVE    #1,NOW_BEAT          ; RESET BEAT NUMBER
;
               MOVE    INIT_TEMPO_USEC,D0   ;FINALLY - RELOAD INITIAL TEMPO
               MOVE    D0,CUR_TEMPO_USEC
               MOVE    D0,REF_TEMPO_USEC
               BSR     USEC_TO_ALL          ; CALC IN OTHER FORMS, TELL TC
;
               ST      SUBFUN_INSTALL       ;OUR STOPPING MAY HAVE BROUGHT ABOUT CHANGES - DISPLAY THEM.
               SF      STARTED_TAPPING      ; KNOCK DOWN 'TAPPING' FLAG
               CLR     HOLDING_EVENT        ;  NOTHING PENDING, EH, BRO'?
;
               RTS
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                SKIP
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
; CONVERT CUR_TEMPO_USEC - CURRENT TEMPO IN uSEC PER CLICK (96th NOTE) -
; INTO ALL OTHER FORMS IN WHICH CURRENT TEMPO IS MAINTAINED, AND PASS IT
; ON TO TIMING CHIP AS WELL.
;
USEC_TO_ALL
               TST.B   SHOWING_TEMPO        ;IF THE TEMPO UP/DOWN SWITCHES ARE BEING DIDDLED,
               BNE.S   UTA_20               ;DON'T FUCK UP THE SCREEN WHICH THEY HAVE CALLED UP.
;
               CMP.L   #CLOCK_TEMPO_SUB,CUR_SUB_BLOCK      ;IS "CURRENT TEMPO" SCREEN IN DISPLAY?
               BNE.S   UTA_20                              ;BRANCH IF NOT, NO REDISPLAY NEEDED.
;
               ST      SUBFUN_INSTALL       ;ELSE, SHOW EVERYBODY THE NEW CURRENT TEMPO.
;
UTA_20
               MOVE.L  #200000000,D0        ;CONVERT CURRENT TEMPO FROM uSEC/CLICK TO BPM * 80.
               MOVE    CUR_TEMPO_USEC,D1
               BNE.S   UTA_40               ;IF WE CAME IN WITH BOGUS CURRENT TEMPO VALUE,
               MOVE    #25000,D1            ;FUDGE IT TO 100 BPM (MYSTERIOUS CRASH BLOCK).
UTA_40
               DIVU    D1,D0                ;ON TO BPM-LAND ....
               MOVE    D0,CUR_T_BPM_8       ;STORE IN BPM * 80 (HI-RES FOR ACCEL/RITARD HANDLING),
               LSR     #3,D0
               MOVE    D0,CUR_TEMPO_BPM     ;AS WELL AS IN BPM * 10 FORMAT (FOR EDITING, STORAGE).
;
               MOVE.B  SMPTE_NOW_T_1,D0     ;FPB DEPENDS UPON SMPTE TYPE -
               EXT     D0
               LSL     #1,D0                          ;CONVERT TYPE SETTING INTO WORD INDEX,
               MOVE    SMPTE_MULCH_TBL(PC,D0),D0      ;LOAD SMPTE FPS * 100 FOR CURRENT SMPTE TYPE,
               MULU    #60,D0               ;MULTIPLY BY 60 SECONDS/MINUTE,
               DIVU    CUR_TEMPO_BPM,D0     ;DIVIDE BY CURRENT BEATS/MINUTE * 10 -
               MOVE    D0,CUR_TEMPO_FPB     ;NOW WE GOT FPB * 10 - STORE IT.
;
               MOVEQ   #NEG_EXT+0F2H,D0     ;FINALLY, TELL TIMING CHIP ABOUT NEW TEMPO.
               JSR     WRITE_TO_TC
               MOVE    D1,D0                ;THIS IS OUR TEMPO IN uSEC/CLICK, AS YOU RECALL ....
               LSR     #8,D0                ;SEND M.S.BYTE FIRST,
               JSR     WRITE_TO_TC
               MOVE    D1,D0                ;FOLLOWED BY L.S.BYTE.
               JSR     WRITE_TO_TC
;
UTA_EXIT
               RTS
;
;
;
SMPTE_MULCH_TBL
               DC.W    2400
               DC.W    2500
               DC.W    2997
               DC.W    3000
;
;
; FETCH CURRENT VALUE OF INIT_TEMPO_USEC, PROPAGATE IT:
;
INIT_TEMPO_TO_ALL
;
               MOVE    INIT_TEMPO_USEC,D0   ;FINALLY - RELOAD INITIAL TEMPO,
               MOVE    D0,CUR_TEMPO_USEC
               MOVE    D0,REF_TEMPO_USEC
               BRA     USEC_TO_ALL          ;PROPAGATE TO REST OF THE WORLD, INCLUDING TIME CHIP -
                                            ;RETURN THROUGH, BY THE WAY ....
;
;
;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
